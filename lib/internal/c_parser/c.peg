%{
library binary_declarations.internal.c_parser;

import "package:binary_declarations/binary_declarations.dart";

Identifier _ident(List parts) {
  var list = [];
  for (var part in parts) {
    if (part != null) {
      list.add(part);
    }
  }

  return new Identifier(name: list.join(" "));
}

List _createParameters(List parameters, ParameterDeclaration vaList) {    
  var list = <ParameterDeclaration>[];
  list.addAll(parameters);
  if (vaList != null) {
    list.add(vaList);  
  }
  
  return list;
}

int _escape(String ch) {
  switch(ch) {
    case "a":
      return 0x07;
    case "b":
      return 0x08;
    case "f":
      return 0x0c;
    case "n":
      return 0x0a;
    case "r":
      return 0x0d;
    case "t":
      return 0x09;
    case "v":
      return 0x0b;
    case "\'":
      return 0x27;
    case "\"":
      return 0x22;
    case "\?":
      return 0x3f;
    default:
      throw new StateError("Unknown escape sequence: \\$ch");  
  }
}

int _parseInt(String sign, String digits, int radix) {
  if (sign == null) {
    sign = "";
  }
  return int.parse("$sign$digits", radix: radix);   
}

}%

### Sentences (nonterminals) ###

Declarations <-
  LEADING_SPACES? DeclarationList? EOF { $$ = $2; }

DeclarationList <-
  Declaration*

Declaration <-
  FunctionDeclaration SEMICOLON+ { $$ = $1; }
  / StructureDeclaration SEMICOLON+ { $$ = $1; }
  / EnumDeclaration SEMICOLON+ { $$ = $1; }
  / TypedefDeclaration SEMICOLON+ { $$ = $1; }
  / VariableDeclaration SEMICOLON+ { $$ = $1; }
  / SEMICOLON+ { $$ = new EmptyDeclaration(); }

FunctionDeclaration <-
  Metadata? TypeQualifiers? FunctionDeclarator { $$ = new FunctionDeclaration(declarator: $3, metadata: $1, qualifiers: $2); }
  / Metadata? TypeQualifiers? Type FunctionDeclarator { $$ = new FunctionDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3); }

Metadata <-
  DeclarationSpecifier+ { $$ = new DeclarationSpecifiers(specifiers: $1); }

DeclarationSpecifier <-
  ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN { $$ = new DeclarationSpecifier(modifiers: $4); }

DeclarationModifierList <-
  DeclarationModifier (COMMA DeclarationModifier)* { $$ = new DeclarationModifiers(modifiers: _list($1, $2)); }

DeclarationModifier <-
  Identifier OPEN_PAREN DeclarationModifierArgumentList? CLOSE_PAREN { $$ = new DeclarationModifier(arguments: $3, identifier: $1); }
  / Identifier { $$ = new DeclarationModifier(identifier: $1); }

DeclarationModifierArgumentList <-
  DeclarationModifierArgument (COMMA DeclarationModifierArgument)* { $$ = _list($1, $2); }

DeclarationModifierArgument <-
  STRING_LITERAL
  / IntegerLiteral

TypeQualifiers <-
  TypeQualifier+ { $$ = new TypeQualifiers(qualifiers: $1); }

TypeQualifier <-
  (CONST / VOLATILE) Metadata? { $$ = new TypeQualifier(identifier: $1, metadata: $2); }

FunctionDeclarator <-
  PointerSpecifiers? Identifier FunctionParameters Metadata? { $$ = new Declarator(identifier: $2, metadata: $4, parameters: $3, pointers: $1); }

PointerSpecifiers <-
  PointerSpecifier+ { $$ = new PointerSpecifiers(specifiers: $1); }

PointerSpecifier <-
  ASTERISK Metadata? TypeQualifiers? { $$ = new PointerSpecifier(metadata: $2, qualifiers: $3); }

FunctionParameters <-
  OPEN_PAREN FunctionParameterList? CLOSE_PAREN { $$ = new FunctionParameters(declarations: $2); }

FunctionParameterList <-
  FunctionParameterListNoVaList (COMMA VA_LIST_PARAMETER { $$ = $2; })? { $$ = _createParameters($1, $2); }

FunctionParameterListNoVaList <-
  FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* { $$ = _list($1, $2); }

FunctionParameterDeclaration <-
  ParameterDeclarationNotAbstract
  / ParameterDeclarationAbstract

ParameterDeclarationNotAbstract <-
  Metadata? TypeQualifiers? Type FunctionDeclarator { $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3); }
  / Metadata? TypeQualifiers? Type FunctionPointerDeclarator { $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3); }
  / Metadata? TypeQualifiers? Type DeclaratorNotAbstract { $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3); }

Type <-
  DefinedType
  / IntegerType
  / FloatType
  / VoidType
  / BoolType
  / StructureType
  / EnumType

DefinedType <-
  Identifier Metadata? TypeQualifiers? { $$ = new DefinedTypeSpecification(identifier: $1, metadata: $2, qualifiers: $3); }

IntegerType <-
  SIGNEDNESS? (SHORT / LONG_TYPE) INT? Metadata? TypeQualifiers? { $$ = new BuiltinTypeSpecification(identifier: _ident([$1, $2, $3]), metadata: $4, qualifiers: $5, typeKind: TypeSpecificationKind.INTEGER); }
  / SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? { $$ = new BuiltinTypeSpecification(identifier: _ident([$1, $2]), metadata: $3, qualifiers: $4, typeKind: TypeSpecificationKind.INTEGER); }
  / SIGNEDNESS Metadata? TypeQualifiers? { $$ = new BuiltinTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3, typeKind: TypeSpecificationKind.INTEGER); }

FloatType <-
  (FLOAT / DOUBLE) Metadata? TypeQualifiers? { $$ = new BuiltinTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3, typeKind: TypeSpecificationKind.FLOAT); }

VoidType <-
  VOID Metadata? TypeQualifiers? { $$ = new BuiltinTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3, typeKind: TypeSpecificationKind.VOID); }

BoolType <-
  BOOL Metadata? TypeQualifiers? { $$ = new BuiltinTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3, typeKind: TypeSpecificationKind.BOOL); }

StructureType <-
  StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? { $$ = new StructureTypeSpecification(metadata: $3, elaboratedType: $1, members: $2, qualifiers: $4); }
  / StructureTypeSpecifierWithTag Metadata? TypeQualifiers? { $$ = new StructureTypeSpecification(metadata: $2, elaboratedType: $1, qualifiers: $3); }

StructureTypeSpecifier <-
  (STRUCT / UNION) Metadata? Identifier? { $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3); }

StructureMemberList <-
  OPEN_BRACE StructureMember+ CLOSE_BRACE { $$ = $2; }

StructureMember <-
  BitFieldParameterDeclaration SEMICOLON { $$ = $1; }
  / ParameterDeclarationNotAbstract SEMICOLON { $$ = $1; }
  / ParameterDeclarationAbstract SEMICOLON { $$ = $1; }

BitFieldParameterDeclaration <-
  Metadata? TypeQualifiers? Type BitFieldDeclaratorNotAbstract { $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3); }
  / Metadata? TypeQualifiers? Type BitFieldDeclaratorAbstract { $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3); }

BitFieldDeclaratorNotAbstract <-
  Identifier COLON IntegerLiteral Metadata? { $$ = new Declarator(identifier: $1, metadata: $4, width: $3); }

BitFieldDeclaratorAbstract <-
  Identifier? COLON IntegerLiteral Metadata? { $$ = new Declarator(identifier: $1, metadata: $4, width: $3); }

ParameterDeclarationAbstract <-
  Metadata? TypeQualifiers? Type DeclaratorAbstract { $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3); }
  / Metadata? TypeQualifiers? Type { $$ = new ParameterDeclaration(metadata: $1, qualifiers: $2, type: $3); }

DeclaratorAbstract <-
  PointerSpecifiers ArrayDimensions Metadata? { $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1); }
  / PointerSpecifiers? ArrayDimensions Metadata? { $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1); }
  / PointerSpecifiers ArrayDimensions? Metadata? { $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1); }

ArrayDimensions <-
  Dimension+ { $$ = new ArrayDimensions(dimensions: $1); }

Dimension <-
  OPEN_BRACKET IntegerLiteral? CLOSE_BRACKET { $$ = $2; }

StructureTypeSpecifierWithTag <-
  (STRUCT / UNION) Metadata? Identifier { $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3); }

EnumType <-
  EnumTypeSpecifier OPEN_BRACE EnumeratorList CLOSE_BRACE Metadata? TypeQualifiers? { $$ = new EnumTypeSpecification(metadata: $5, elaboratedType: $1, qualifiers: $6, enumerators: $3); }
  / EnumTypeSpecifierWithTag Metadata? TypeQualifiers? { $$ = new EnumTypeSpecification(metadata: $2, elaboratedType: $1, qualifiers: $3); }

EnumTypeSpecifier <-
  ENUM Metadata? Identifier? { $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3); }

EnumeratorList <-
  Enumerator (COMMA Enumerator)* COMMA? { $$ = _list($1, $2); }

Enumerator <-
  Identifier ASSIGN IntegerLiteral { $$ = new Enumerator(identifier: $1, value: $3); }
  / Identifier { $$ = new Enumerator(identifier: $1); }

EnumTypeSpecifierWithTag <-
  ENUM Metadata? Identifier { $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3); }

FunctionPointerDeclarator <-
  PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN FunctionParameters ArrayDimensions? Metadata? { $$ = new Declarator(dimensions: $7, functionPointers: $3, identifier: $4, metadata: $8, parameters: $6, pointers: $1); }

DeclaratorNotAbstract <-
  PointerSpecifiers? Identifier ArrayDimensions? Metadata? { $$ = new Declarator(dimensions: $3, identifier: $2, metadata: $4, pointers: $1); }

StructureDeclaration <-
  Metadata? TypeQualifiers? StructureType { $$ = new StructureDeclaration(metadata: $1, qualifiers: $2, type: $3); }

EnumDeclaration <-
  Metadata? TypeQualifiers? EnumType { $$ = new EnumDeclaration(metadata: $1, qualifiers: $2, type: $3); }

TypedefDeclaration <-
  Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList { $$ = new TypedefDeclaration(declarators: $5, metadata: $1, qualifiers: $2, type: $4, typedef: $3); }

TypedefSpecifier <-
  TYPEDEF Metadata? TypeQualifiers? { $$ = new TypedefSpecifier(metadata: $2, qualifiers: $3); }

TypeDeclaratorList <-
  TypeDeclarator (COMMA TypeDeclarator)* { $$ = _list($1, $2); }

TypeDeclarator <-
  FunctionDeclarator
  / FunctionPointerDeclarator
  / DeclaratorNotAbstract
  / TypedefFunctionDeclarator

TypedefFunctionDeclarator <-
  PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN FunctionParameters Metadata? { $$ = new Declarator(identifier: $3, metadata: $6, parameters: $5, pointers: $1); }

VariableDeclaration <-
  Metadata? TypeQualifiers? Type VariableDeclaratorList { $$ = new VariableDeclaration(declarators: $4, metadata: $1, qualifiers: $2, type: $3); }

VariableDeclaratorList <-
  VariableDeclarator (COMMA VariableDeclarator)* { $$ = _list($1, $2); }

VariableDeclarator <-
  DeclaratorNotAbstract

### Lexemes (tokens) ###

ASSIGN <-
  '=' SPACING { $$ = $1; }

ASTERISK <-
  '*' SPACING { $$ = $1; }

ATTRIBUTE <-
  '__attribute__' !IDENT_PART SPACING { $$ = $1; }

BOOL <-
  '_Bool' !IDENT_PART SPACING { $$ = $1; }

CHAR <-
  'char' !IDENT_PART SPACING { $$ = $1; }

CLOSE_BRACE <-
  '}' SPACING { $$ = $1; }

CLOSE_BRACKET <-
  ']' SPACING { $$ = $1; }

CLOSE_PAREN <-
  ')' SPACING { $$ = $1; }

COLON <-
  ':' SPACING { $$ = $1; }

COMMA <-
  ',' SPACING { $$ = $1; }

CONST <-
  'const' !IDENT_PART SPACING { $$ = new Identifier(name: $1); }

DOUBLE <-
  'double' !IDENT_PART SPACING { $$ = $1; }

ENUM <-
  'enum' !IDENT_PART SPACING { $$ = $1; }

EOF <-
  !.

FLOAT <-
  'float' !IDENT_PART SPACING { $$ = $1; }

INT <-
  'int' !IDENT_PART SPACING { $$ = $1; }

Identifier <-
  IDENT { $$ = new Identifier(name: $1); }

IntegerLiteral <-
  HEXADECIMAL_LITERAL
  / OCTAL_LITERAL
  / INTEGER_LITERAL

LEADING_SPACES <-
  SPACING

LONG_TYPE <-
  LONG LONG { $$ = "long long"; }
  / LONG

OPEN_BRACE <-
  '{' SPACING { $$ = $1; }

OPEN_BRACKET <-
  '[' SPACING { $$ = $1; }

OPEN_PAREN <-
  '(' SPACING { $$ = $1; }

SEMICOLON <-
  ';' SPACING { $$ = $1; }

SHORT <-
  'short' !IDENT_PART SPACING { $$ = $1; }

SIGNEDNESS <-
  SIGNED
  / UNSIGNED

STRING_LITERAL <-
  STRING_LITERAL_PART+ { $$ = new StringLiteral(text: _text(), value: $1.join()); }

STRUCT <-
  'struct' !IDENT_PART SPACING { $$ = $1; }

TYPEDEF <-
  'typedef' !IDENT_PART SPACING { $$ = $1; }

UNION <-
  'union' !IDENT_PART SPACING { $$ = $1; }

VA_LIST_PARAMETER <-
  VA_LIST_TYPE { $$ = new ParameterDeclaration(type: $1); }

VOID <-
  'void' !IDENT_PART SPACING { $$ = $1; }

VOLATILE <-
  'volatile' !IDENT_PART SPACING { $$ = new Identifier(name: $1); }

### Morphemes ###

COMMENT <-
  '//' (!EOL .)* (EOL / !.)

ELLIPSIS <-
  '...' SPACING { $$ = $1; }

EOL <-
  '\r\n'
  / [\n\r]

ESCAPE_SEQUENCE <-
  SIMPLE_ESCAPE_SEQUENCE
  / OCTAL_ESCAPE_SEQUENCE
  / HEXADECIMAL_ESCAPE_SEQUENCE
  / UNIVERSAL_CHARCTER_NAME

HEXADECIMAL_DIGIT <-
  [0-9A-Fa-f]

HEXADECIMAL_ESCAPE_SEQUENCE <-
  '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 { $$ = int.parse(_text(2), radix: 16); }

HEXADECIMAL_ESCAPE_SEQUENCE1 <-
  HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 { $$ = _text(); }
  / ''

HEXADECIMAL_LITERAL <-
  HEXADECIMAL_NUMBER SPACING { $$ = $1; }

HEXADECIMAL_NUMBER <-
  HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT+ { $$ = new IntegerLiteral(text: _text() ,value: int.parse(_text(2), radix: 16)); }

HEXADECIMAL_PREFIX <-
  '0x'
  / '0X'

HEX_QUAD <-
  HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT { $$ = _text(); }

IDENT <-
  !RESERVED_WORD IDENT_START IDENT_CONT* SPACING { $$ = _flatten([$2, $3]).join(); }

IDENT_CONT <-
  IDENT_START
  / [0-9]

IDENT_PART <-
  IDENT_START
  / IDENT_CONT

IDENT_START <-
  [A-Z_a-z]

INTEGER_LITERAL <-
  INTEGER_NUMBER SPACING { $$ = $1; }

INTEGER_NUMBER <-
  SIGN? [0-9]+ { $$ = new IntegerLiteral(text: _text(), value: int.parse(_text(), radix: 10)); }

LONG <-
  'long' !IDENT_PART SPACING { $$ = $1; }

MINUS <-
  '-' SPACING { $$ = $1; }

OCTAL_DIGIT <-
  [0-7]

OCTAL_ESCAPE_SEQUENCE <-
  '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT { $$ = int.parse(_text(1), radix: 8); }
  / '\\' OCTAL_DIGIT OCTAL_DIGIT { $$ = int.parse(_text(1), radix: 8); }
  / '\\' OCTAL_DIGIT { $$ = int.parse($2, radix: 8); }

OCTAL_LITERAL <-
  OCTAL_NUMBER SPACING { $$ = $1; }

OCTAL_NUMBER <-
  SIGN? [0] [0-9]+ { $$ = new IntegerLiteral(text: _text(), value: int.parse(_text(), radix: 8)); }

PLUS <-
  '+' SPACING { $$ = $1; }

RESERVED_WORD <-
  ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT)
  / '__attribute__'

SIGN <-
  PLUS
  / MINUS

SIGNED <-
  'signed' !IDENT_PART SPACING { $$ = $1; }

SIMPLE_ESCAPE_SEQUENCE <-
  [\\] ["'?\\a-bfnrtv] { $$ = _escape($1); }

SPACE <-
  [\t-\n\r ]

SPACING <-
  (SPACE / COMMENT)*

STRING <-
  '"' STRING_CHAR_SEQUENCE? '"' { $$ = $2 == null ? "" : new String.fromCharCodes($2); }
  / 'L"' STRING_CHAR_SEQUENCE? '"' { $$ = $2 == null ? "" : new String.fromCharCodes($2); }

STRING_CHAR <-
  ![\n\r"\\] . { $$ = $2.codeUnitAt(0); }
  / ESCAPE_SEQUENCE

STRING_CHAR_SEQUENCE <-
  STRING_CHAR+

STRING_LITERAL_PART <-
  STRING SPACING { $$ = $1; }

UNIVERSAL_CHARCTER_NAME <-
  '\\U' HEX_QUAD HEX_QUAD { $$ = int.parse(_text(2), radix: 16); }
  / '\\u' HEX_QUAD { $$ = int.parse(_text(2), radix: 16); }

UNSIGNED <-
  'unsigned' !IDENT_PART SPACING { $$ = $1; }

VA_LIST_TYPE <-
  ELLIPSIS { $$ = new VaListTypeSpecification(); }

