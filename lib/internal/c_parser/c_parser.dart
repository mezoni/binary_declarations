// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

import "package:binary_declarations/binary_declarations.dart";

Identifier _ident(List parts) {
  var list = [];
  for (var part in parts) {
    if (part != null) {
      list.add(part);
    }
  }

  return new Identifier(name: list.join(" "));
}

List _createParameters(List parameters, ParameterDeclaration vaList) {    
  var list = <ParameterDeclaration>[];
  list.addAll(parameters);
  if (vaList != null) {
    list.add(vaList);  
  }
  
  return list;
}

int _escape(String ch) {
  switch(ch) {
    case "a":
      return 0x07;
    case "b":
      return 0x08;
    case "f":
      return 0x0c;
    case "n":
      return 0x0a;
    case "r":
      return 0x0d;
    case "t":
      return 0x09;
    case "v":
      return 0x0b;
    case "\'":
      return 0x27;
    case "\"":
      return 0x22;
    case "\?":
      return 0x3f;
    default:
      throw new StateError("Unknown escape sequence: \\$ch");  
  }
}

int _parseInt(String sign, String digits, int radix) {
  if (sign == null) {
    sign = "";
  }
  return int.parse("$sign$digits", radix: radix);
}

class CParser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));
  
  static final List<String> _expect0 = <String>["EOF"];
  
  static final List<String> _expect1 = <String>[];
  
  static final List<String> _expect10 = <String>["\'*\'"];
  
  static final List<String> _expect11 = <String>["\'(\'"];
  
  static final List<String> _expect12 = <String>["\'char\'", "\'int\'", "\'long\'", "\'short\'", "SIGNEDNESS"];
  
  static final List<String> _expect13 = <String>["\'char\'", "\'int\'", "\'long\'", "\'short\'"];
  
  static final List<String> _expect14 = <String>["\'long\'", "\'short\'"];
  
  static final List<String> _expect15 = <String>["\'double\'", "\'float\'"];
  
  static final List<String> _expect16 = <String>["\'void\'"];
  
  static final List<String> _expect17 = <String>["\'_Bool\'"];
  
  static final List<String> _expect18 = <String>["\'struct\'", "\'union\'"];
  
  static final List<String> _expect19 = <String>["\'{\'"];
  
  static final List<String> _expect2 = <String>["\';\'", "\'_Bool\'", "\'char\'", "\'double\'", "\'enum\'", "\'float\'", "\'int\'", "\'long\'", "\'short\'", "\'struct\'", "\'typedef\'", "\'union\'", "\'void\'", "Identifier", "SIGNEDNESS"];
  
  static final List<String> _expect20 = <String>["\':\'"];
  
  static final List<String> _expect21 = <String>["\'*\'", "\'[\'"];
  
  static final List<String> _expect22 = <String>["\'[\'"];
  
  static final List<String> _expect23 = <String>["POSITIVE_NUMBER"];
  
  static final List<String> _expect24 = <String>["\'enum\'"];
  
  static final List<String> _expect25 = <String>["\'typedef\'"];
  
  static final List<String> _expect26 = <String>["\'(\'", "Identifier"];
  
  static final List<String> _expect27 = <String>["\'=\'"];
  
  static final List<String> _expect28 = <String>["\'char\'"];
  
  static final List<String> _expect29 = <String>["\'}\'"];
  
  static final List<String> _expect3 = <String>["\'_Bool\'", "\'char\'", "\'double\'", "\'enum\'", "\'float\'", "\'int\'", "\'long\'", "\'short\'", "\'struct\'", "\'union\'", "\'void\'", "Identifier", "SIGNEDNESS"];
  
  static final List<String> _expect30 = <String>["\']\'"];
  
  static final List<String> _expect31 = <String>["\')\'"];
  
  static final List<String> _expect32 = <String>["\'const\'"];
  
  static final List<String> _expect33 = <String>["\'double\'"];
  
  static final List<String> _expect34 = <String>["\'float\'"];
  
  static final List<String> _expect35 = <String>["\'int\'"];
  
  static final List<String> _expect36 = <String>["LEADING_SPACES"];
  
  static final List<String> _expect37 = <String>["\'long\'"];
  
  static final List<String> _expect38 = <String>["NUMBER"];
  
  static final List<String> _expect39 = <String>["-"];
  
  static final List<String> _expect4 = <String>["\'__attribute__\'"];
  
  static final List<String> _expect40 = <String>["\';\'"];
  
  static final List<String> _expect41 = <String>["\'short\'"];
  
  static final List<String> _expect42 = <String>["SIGNEDNESS"];
  
  static final List<String> _expect43 = <String>["STRING"];
  
  static final List<String> _expect44 = <String>["\'struct\'"];
  
  static final List<String> _expect45 = <String>["\'union\'"];
  
  static final List<String> _expect46 = <String>["\'...\'"];
  
  static final List<String> _expect47 = <String>["\'volatile\'"];
  
  static final List<String> _expect48 = <String>["ZERO_NUMBER"];
  
  static final List<String> _expect49 = <String>["//"];
  
  static final List<String> _expect5 = <String>["IDENT"];
  
  static final List<String> _expect50 = <String>["const"];
  
  static final List<String> _expect51 = <String>["..."];
  
  static final List<String> _expect52 = <String>["\\x"];
  
  static final List<String> _expect53 = <String>["long"];
  
  static final List<String> _expect54 = <String>["\\"];
  
  static final List<String> _expect55 = <String>["+"];
  
  static final List<String> _expect56 = <String>["_Bool", "_Complex", "_Imaginary", "auto", "break", "case", "char", "const", "continue", "default", "do", "double", "else", "enum", "extern", "float", "for", "goto", "if", "inline", "int", "long", "register", "restrict", "return", "short", "signed", "sizeof", "static", "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"];
  
  static final List<String> _expect57 = <String>["+", "-"];
  
  static final List<String> _expect58 = <String>["signed"];
  
  static final List<String> _expect59 = <String>["\\U", "\\u"];
  
  static final List<String> _expect6 = <String>["\',\'"];
  
  static final List<String> _expect60 = <String>["unsigned"];
  
  static final List<String> _expect61 = <String>["volatile"];
  
  static final List<String> _expect7 = <String>["NUMBER", "STRING"];
  
  static final List<String> _expect8 = <String>["\'const\'", "\'volatile\'"];
  
  static final List<String> _expect9 = <String>["Identifier"];
  
  static final List<bool> _lookahead = _unmap([0x7e000005, 0x7d0fffff, 0x3fffff, 0x7fffe080, 0x7fffd0ff, 0x7c07ffff, 0x7a1fffff, 0x607fffff, 0x50ffffff, 0x7fffffff, 0x7fffffff, 0x61fff, 0x0, 0x3ff28060, 0x60000, 0x60000000, 0x11fc12fe, 0x234000, 0x14740, 0x1e81208c, 0x80001]);
  
  // '\n', '\r'
  static final List<bool> _mapping0 = _unmap([0x9]);
  
  // '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', 'a', 'f'
  static final List<bool> _mapping1 = _unmap([0x7fffffff, 0x87ffff]);
  
  // 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  static final List<bool> _mapping2 = _unmap([0x43ffffff, 0x7fffffe]);
  
  // '\"', '\'', '?', '\\', 'a', 'b', 'f', 'n', 'r', 't', 'v'
  static final List<bool> _mapping3 = _unmap([0x20000021, 0x8000000, 0x544046]);
  
  // '\t', '\n', '\r', ' '
  static final List<bool> _mapping4 = _unmap([0x800013]);
  
  // '\n', '\r', '\"', '\\'
  static final List<bool> _mapping5 = _unmap([0x1000009, 0x0, 0x100000]);
  
  // '__attribute__'
  static final List<int> _strings0 = <int>[95, 95, 97, 116, 116, 114, 105, 98, 117, 116, 101, 95, 95];
  
  // '_Bool'
  static final List<int> _strings1 = <int>[95, 66, 111, 111, 108];
  
  // 'typedef'
  static final List<int> _strings10 = <int>[116, 121, 112, 101, 100, 101, 102];
  
  // 'union'
  static final List<int> _strings11 = <int>[117, 110, 105, 111, 110];
  
  // 'void'
  static final List<int> _strings12 = <int>[118, 111, 105, 100];
  
  // '//'
  static final List<int> _strings13 = <int>[47, 47];
  
  // 'const'
  static final List<int> _strings14 = <int>[99, 111, 110, 115, 116];
  
  // '...'
  static final List<int> _strings15 = <int>[46, 46, 46];
  
  // '\r\n'
  static final List<int> _strings16 = <int>[13, 10];
  
  // '\x'
  static final List<int> _strings17 = <int>[92, 120];
  
  // 'long'
  static final List<int> _strings18 = <int>[108, 111, 110, 103];
  
  // '_Complex'
  static final List<int> _strings19 = <int>[95, 67, 111, 109, 112, 108, 101, 120];
  
  // 'char'
  static final List<int> _strings2 = <int>[99, 104, 97, 114];
  
  // '_Imaginary'
  static final List<int> _strings20 = <int>[95, 73, 109, 97, 103, 105, 110, 97, 114, 121];
  
  // 'auto'
  static final List<int> _strings21 = <int>[97, 117, 116, 111];
  
  // 'break'
  static final List<int> _strings22 = <int>[98, 114, 101, 97, 107];
  
  // 'case'
  static final List<int> _strings23 = <int>[99, 97, 115, 101];
  
  // 'continue'
  static final List<int> _strings24 = <int>[99, 111, 110, 116, 105, 110, 117, 101];
  
  // 'default'
  static final List<int> _strings25 = <int>[100, 101, 102, 97, 117, 108, 116];
  
  // 'do'
  static final List<int> _strings26 = <int>[100, 111];
  
  // 'else'
  static final List<int> _strings27 = <int>[101, 108, 115, 101];
  
  // 'extern'
  static final List<int> _strings28 = <int>[101, 120, 116, 101, 114, 110];
  
  // 'for'
  static final List<int> _strings29 = <int>[102, 111, 114];
  
  // 'double'
  static final List<int> _strings3 = <int>[100, 111, 117, 98, 108, 101];
  
  // 'goto'
  static final List<int> _strings30 = <int>[103, 111, 116, 111];
  
  // 'if'
  static final List<int> _strings31 = <int>[105, 102];
  
  // 'inline'
  static final List<int> _strings32 = <int>[105, 110, 108, 105, 110, 101];
  
  // 'register'
  static final List<int> _strings33 = <int>[114, 101, 103, 105, 115, 116, 101, 114];
  
  // 'restrict'
  static final List<int> _strings34 = <int>[114, 101, 115, 116, 114, 105, 99, 116];
  
  // 'return'
  static final List<int> _strings35 = <int>[114, 101, 116, 117, 114, 110];
  
  // 'signed'
  static final List<int> _strings36 = <int>[115, 105, 103, 110, 101, 100];
  
  // 'sizeof'
  static final List<int> _strings37 = <int>[115, 105, 122, 101, 111, 102];
  
  // 'static'
  static final List<int> _strings38 = <int>[115, 116, 97, 116, 105, 99];
  
  // 'switch'
  static final List<int> _strings39 = <int>[115, 119, 105, 116, 99, 104];
  
  // 'enum'
  static final List<int> _strings4 = <int>[101, 110, 117, 109];
  
  // 'unsigned'
  static final List<int> _strings40 = <int>[117, 110, 115, 105, 103, 110, 101, 100];
  
  // 'volatile'
  static final List<int> _strings41 = <int>[118, 111, 108, 97, 116, 105, 108, 101];
  
  // 'while'
  static final List<int> _strings42 = <int>[119, 104, 105, 108, 101];
  
  // '\U'
  static final List<int> _strings43 = <int>[92, 85];
  
  // '\u'
  static final List<int> _strings44 = <int>[92, 117];
  
  // 'float'
  static final List<int> _strings5 = <int>[102, 108, 111, 97, 116];
  
  // 'int'
  static final List<int> _strings6 = <int>[105, 110, 116];
  
  // 'short'
  static final List<int> _strings7 = <int>[115, 104, 111, 114, 116];
  
  // 'L"'
  static final List<int> _strings8 = <int>[76, 34];
  
  // 'struct'
  static final List<int> _strings9 = <int>[115, 116, 114, 117, 99, 116];
  
  final List<String> _tokenAliases = ["\'=\'", "\'*\'", "\'__attribute__\'", "\'_Bool\'", "\'char\'", "\'}\'", "\']\'", "\')\'", "\':\'", "\',\'", "\'const\'", "\'double\'", "\'enum\'", "EOF", "\'float\'", "IDENT", "\'int\'", "Identifier", "LEADING_SPACES", "\'long\'", "NUMBER", "\'{\'", "\'[\'", "\'(\'", "POSITIVE_NUMBER", "\';\'", "\'short\'", "SIGNEDNESS", "STRING", "\'struct\'", "\'typedef\'", "\'union\'", "\'...\'", "\'void\'", "\'volatile\'", "ZERO_NUMBER"];
  
  final List<int> _tokenFlags = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
  
  final List<String> _tokenNames = ["ASSIGN", "ASTERISK", "ATTRIBUTE", "BOOL", "CHAR", "CLOSE_BRACE", "CLOSE_BRACKET", "CLOSE_PAREN", "COLON", "COMMA", "Const", "DOUBLE", "ENUM", "EOF", "FLOAT", "IDENT", "INT", "Identifier", "LEADING_SPACES", "LONG_TYPE", "NUMBER", "OPEN_BRACE", "OPEN_BRACKET", "OPEN_PAREN", "POSITIVE_NUMBER", "SEMICOLON", "SHORT", "SIGNEDNESS", "STRING", "STRUCT", "TYPEDEF", "UNION", "VA_LIST_PARAMETER", "VOID", "Volatile", "ZERO_NUMBER"];
  
  static final List<List<int>> _transitions0 = [[42, 42], [59, 59], [65, 90], [95, 95, 97, 122]];
  
  static final List<List<int>> _transitions1 = [[42, 42], [65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions10 = [[99, 99], [105, 105], [108, 108], [115, 115]];
  
  static final List<List<int>> _transitions11 = [[108, 108], [115, 115]];
  
  static final List<List<int>> _transitions12 = [[100, 100, 102, 102]];
  
  static final List<List<int>> _transitions13 = [[100, 100], [102, 102]];
  
  static final List<List<int>> _transitions14 = [[115, 115, 117, 117]];
  
  static final List<List<int>> _transitions15 = [[115, 115], [117, 117]];
  
  static final List<List<int>> _transitions16 = [[65, 90, 97, 98, 100, 104, 106, 107, 109, 114, 116, 116, 119, 122], [95, 95, 99, 99, 105, 105, 108, 108, 115, 115, 117, 118]];
  
  static final List<List<int>> _transitions17 = [[95, 95, 99, 99, 105, 105, 108, 108, 115, 115, 117, 118]];
  
  static final List<List<int>> _transitions18 = [[58, 58, 65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions19 = [[42, 42], [91, 91]];
  
  static final List<List<int>> _transitions2 = [[65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions20 = [[43, 43, 45, 45, 48, 57]];
  
  static final List<List<int>> _transitions21 = [[40, 40, 42, 42]];
  
  static final List<List<int>> _transitions22 = [[95, 95, 99, 99, 115, 115, 117, 118]];
  
  static final List<List<int>> _transitions23 = [[95, 95, 99, 99, 101, 101, 118, 118]];
  
  static final List<List<int>> _transitions24 = [[95, 95, 99, 99, 116, 116, 118, 118]];
  
  static final List<List<int>> _transitions25 = [[40, 40, 42, 42, 65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions26 = [[40, 40], [42, 42], [65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions27 = [[43, 43, 45, 45, 48, 48], [49, 57]];
  
  static final List<List<int>> _transitions28 = [[34, 34], [76, 76]];
  
  static final List<List<int>> _transitions29 = [[0, 9, 11, 12, 14, 1114111], [10, 10, 13, 13]];
  
  static final List<List<int>> _transitions3 = [[34, 34, 43, 43, 45, 45, 48, 57, 76, 76]];
  
  static final List<List<int>> _transitions30 = [[10, 10], [13, 13]];
  
  static final List<List<int>> _transitions31 = [[48, 97, 102, 102]];
  
  static final List<List<int>> _transitions32 = [[0, 47, 98, 101, 103, 1114111], [48, 97, 102, 102]];
  
  static final List<List<int>> _transitions33 = [[48, 57], [65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions34 = [[43, 43, 45, 45, 48, 48]];
  
  static final List<List<int>> _transitions35 = [[95, 95, 97, 103, 105, 105, 108, 108, 114, 119]];
  
  static final List<List<int>> _transitions36 = [[95, 95], [97, 97], [98, 98], [99, 99], [100, 100], [101, 101], [102, 102], [103, 103], [105, 105], [108, 108], [114, 114], [115, 115], [116, 116], [117, 117], [118, 118], [119, 119]];
  
  static final List<List<int>> _transitions37 = [[43, 43], [45, 45]];
  
  static final List<List<int>> _transitions38 = [[9, 10, 13, 13, 32, 32]];
  
  static final List<List<int>> _transitions39 = [[9, 10, 13, 13, 32, 32], [47, 47]];
  
  static final List<List<int>> _transitions4 = [[34, 34, 76, 76], [43, 43, 45, 45, 48, 57]];
  
  static final List<List<int>> _transitions5 = [[99, 99, 118, 118]];
  
  static final List<List<int>> _transitions6 = [[99, 99], [118, 118]];
  
  static final List<List<int>> _transitions7 = [[42, 42, 65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions8 = [[65, 90], [95, 95], [97, 122]];
  
  static final List<List<int>> _transitions9 = [[99, 99, 105, 105], [108, 108], [115, 115, 117, 117]];
  
  List<Map<int, List>> _cache;
  
  List<int> _cachePos;
  
  List<bool> _cacheable;
  
  int _ch;
  
  int _cursor;
  
  List<CParserError> _errors;
  
  List<String> _expected;
  
  int _failurePos;
  
  List<int> _input;
  
  int _inputLen;
  
  int _startPos;
  
  int _testing;
  
  int _token;
  
  int _tokenStart;
  
  bool success;
  
  final String text;
  
  CParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }    
    _input = _toCodePoints(text);
    _inputLen = _input.length;    
    reset(0);    
  }
  
  void _addToCache(dynamic result, int start, int id) {   
    var map = _cache[id];
    if (map == null) {
      map = <int, List>{};
      _cache[id] = map;
    }
    map[start] = [result, _cursor, success];      
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {    
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var alias = _tokenAliases[_token];
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos > _tokenStart && _failurePos == _inputLen && (flag & 1) != 0) {             
        var message = "Unterminated '$name'";
        _errors.add(new CParserError(CParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {             
        var message = "Malformed '$name'";
        _errors.add(new CParserError(CParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else {
        _expected.add(alias);
      }            
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }   
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    if (!_cacheable[id]) {  
      _cacheable[id] = true;  
      return null;
    }
    var map = _cache[id];
    if (map == null) {
      return null;
    }
    var data = map[_cursor];
    if (data == null) {
      return null;
    }
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }
    return data;  
  }
  
  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];    
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;          
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state; 
      }   
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;  
  }
  
  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }
  
  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }    
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }    
    return null;  
  }
  
  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;  
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];  
        } else {
          result = new String.fromCharCode(_ch);
        }     
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      }
      success = false;
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }        
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }  
      return result;
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {    
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];  
          } else {
            result = new String.fromCharCode(_ch);
          }          
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    success = false;  
    return null;  
  }
  
  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;  
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }  
    if (success) {
      _cursor += length;      
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return string;      
    }  
    return null; 
  }
  
  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }  
  }
  
  dynamic _parse_ASSIGN() {
    // LEXEME (TOKEN)
    // ASSIGN <- '=' SPACING
    var $$;
    _token = 0;  
    _tokenStart = _cursor;  
    // => '=' SPACING # Choice
    switch (_ch == 61 ? 0 : _ch == -1 ? 2 : 1) {
      // [=]
      case 0:
        // => '=' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '='
          $$ = '=';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '='
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '=' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '='
      _failure(_expect27);
    }
    // <= '=' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ASTERISK() {
    // LEXEME (TOKEN)
    // ASTERISK <- '*' SPACING
    var $$;
    _token = 1;  
    _tokenStart = _cursor;  
    // => '*' SPACING # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => '*' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '*'
          $$ = '*';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '*'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '*'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '*' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '*'
      _failure(_expect10);
    }
    // <= '*' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ATTRIBUTE() {
    // LEXEME (TOKEN)
    // ATTRIBUTE <- '__attribute__' SPACING
    var $$;
    _token = 2;  
    _tokenStart = _cursor;  
    // => '__attribute__' SPACING # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => '__attribute__' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '__attribute__'
          $$ = _matchString(_strings0, '__attribute__');
          // <= '__attribute__'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '__attribute__'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '__attribute__' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '__attribute__'
      _failure(_expect4);
    }
    // <= '__attribute__' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ArrayDimensions() {
    // SENTENCE (NONTERMINAL)
    // ArrayDimensions <- Dimension+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[35] >= pos) {
      $$ = _getFromCache(35);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[35] = pos;
    }  
    // => Dimension+ # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => Dimension+
        var testing0;
        for (var first = true, reps; ;) {  
          // => Dimension  
          $$ = _parse_Dimension();  
          // <= Dimension  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= Dimension+
        if (success) {    
          // Dimension+
          final $1 = $$;
          final $start = startPos0;
          $$ = new ArrayDimensions(dimensions: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect22);
    }
    // <= Dimension+ # Choice
    if (_cacheable[35]) {
      _addToCache($$, pos, 35);
    }    
    return $$;
  }
  
  dynamic _parse_ArraySize() {
    // SENTENCE (NONTERMINAL)
    // ArraySize <- !ZERO_NUMBER POSITIVE_NUMBER
    var $$;
    // => !ZERO_NUMBER POSITIVE_NUMBER # Choice
    switch (_getState(_transitions20)) {
      // [+] [-] [0-9]
      // EOF
      case 0:
      case 2:
        // => !ZERO_NUMBER POSITIVE_NUMBER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !ZERO_NUMBER
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => ZERO_NUMBER
          $$ = _parse_ZERO_NUMBER();
          // <= ZERO_NUMBER
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !ZERO_NUMBER
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => POSITIVE_NUMBER
          $$ = _parse_POSITIVE_NUMBER();
          // <= POSITIVE_NUMBER
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // !ZERO_NUMBER
            final $1 = seq[0];
            // POSITIVE_NUMBER
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !ZERO_NUMBER POSITIVE_NUMBER # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: POSITIVE_NUMBER
      _failure(_expect23);
    }
    // <= !ZERO_NUMBER POSITIVE_NUMBER # Choice
    return $$;
  }
  
  dynamic _parse_BOOL() {
    // LEXEME (TOKEN)
    // BOOL <- '_Bool' SPACING
    var $$;
    _token = 3;  
    _tokenStart = _cursor;  
    // => '_Bool' SPACING # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => '_Bool' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '_Bool'
          $$ = _matchString(_strings1, '_Bool');
          // <= '_Bool'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '_Bool'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '_Bool' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '_Bool'
      _failure(_expect17);
    }
    // <= '_Bool' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_BitFieldDeclaratorAbstract() {
    // SENTENCE (NONTERMINAL)
    // BitFieldDeclaratorAbstract <- Identifier? COLON POSITIVE_NUMBER Metadata?
    var $$;
    // => Identifier? COLON POSITIVE_NUMBER Metadata? # Choice
    switch (_getState(_transitions18)) {
      // [:] [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Identifier? COLON POSITIVE_NUMBER Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Identifier?
          var testing0 = _testing;
          _testing = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          success = true; 
          _testing = testing0;
          // <= Identifier?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => COLON
          $$ = _parse_COLON();
          // <= COLON
          if (!success) break;
          seq[1] = $$;
          // => POSITIVE_NUMBER
          $$ = _parse_POSITIVE_NUMBER();
          // <= POSITIVE_NUMBER
          if (!success) break;
          seq[2] = $$;
          // => Metadata?
          var testing1 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing1;
          // <= Metadata?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Identifier?
            final $1 = seq[0];
            // COLON
            final $2 = seq[1];
            // POSITIVE_NUMBER
            final $3 = seq[2];
            // Metadata?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Declarator(identifier: $1, metadata: $4, width: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Identifier? COLON POSITIVE_NUMBER Metadata? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ':'
      _failure(_expect20);
    }
    // <= Identifier? COLON POSITIVE_NUMBER Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_BitFieldDeclaratorNotAbstract() {
    // SENTENCE (NONTERMINAL)
    // BitFieldDeclaratorNotAbstract <- Identifier COLON POSITIVE_NUMBER Metadata?
    var $$;
    // => Identifier COLON POSITIVE_NUMBER Metadata? # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Identifier COLON POSITIVE_NUMBER Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => COLON
          $$ = _parse_COLON();
          // <= COLON
          if (!success) break;
          seq[1] = $$;
          // => POSITIVE_NUMBER
          $$ = _parse_POSITIVE_NUMBER();
          // <= POSITIVE_NUMBER
          if (!success) break;
          seq[2] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Identifier
            final $1 = seq[0];
            // COLON
            final $2 = seq[1];
            // POSITIVE_NUMBER
            final $3 = seq[2];
            // Metadata?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Declarator(identifier: $1, metadata: $4, width: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Identifier COLON POSITIVE_NUMBER Metadata? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= Identifier COLON POSITIVE_NUMBER Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_BitFieldParameterDeclaration() {
    // SENTENCE (NONTERMINAL)
    // BitFieldParameterDeclaration <- Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorNotAbstract / Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorAbstract
    var $$;
    // => Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorNotAbstract / Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorAbstract # Choice
    switch (_getState(_transitions17)) {
      // [_] [c] [i] [l] [s] [u-v]
      case 0:
        while (true) {
          // => Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorNotAbstract # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => IntegerType
            $$ = _parse_IntegerType();
            // <= IntegerType
            if (!success) break;
            seq[2] = $$;
            // => BitFieldDeclaratorNotAbstract
            $$ = _parse_BitFieldDeclaratorNotAbstract();
            // <= BitFieldDeclaratorNotAbstract
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // IntegerType
              final $3 = seq[2];
              // BitFieldDeclaratorNotAbstract
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorNotAbstract # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorAbstract # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => IntegerType
            $$ = _parse_IntegerType();
            // <= IntegerType
            if (!success) break;
            seq[2] = $$;
            // => BitFieldDeclaratorAbstract
            $$ = _parse_BitFieldDeclaratorAbstract();
            // <= BitFieldDeclaratorAbstract
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // IntegerType
              final $3 = seq[2];
              // BitFieldDeclaratorAbstract
              final $4 = seq[3];
              final $start = startPos1;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorAbstract # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'short', 'long', 'char', 'int', SIGNEDNESS
      _failure(_expect12);
    }
    // <= Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorNotAbstract / Metadata? TypeQualifiers? IntegerType BitFieldDeclaratorAbstract # Choice
    return $$;
  }
  
  dynamic _parse_BoolType() {
    // SENTENCE (NONTERMINAL)
    // BoolType <- BOOL Metadata? TypeQualifiers?
    var $$;
    // => BOOL Metadata? TypeQualifiers? # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => BOOL Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => BOOL
          $$ = _parse_BOOL();
          // <= BOOL
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // BOOL
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new BuiltinTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3, typeKind: TypeSpecificationKind.BOOL);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= BOOL Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '_Bool'
      _failure(_expect17);
    }
    // <= BOOL Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_CHAR() {
    // LEXEME (TOKEN)
    // CHAR <- 'char' !IDENT_PART SPACING
    var $$;
    _token = 4;  
    _tokenStart = _cursor;  
    // => 'char' !IDENT_PART SPACING # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        // => 'char' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'char'
          $$ = _matchString(_strings2, 'char');
          // <= 'char'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'char'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'char' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'char'
      _failure(_expect28);
    }
    // <= 'char' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_CLOSE_BRACE() {
    // LEXEME (TOKEN)
    // CLOSE_BRACE <- '}' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[61] >= pos) {
      $$ = _getFromCache(61);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[61] = pos;
    }  
    _token = 5;    
    _tokenStart = _cursor;    
    // => '}' SPACING # Choice
    switch (_ch == 125 ? 0 : _ch == -1 ? 2 : 1) {
      // [}]
      case 0:
        // => '}' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '}'
          $$ = '}';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '}'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '}'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '}' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '}'
      _failure(_expect29);
    }
    // <= '}' SPACING # Choice
    if (_cacheable[61]) {
      _addToCache($$, pos, 61);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_CLOSE_BRACKET() {
    // LEXEME (TOKEN)
    // CLOSE_BRACKET <- ']' SPACING
    var $$;
    _token = 6;  
    _tokenStart = _cursor;  
    // => ']' SPACING # Choice
    switch (_ch == 93 ? 0 : _ch == -1 ? 2 : 1) {
      // []]
      case 0:
        // => ']' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ']'
          $$ = ']';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ']'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ']'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ']' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ']'
      _failure(_expect30);
    }
    // <= ']' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_CLOSE_PAREN() {
    // LEXEME (TOKEN)
    // CLOSE_PAREN <- ')' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[63] >= pos) {
      $$ = _getFromCache(63);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[63] = pos;
    }  
    _token = 7;    
    _tokenStart = _cursor;    
    // => ')' SPACING # Choice
    switch (_ch == 41 ? 0 : _ch == -1 ? 2 : 1) {
      // [)]
      case 0:
        // => ')' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ')'
          $$ = ')';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ')'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ')'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ')' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ')'
      _failure(_expect31);
    }
    // <= ')' SPACING # Choice
    if (_cacheable[63]) {
      _addToCache($$, pos, 63);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_COLON() {
    // LEXEME (TOKEN)
    // COLON <- ':' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[64] >= pos) {
      $$ = _getFromCache(64);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[64] = pos;
    }  
    _token = 8;    
    _tokenStart = _cursor;    
    // => ':' SPACING # Choice
    switch (_ch == 58 ? 0 : _ch == -1 ? 2 : 1) {
      // [:]
      case 0:
        // => ':' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ':'
          $$ = ':';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ':'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ':'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ':' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ':'
      _failure(_expect20);
    }
    // <= ':' SPACING # Choice
    if (_cacheable[64]) {
      _addToCache($$, pos, 64);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_COMMA() {
    // LEXEME (TOKEN)
    // COMMA <- ',' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[65] >= pos) {
      $$ = _getFromCache(65);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[65] = pos;
    }  
    _token = 9;    
    _tokenStart = _cursor;    
    // => ',' SPACING # Choice
    switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
      // [,]
      case 0:
        // => ',' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ','
          $$ = ',';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ','
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ','
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ',' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ','
      _failure(_expect6);
    }
    // <= ',' SPACING # Choice
    if (_cacheable[65]) {
      _addToCache($$, pos, 65);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_COMMENT() {
    // MORHEME
    // COMMENT <- '//' (!EOL .)* (EOL / !.)
    var $$;
    // => '//' (!EOL .)* (EOL / !.) # Choice
    switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
      // [/]
      case 0:
        // => '//' (!EOL .)* (EOL / !.) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '//'
          $$ = _matchString(_strings13, '//');
          // <= '//'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (!EOL .)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (!EOL .) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              // EOF
              case 0:
              case 2:
                // => !EOL . # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => !EOL
                  var ch2 = _ch, pos2 = _cursor, testing1 = _testing; 
                  _testing = _inputLen + 1;
                  // => EOL
                  $$ = _parse_EOL();
                  // <= EOL
                  _ch = ch2;
                  _cursor = pos2; 
                  _testing = testing1;
                  $$ = null;
                  success = !success;
                  // <= !EOL
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => .
                  $$ = _matchAny();
                  // <= .
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= !EOL . # Sequence
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(const [null]);
            }
            // <= (!EOL .) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (!EOL .)*
          if (!success) break;
          seq[1] = $$;
          // => (EOL / !.) # Choice
          switch (_getState(_transitions29)) {
            // [\u0000-\t] [\u000b-\u000c] [\u000e-\u0010ffff]
            // EOF
            case 0:
            case 3:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => !.
              var ch3 = _ch, pos3 = _cursor, testing2 = _testing; 
              _testing = _inputLen + 1;
              // => .
              $$ = _matchAny();
              // <= .
              _ch = ch3;
              _cursor = pos3; 
              _testing = testing2;
              $$ = null;
              success = !success;
              // <= !.
              _startPos = startPos2;
              break;
            // [\n] [\r]
            case 1:
              while (true) {
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => EOL
                $$ = _parse_EOL();
                // <= EOL
                _startPos = startPos3;
                if (success) break;
                var startPos4 = _startPos;
                _startPos = _cursor;
                // => !.
                var ch4 = _ch, pos4 = _cursor, testing3 = _testing; 
                _testing = _inputLen + 1;
                // => .
                $$ = _matchAny();
                // <= .
                _ch = ch4;
                _cursor = pos4; 
                _testing = testing3;
                $$ = null;
                success = !success;
                // <= !.
                _startPos = startPos4;
                break;
              }
              break;
            // No matches
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (EOL / !.) # Choice
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '//' (!EOL .)* (EOL / !.) # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: //
      _failure(_expect49);
    }
    // <= '//' (!EOL .)* (EOL / !.) # Choice
    return $$;
  }
  
  dynamic _parse_CONST() {
    // MORHEME
    // CONST <- 'const' SPACING
    var $$;
    // => 'const' SPACING # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        // => 'const' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'const'
          $$ = _matchString(_strings14, 'const');
          // <= 'const'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'const'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'const' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: const
      _failure(_expect50);
    }
    // <= 'const' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_Const() {
    // LEXEME (TOKEN)
    // Const <- CONST
    var $$;
    _token = 10;  
    _tokenStart = _cursor;  
    // => CONST # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => CONST
        $$ = _parse_CONST();
        // <= CONST
        if (success) {    
          // CONST
          final $1 = $$;
          final $start = startPos0;
          $$ = new Identifier(name: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'const'
      _failure(_expect32);
    }
    // <= CONST # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_DOUBLE() {
    // LEXEME (TOKEN)
    // DOUBLE <- 'double' !IDENT_PART SPACING
    var $$;
    _token = 11;  
    _tokenStart = _cursor;  
    // => 'double' !IDENT_PART SPACING # Choice
    switch (_ch == 100 ? 0 : _ch == -1 ? 2 : 1) {
      // [d]
      case 0:
        // => 'double' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'double'
          $$ = _matchString(_strings3, 'double');
          // <= 'double'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'double'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'double' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'double'
      _failure(_expect33);
    }
    // <= 'double' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_Declaration() {
    // SENTENCE (NONTERMINAL)
    // Declaration <- FunctionDeclaration SEMICOLON+ / StructureDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / SEMICOLON+
    var $$;
    // => FunctionDeclaration SEMICOLON+ / StructureDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / SEMICOLON+ # Choice
    switch (_getState(_transitions0)) {
      // [*]
      case 0:
        // => FunctionDeclaration SEMICOLON+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FunctionDeclaration
          $$ = _parse_FunctionDeclaration();
          // <= FunctionDeclaration
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SEMICOLON+
          var testing0;
          for (var first = true, reps; ;) {  
            // => SEMICOLON  
            $$ = _parse_SEMICOLON();  
            // <= SEMICOLON  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= SEMICOLON+
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // FunctionDeclaration
            final $1 = seq[0];
            // SEMICOLON+
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionDeclaration SEMICOLON+ # Sequence
        break;
      // [;]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => SEMICOLON+
        var testing1;
        for (var first = true, reps; ;) {  
          // => SEMICOLON  
          $$ = _parse_SEMICOLON();  
          // <= SEMICOLON  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing1 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing1;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= SEMICOLON+
        if (success) {    
          // SEMICOLON+
          final $1 = $$;
          final $start = startPos1;
          $$ = new EmptyDeclaration();
        }
        _startPos = startPos1;
        break;
      // [A-Z]
      // EOF
      case 2:
      case 5:
        while (true) {
          // => FunctionDeclaration SEMICOLON+ # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FunctionDeclaration
            $$ = _parse_FunctionDeclaration();
            // <= FunctionDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing2;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing2 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing2;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // FunctionDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos2;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos2;
          // <= FunctionDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => VariableDeclaration SEMICOLON+ # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => VariableDeclaration
            $$ = _parse_VariableDeclaration();
            // <= VariableDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing3;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing3 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing3;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // VariableDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos3;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos3;
          // <= VariableDeclaration SEMICOLON+ # Sequence
          break;
        }
        break;
      // [_] [a-z]
      case 3:
        while (true) {
          // => FunctionDeclaration SEMICOLON+ # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FunctionDeclaration
            $$ = _parse_FunctionDeclaration();
            // <= FunctionDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing4;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing4 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing4;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // FunctionDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos4;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos4;
          // <= FunctionDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => StructureDeclaration SEMICOLON+ # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => StructureDeclaration
            $$ = _parse_StructureDeclaration();
            // <= StructureDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing5;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing5 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing5;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // StructureDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos5;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos5;
          // <= StructureDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => EnumDeclaration SEMICOLON+ # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => EnumDeclaration
            $$ = _parse_EnumDeclaration();
            // <= EnumDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing6;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing6 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing6;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // EnumDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos6;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos6;
          // <= EnumDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => TypedefDeclaration SEMICOLON+ # Sequence
          var ch6 = _ch, pos6 = _cursor, startPos7 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => TypedefDeclaration
            $$ = _parse_TypedefDeclaration();
            // <= TypedefDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing7;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing7 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing7;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // TypedefDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos7;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos7;
          // <= TypedefDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => VariableDeclaration SEMICOLON+ # Sequence
          var ch7 = _ch, pos7 = _cursor, startPos8 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => VariableDeclaration
            $$ = _parse_VariableDeclaration();
            // <= VariableDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing8;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing8 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing8;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // VariableDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos8;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch7;
            _cursor = pos7;
          }
          _startPos = startPos8;
          // <= VariableDeclaration SEMICOLON+ # Sequence
          break;
        }
        break;
      // No matches
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum', 'typedef', ';'
      _failure(_expect2);
    }
    // <= FunctionDeclaration SEMICOLON+ / StructureDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / SEMICOLON+ # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationList() {
    // SENTENCE (NONTERMINAL)
    // DeclarationList <- Declaration*
    var $$;
    // => Declaration* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => Declaration*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => Declaration
          $$ = _parse_Declaration();
          // <= Declaration
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= Declaration*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
      // EOF
      case 2:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => Declaration*
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => Declaration
            $$ = _parse_Declaration();
            // <= Declaration
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          // <= Declaration*
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => Declaration*
          var testing2 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => Declaration
            $$ = _parse_Declaration();
            // <= Declaration
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing2;
              $$ = reps;
              break; 
            }
          }
          // <= Declaration*
          _startPos = startPos2;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= Declaration* # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationModifier() {
    // SENTENCE (NONTERMINAL)
    // DeclarationModifier <- IDENT OPEN_PAREN DeclarationModifierArgumentList? CLOSE_PAREN / IDENT
    var $$;          
    var pos = _cursor;             
    if(_cachePos[7] >= pos) {
      $$ = _getFromCache(7);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[7] = pos;
    }  
    // => IDENT OPEN_PAREN DeclarationModifierArgumentList? CLOSE_PAREN / IDENT # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      case 0:
        while (true) {
          // => IDENT OPEN_PAREN DeclarationModifierArgumentList? CLOSE_PAREN # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => IDENT
            $$ = _parse_IDENT();
            // <= IDENT
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => OPEN_PAREN
            $$ = _parse_OPEN_PAREN();
            // <= OPEN_PAREN
            if (!success) break;
            seq[1] = $$;
            // => DeclarationModifierArgumentList?
            var testing0 = _testing;
            _testing = _cursor;
            // => DeclarationModifierArgumentList
            $$ = _parse_DeclarationModifierArgumentList();
            // <= DeclarationModifierArgumentList
            success = true; 
            _testing = testing0;
            // <= DeclarationModifierArgumentList?
            if (!success) break;
            seq[2] = $$;
            // => CLOSE_PAREN
            $$ = _parse_CLOSE_PAREN();
            // <= CLOSE_PAREN
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // IDENT
              final $1 = seq[0];
              // OPEN_PAREN
              final $2 = seq[1];
              // DeclarationModifierArgumentList?
              final $3 = seq[2];
              // CLOSE_PAREN
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new DeclarationModifier($1, $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= IDENT OPEN_PAREN DeclarationModifierArgumentList? CLOSE_PAREN # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => IDENT
          $$ = _parse_IDENT();
          // <= IDENT
          if (success) {    
            // IDENT
            final $1 = $$;
            final $start = startPos1;
            $$ = new DeclarationModifier($1);
          }
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT
      _failure(_expect5);
    }
    // <= IDENT OPEN_PAREN DeclarationModifierArgumentList? CLOSE_PAREN / IDENT # Choice
    if (_cacheable[7]) {
      _addToCache($$, pos, 7);
    }    
    return $$;
  }
  
  dynamic _parse_DeclarationModifierArgument() {
    // SENTENCE (NONTERMINAL)
    // DeclarationModifierArgument <- STRING / NUMBER
    var $$;          
    var pos = _cursor;             
    if(_cachePos[9] >= pos) {
      $$ = _getFromCache(9);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[9] = pos;
    }  
    // => STRING / NUMBER # Choice
    switch (_getState(_transitions4)) {
      // [\"] [L]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => STRING
        $$ = _parse_STRING();
        // <= STRING
        _startPos = startPos0;
        break;
      // [+] [-] [0-9]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => NUMBER
        $$ = _parse_NUMBER();
        // <= NUMBER
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: STRING, NUMBER
      _failure(_expect7);
    }
    // <= STRING / NUMBER # Choice
    if (_cacheable[9]) {
      _addToCache($$, pos, 9);
    }    
    return $$;
  }
  
  dynamic _parse_DeclarationModifierArgumentList() {
    // SENTENCE (NONTERMINAL)
    // DeclarationModifierArgumentList <- DeclarationModifierArgument (COMMA DeclarationModifierArgument)*
    var $$;
    // => DeclarationModifierArgument (COMMA DeclarationModifierArgument)* # Choice
    switch (_getState(_transitions3)) {
      // [\"] [+] [-] [0-9] [L]
      case 0:
        // => DeclarationModifierArgument (COMMA DeclarationModifierArgument)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => DeclarationModifierArgument
          $$ = _parse_DeclarationModifierArgument();
          // <= DeclarationModifierArgument
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA DeclarationModifierArgument)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA DeclarationModifierArgument) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA DeclarationModifierArgument # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => DeclarationModifierArgument
                  $$ = _parse_DeclarationModifierArgument();
                  // <= DeclarationModifierArgument
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA DeclarationModifierArgument # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect6);
            }
            // <= (COMMA DeclarationModifierArgument) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA DeclarationModifierArgument)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // DeclarationModifierArgument
            final $1 = seq[0];
            // (COMMA DeclarationModifierArgument)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= DeclarationModifierArgument (COMMA DeclarationModifierArgument)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: STRING, NUMBER
      _failure(_expect7);
    }
    // <= DeclarationModifierArgument (COMMA DeclarationModifierArgument)* # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationModifierList() {
    // SENTENCE (NONTERMINAL)
    // DeclarationModifierList <- DeclarationModifier (COMMA DeclarationModifier)*
    var $$;
    // => DeclarationModifier (COMMA DeclarationModifier)* # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      case 0:
        // => DeclarationModifier (COMMA DeclarationModifier)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => DeclarationModifier
          $$ = _parse_DeclarationModifier();
          // <= DeclarationModifier
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA DeclarationModifier)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA DeclarationModifier) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA DeclarationModifier # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => DeclarationModifier
                  $$ = _parse_DeclarationModifier();
                  // <= DeclarationModifier
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA DeclarationModifier # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect6);
            }
            // <= (COMMA DeclarationModifier) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA DeclarationModifier)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // DeclarationModifier
            final $1 = seq[0];
            // (COMMA DeclarationModifier)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new DeclarationModifiers(_list($1, $2));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= DeclarationModifier (COMMA DeclarationModifier)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT
      _failure(_expect5);
    }
    // <= DeclarationModifier (COMMA DeclarationModifier)* # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationSpecifier() {
    // SENTENCE (NONTERMINAL)
    // DeclarationSpecifier <- ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN
    var $$;
    // => ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ATTRIBUTE
          $$ = _parse_ATTRIBUTE();
          // <= ATTRIBUTE
          if (!success) break;
          var seq = new List(6)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[2] = $$;
          // => DeclarationModifierList?
          var testing0 = _testing;
          _testing = _cursor;
          // => DeclarationModifierList
          $$ = _parse_DeclarationModifierList();
          // <= DeclarationModifierList
          success = true; 
          _testing = testing0;
          // <= DeclarationModifierList?
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[4] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[5] = $$;
          $$ = seq;
          if (success) {    
            // ATTRIBUTE
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // OPEN_PAREN
            final $3 = seq[2];
            // DeclarationModifierList?
            final $4 = seq[3];
            // CLOSE_PAREN
            final $5 = seq[4];
            // CLOSE_PAREN
            final $6 = seq[5];
            final $start = startPos0;
            $$ = new DeclarationSpecifier($4);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '__attribute__'
      _failure(_expect4);
    }
    // <= ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN # Choice
    return $$;
  }
  
  dynamic _parse_DeclaratorAbstract() {
    // SENTENCE (NONTERMINAL)
    // DeclaratorAbstract <- PointerSpecifiers ArrayDimensions Metadata? / PointerSpecifiers? ArrayDimensions Metadata? / PointerSpecifiers ArrayDimensions? Metadata?
    var $$;
    // => PointerSpecifiers ArrayDimensions Metadata? / PointerSpecifiers? ArrayDimensions Metadata? / PointerSpecifiers ArrayDimensions? Metadata? # Choice
    switch (_getState(_transitions19)) {
      // [*]
      case 0:
        while (true) {
          // => PointerSpecifiers ArrayDimensions Metadata? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => PointerSpecifiers
            $$ = _parse_PointerSpecifiers();
            // <= PointerSpecifiers
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ArrayDimensions
            $$ = _parse_ArrayDimensions();
            // <= ArrayDimensions
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // PointerSpecifiers
              final $1 = seq[0];
              // ArrayDimensions
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              final $start = startPos0;
              $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= PointerSpecifiers ArrayDimensions Metadata? # Sequence
          if (success) break;
          // => PointerSpecifiers? ArrayDimensions Metadata? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => PointerSpecifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => PointerSpecifiers
            $$ = _parse_PointerSpecifiers();
            // <= PointerSpecifiers
            success = true; 
            _testing = testing1;
            // <= PointerSpecifiers?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ArrayDimensions
            $$ = _parse_ArrayDimensions();
            // <= ArrayDimensions
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // PointerSpecifiers?
              final $1 = seq[0];
              // ArrayDimensions
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= PointerSpecifiers? ArrayDimensions Metadata? # Sequence
          if (success) break;
          // => PointerSpecifiers ArrayDimensions? Metadata? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => PointerSpecifiers
            $$ = _parse_PointerSpecifiers();
            // <= PointerSpecifiers
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ArrayDimensions?
            var testing3 = _testing;
            _testing = _cursor;
            // => ArrayDimensions
            $$ = _parse_ArrayDimensions();
            // <= ArrayDimensions
            success = true; 
            _testing = testing3;
            // <= ArrayDimensions?
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing4 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing4;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // PointerSpecifiers
              final $1 = seq[0];
              // ArrayDimensions?
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              final $start = startPos2;
              $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= PointerSpecifiers ArrayDimensions? Metadata? # Sequence
          break;
        }
        break;
      // [[]
      case 1:
        // => PointerSpecifiers? ArrayDimensions Metadata? # Sequence
        var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing5 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing5;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => ArrayDimensions
          $$ = _parse_ArrayDimensions();
          // <= ArrayDimensions
          if (!success) break;
          seq[1] = $$;
          // => Metadata?
          var testing6 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing6;
          // <= Metadata?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // ArrayDimensions
            final $2 = seq[1];
            // Metadata?
            final $3 = seq[2];
            final $start = startPos3;
            $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch3;
          _cursor = pos3;
        }
        _startPos = startPos3;
        // <= PointerSpecifiers? ArrayDimensions Metadata? # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '*', '['
      _failure(_expect21);
    }
    // <= PointerSpecifiers ArrayDimensions Metadata? / PointerSpecifiers? ArrayDimensions Metadata? / PointerSpecifiers ArrayDimensions? Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_DeclaratorNotAbstract() {
    // SENTENCE (NONTERMINAL)
    // DeclaratorNotAbstract <- PointerSpecifiers? Identifier ArrayDimensions? Metadata?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[45] >= pos) {
      $$ = _getFromCache(45);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[45] = pos;
    }  
    // => PointerSpecifiers? Identifier ArrayDimensions? Metadata? # Choice
    switch (_getState(_transitions7)) {
      // [*] [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => PointerSpecifiers? Identifier ArrayDimensions? Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing0;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[1] = $$;
          // => ArrayDimensions?
          var testing1 = _testing;
          _testing = _cursor;
          // => ArrayDimensions
          $$ = _parse_ArrayDimensions();
          // <= ArrayDimensions
          success = true; 
          _testing = testing1;
          // <= ArrayDimensions?
          if (!success) break;
          seq[2] = $$;
          // => Metadata?
          var testing2 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing2;
          // <= Metadata?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // Identifier
            final $2 = seq[1];
            // ArrayDimensions?
            final $3 = seq[2];
            // Metadata?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Declarator(dimensions: $3, identifier: $2, metadata: $4, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerSpecifiers? Identifier ArrayDimensions? Metadata? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= PointerSpecifiers? Identifier ArrayDimensions? Metadata? # Choice
    if (_cacheable[45]) {
      _addToCache($$, pos, 45);
    }    
    return $$;
  }
  
  dynamic _parse_DefinedType() {
    // SENTENCE (NONTERMINAL)
    // DefinedType <- Identifier Metadata? TypeQualifiers?
    var $$;
    // => Identifier Metadata? TypeQualifiers? # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Identifier Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Identifier
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new DefinedTypeSpecification(identifier: $1, metadata: $2, qualifiers: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Identifier Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= Identifier Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_Dimension() {
    // SENTENCE (NONTERMINAL)
    // Dimension <- OPEN_BRACKET ArraySize? CLOSE_BRACKET
    var $$;
    // => OPEN_BRACKET ArraySize? CLOSE_BRACKET # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => OPEN_BRACKET ArraySize? CLOSE_BRACKET # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => OPEN_BRACKET
          $$ = _parse_OPEN_BRACKET();
          // <= OPEN_BRACKET
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => ArraySize?
          var testing0 = _testing;
          _testing = _cursor;
          // => ArraySize
          $$ = _parse_ArraySize();
          // <= ArraySize
          success = true; 
          _testing = testing0;
          // <= ArraySize?
          if (!success) break;
          seq[1] = $$;
          // => CLOSE_BRACKET
          $$ = _parse_CLOSE_BRACKET();
          // <= CLOSE_BRACKET
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // OPEN_BRACKET
            final $1 = seq[0];
            // ArraySize?
            final $2 = seq[1];
            // CLOSE_BRACKET
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= OPEN_BRACKET ArraySize? CLOSE_BRACKET # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect22);
    }
    // <= OPEN_BRACKET ArraySize? CLOSE_BRACKET # Choice
    return $$;
  }
  
  dynamic _parse_ELLIPSIS() {
    // MORHEME
    // ELLIPSIS <- '...' SPACING
    var $$;
    // => '...' SPACING # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        // => '...' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '...'
          $$ = _matchString(_strings15, '...');
          // <= '...'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '...'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '...' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ...
      _failure(_expect51);
    }
    // <= '...' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_ENUM() {
    // LEXEME (TOKEN)
    // ENUM <- 'enum' !IDENT_PART SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[68] >= pos) {
      $$ = _getFromCache(68);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[68] = pos;
    }  
    _token = 12;    
    _tokenStart = _cursor;    
    // => 'enum' !IDENT_PART SPACING # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => 'enum' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'enum'
          $$ = _matchString(_strings4, 'enum');
          // <= 'enum'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'enum'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'enum' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect24);
    }
    // <= 'enum' !IDENT_PART SPACING # Choice
    if (_cacheable[68]) {
      _addToCache($$, pos, 68);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_EOF() {
    // LEXEME (TOKEN)
    // EOF <- !.
    var $$;
    _token = 13;  
    _tokenStart = _cursor;  
    // => !. # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => !.
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
        _testing = _inputLen + 1;
        // => .
        $$ = _matchAny();
        // <= .
        _ch = ch0;
        _cursor = pos0; 
        _testing = testing0;
        $$ = null;
        success = !success;
        // <= !.
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= !. # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_EOL() {
    // MORHEME
    // EOL <- '\r\n' / [\n\r]
    var $$;
    // => '\r\n' / [\n\r] # Choice
    switch (_getState(_transitions30)) {
      // [\n]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\n\r]
        $$ = _matchMapping(10, 13, _mapping0);
        // <= [\n\r]
        _startPos = startPos0;
        break;
      // [\r]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => '\r\n'
          $$ = _matchString(_strings16, '\r\n');
          // <= '\r\n'
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => [\n\r]
          $$ = _matchMapping(10, 13, _mapping0);
          // <= [\n\r]
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= '\r\n' / [\n\r] # Choice
    return $$;
  }
  
  dynamic _parse_ESCAPE_SEQUENCE() {
    // MORHEME
    // ESCAPE_SEQUENCE <- SIMPLE_ESCAPE_SEQUENCE / OCTAL_ESCAPE_SEQUENCE / HEXADECIMAL_ESCAPE_SEQUENCE / UNIVERSAL_CHARCTER_NAME
    var $$;
    // => SIMPLE_ESCAPE_SEQUENCE / OCTAL_ESCAPE_SEQUENCE / HEXADECIMAL_ESCAPE_SEQUENCE / UNIVERSAL_CHARCTER_NAME # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => SIMPLE_ESCAPE_SEQUENCE
          $$ = _parse_SIMPLE_ESCAPE_SEQUENCE();
          // <= SIMPLE_ESCAPE_SEQUENCE
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => OCTAL_ESCAPE_SEQUENCE
          $$ = _parse_OCTAL_ESCAPE_SEQUENCE();
          // <= OCTAL_ESCAPE_SEQUENCE
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => HEXADECIMAL_ESCAPE_SEQUENCE
          $$ = _parse_HEXADECIMAL_ESCAPE_SEQUENCE();
          // <= HEXADECIMAL_ESCAPE_SEQUENCE
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => UNIVERSAL_CHARCTER_NAME
          $$ = _parse_UNIVERSAL_CHARCTER_NAME();
          // <= UNIVERSAL_CHARCTER_NAME
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= SIMPLE_ESCAPE_SEQUENCE / OCTAL_ESCAPE_SEQUENCE / HEXADECIMAL_ESCAPE_SEQUENCE / UNIVERSAL_CHARCTER_NAME # Choice
    return $$;
  }
  
  dynamic _parse_EnumDeclaration() {
    // SENTENCE (NONTERMINAL)
    // EnumDeclaration <- Metadata? TypeQualifiers? EnumType
    var $$;
    // => Metadata? TypeQualifiers? EnumType # Choice
    switch (_getState(_transitions23)) {
      // [_] [c] [e] [v]
      case 0:
        // => Metadata? TypeQualifiers? EnumType # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => EnumType
          $$ = _parse_EnumType();
          // <= EnumType
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // EnumType
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new EnumDeclaration(metadata: $1, qualifiers: $2, type: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? EnumType # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect24);
    }
    // <= Metadata? TypeQualifiers? EnumType # Choice
    return $$;
  }
  
  dynamic _parse_EnumType() {
    // SENTENCE (NONTERMINAL)
    // EnumType <- EnumTypeSpecifier OPEN_BRACE EnumeratorList CLOSE_BRACE Metadata? TypeQualifiers? / EnumTypeSpecifierWithTag Metadata? TypeQualifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[39] >= pos) {
      $$ = _getFromCache(39);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[39] = pos;
    }  
    // => EnumTypeSpecifier OPEN_BRACE EnumeratorList CLOSE_BRACE Metadata? TypeQualifiers? / EnumTypeSpecifierWithTag Metadata? TypeQualifiers? # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        while (true) {
          // => EnumTypeSpecifier OPEN_BRACE EnumeratorList CLOSE_BRACE Metadata? TypeQualifiers? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => EnumTypeSpecifier
            $$ = _parse_EnumTypeSpecifier();
            // <= EnumTypeSpecifier
            if (!success) break;
            var seq = new List(6)..[0] = $$;
            // => OPEN_BRACE
            $$ = _parse_OPEN_BRACE();
            // <= OPEN_BRACE
            if (!success) break;
            seq[1] = $$;
            // => EnumeratorList
            $$ = _parse_EnumeratorList();
            // <= EnumeratorList
            if (!success) break;
            seq[2] = $$;
            // => CLOSE_BRACE
            $$ = _parse_CLOSE_BRACE();
            // <= CLOSE_BRACE
            if (!success) break;
            seq[3] = $$;
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            seq[4] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[5] = $$;
            $$ = seq;
            if (success) {    
              // EnumTypeSpecifier
              final $1 = seq[0];
              // OPEN_BRACE
              final $2 = seq[1];
              // EnumeratorList
              final $3 = seq[2];
              // CLOSE_BRACE
              final $4 = seq[3];
              // Metadata?
              final $5 = seq[4];
              // TypeQualifiers?
              final $6 = seq[5];
              final $start = startPos0;
              $$ = new EnumTypeSpecification(metadata: $5, elaboratedType: $1, qualifiers: $6, enumerators: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= EnumTypeSpecifier OPEN_BRACE EnumeratorList CLOSE_BRACE Metadata? TypeQualifiers? # Sequence
          if (success) break;
          // => EnumTypeSpecifierWithTag Metadata? TypeQualifiers? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => EnumTypeSpecifierWithTag
            $$ = _parse_EnumTypeSpecifierWithTag();
            // <= EnumTypeSpecifierWithTag
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            seq[1] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // EnumTypeSpecifierWithTag
              final $1 = seq[0];
              // Metadata?
              final $2 = seq[1];
              // TypeQualifiers?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new EnumTypeSpecification(metadata: $2, elaboratedType: $1, qualifiers: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= EnumTypeSpecifierWithTag Metadata? TypeQualifiers? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect24);
    }
    // <= EnumTypeSpecifier OPEN_BRACE EnumeratorList CLOSE_BRACE Metadata? TypeQualifiers? / EnumTypeSpecifierWithTag Metadata? TypeQualifiers? # Choice
    if (_cacheable[39]) {
      _addToCache($$, pos, 39);
    }    
    return $$;
  }
  
  dynamic _parse_EnumTypeSpecifier() {
    // SENTENCE (NONTERMINAL)
    // EnumTypeSpecifier <- ENUM Metadata? Identifier?
    var $$;
    // => ENUM Metadata? Identifier? # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => ENUM Metadata? Identifier? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ENUM
          $$ = _parse_ENUM();
          // <= ENUM
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => Identifier?
          var testing1 = _testing;
          _testing = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          success = true; 
          _testing = testing1;
          // <= Identifier?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ENUM
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // Identifier?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ENUM Metadata? Identifier? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect24);
    }
    // <= ENUM Metadata? Identifier? # Choice
    return $$;
  }
  
  dynamic _parse_EnumTypeSpecifierWithTag() {
    // SENTENCE (NONTERMINAL)
    // EnumTypeSpecifierWithTag <- ENUM Metadata? Identifier
    var $$;
    // => ENUM Metadata? Identifier # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => ENUM Metadata? Identifier # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ENUM
          $$ = _parse_ENUM();
          // <= ENUM
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ENUM
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // Identifier
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ENUM Metadata? Identifier # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect24);
    }
    // <= ENUM Metadata? Identifier # Choice
    return $$;
  }
  
  dynamic _parse_Enumerator() {
    // SENTENCE (NONTERMINAL)
    // Enumerator <- Identifier ASSIGN NUMBER / Identifier
    var $$;          
    var pos = _cursor;             
    if(_cachePos[42] >= pos) {
      $$ = _getFromCache(42);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[42] = pos;
    }  
    // => Identifier ASSIGN NUMBER / Identifier # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => Identifier ASSIGN NUMBER # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Identifier
            $$ = _parse_Identifier();
            // <= Identifier
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ASSIGN
            $$ = _parse_ASSIGN();
            // <= ASSIGN
            if (!success) break;
            seq[1] = $$;
            // => NUMBER
            $$ = _parse_NUMBER();
            // <= NUMBER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // Identifier
              final $1 = seq[0];
              // ASSIGN
              final $2 = seq[1];
              // NUMBER
              final $3 = seq[2];
              final $start = startPos0;
              $$ = new Enumerator(identifier: $1, value: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Identifier ASSIGN NUMBER # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (success) {    
            // Identifier
            final $1 = $$;
            final $start = startPos1;
            $$ = new Enumerator(identifier: $1);
          }
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= Identifier ASSIGN NUMBER / Identifier # Choice
    if (_cacheable[42]) {
      _addToCache($$, pos, 42);
    }    
    return $$;
  }
  
  dynamic _parse_EnumeratorList() {
    // SENTENCE (NONTERMINAL)
    // EnumeratorList <- Enumerator (COMMA Enumerator)* COMMA?
    var $$;
    // => Enumerator (COMMA Enumerator)* COMMA? # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Enumerator (COMMA Enumerator)* COMMA? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Enumerator
          $$ = _parse_Enumerator();
          // <= Enumerator
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (COMMA Enumerator)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA Enumerator) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA Enumerator # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => Enumerator
                  $$ = _parse_Enumerator();
                  // <= Enumerator
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA Enumerator # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect6);
            }
            // <= (COMMA Enumerator) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA Enumerator)*
          if (!success) break;
          seq[1] = $$;
          // => COMMA?
          var testing1 = _testing;
          _testing = _cursor;
          // => COMMA
          $$ = _parse_COMMA();
          // <= COMMA
          success = true; 
          _testing = testing1;
          // <= COMMA?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Enumerator
            final $1 = seq[0];
            // (COMMA Enumerator)*
            final $2 = seq[1];
            // COMMA?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Enumerator (COMMA Enumerator)* COMMA? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= Enumerator (COMMA Enumerator)* COMMA? # Choice
    return $$;
  }
  
  dynamic _parse_FLOAT() {
    // LEXEME (TOKEN)
    // FLOAT <- 'float' !IDENT_PART SPACING
    var $$;
    _token = 14;  
    _tokenStart = _cursor;  
    // => 'float' !IDENT_PART SPACING # Choice
    switch (_ch == 102 ? 0 : _ch == -1 ? 2 : 1) {
      // [f]
      case 0:
        // => 'float' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'float'
          $$ = _matchString(_strings5, 'float');
          // <= 'float'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'float'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'float' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'float'
      _failure(_expect34);
    }
    // <= 'float' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_FloatType() {
    // SENTENCE (NONTERMINAL)
    // FloatType <- (FLOAT / DOUBLE) Metadata? TypeQualifiers?
    var $$;
    // => (FLOAT / DOUBLE) Metadata? TypeQualifiers? # Choice
    switch (_getState(_transitions12)) {
      // [d] [f]
      case 0:
        // => (FLOAT / DOUBLE) Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (FLOAT / DOUBLE) # Choice
          switch (_getState(_transitions13)) {
            // [d]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => DOUBLE
              $$ = _parse_DOUBLE();
              // <= DOUBLE
              _startPos = startPos1;
              break;
            // [f]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => FLOAT
              $$ = _parse_FLOAT();
              // <= FLOAT
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'float', 'double'
            _failure(_expect15);
          }
          // <= (FLOAT / DOUBLE) # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // (FLOAT / DOUBLE)
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new BuiltinTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3, typeKind: TypeSpecificationKind.FLOAT);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (FLOAT / DOUBLE) Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'float', 'double'
      _failure(_expect15);
    }
    // <= (FLOAT / DOUBLE) Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_FunctionDeclaration() {
    // SENTENCE (NONTERMINAL)
    // FunctionDeclaration <- Metadata? TypeQualifiers? FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionDeclarator
    var $$;
    // => Metadata? TypeQualifiers? FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionDeclarator # Choice
    switch (_getState(_transitions1)) {
      // [*]
      case 0:
        // => Metadata? TypeQualifiers? FunctionDeclarator # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => FunctionDeclarator
          $$ = _parse_FunctionDeclarator();
          // <= FunctionDeclarator
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // FunctionDeclarator
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new FunctionDeclaration(declarator: $3, metadata: $1, qualifiers: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? FunctionDeclarator # Sequence
        break;
      // [A-Z] [_] [a-z]
      // EOF
      case 1:
      case 3:
        while (true) {
          // => Metadata? TypeQualifiers? FunctionDeclarator # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => FunctionDeclarator
            $$ = _parse_FunctionDeclarator();
            // <= FunctionDeclarator
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // FunctionDeclarator
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new FunctionDeclaration(declarator: $3, metadata: $1, qualifiers: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Metadata? TypeQualifiers? FunctionDeclarator # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type FunctionDeclarator # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing4 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing4;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing5 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing5;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => FunctionDeclarator
            $$ = _parse_FunctionDeclarator();
            // <= FunctionDeclarator
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // FunctionDeclarator
              final $4 = seq[3];
              final $start = startPos2;
              $$ = new FunctionDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= Metadata? TypeQualifiers? Type FunctionDeclarator # Sequence
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionDeclarator # Choice
    return $$;
  }
  
  dynamic _parse_FunctionDeclarator() {
    // SENTENCE (NONTERMINAL)
    // FunctionDeclarator <- PointerSpecifiers? Identifier FunctionParameters Metadata?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[12] >= pos) {
      $$ = _getFromCache(12);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[12] = pos;
    }  
    // => PointerSpecifiers? Identifier FunctionParameters Metadata? # Choice
    switch (_getState(_transitions7)) {
      // [*] [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => PointerSpecifiers? Identifier FunctionParameters Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing0;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[1] = $$;
          // => FunctionParameters
          $$ = _parse_FunctionParameters();
          // <= FunctionParameters
          if (!success) break;
          seq[2] = $$;
          // => Metadata?
          var testing1 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing1;
          // <= Metadata?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // Identifier
            final $2 = seq[1];
            // FunctionParameters
            final $3 = seq[2];
            // Metadata?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Declarator(identifier: $2, metadata: $4, parameters: $3, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerSpecifiers? Identifier FunctionParameters Metadata? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= PointerSpecifiers? Identifier FunctionParameters Metadata? # Choice
    if (_cacheable[12]) {
      _addToCache($$, pos, 12);
    }    
    return $$;
  }
  
  dynamic _parse_FunctionParameterDeclaration() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameterDeclaration <- ParameterDeclarationNotAbstract / ParameterDeclarationAbstract
    var $$;          
    var pos = _cursor;             
    if(_cachePos[18] >= pos) {
      $$ = _getFromCache(18);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[18] = pos;
    }  
    // => ParameterDeclarationNotAbstract / ParameterDeclarationAbstract # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => ParameterDeclarationNotAbstract
          $$ = _parse_ParameterDeclarationNotAbstract();
          // <= ParameterDeclarationNotAbstract
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => ParameterDeclarationAbstract
          $$ = _parse_ParameterDeclarationAbstract();
          // <= ParameterDeclarationAbstract
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= ParameterDeclarationNotAbstract / ParameterDeclarationAbstract # Choice
    if (_cacheable[18]) {
      _addToCache($$, pos, 18);
    }    
    return $$;
  }
  
  dynamic _parse_FunctionParameterList() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameterList <- FunctionParameterListNoVaList (COMMA VA_LIST_PARAMETER)?
    var $$;
    // => FunctionParameterListNoVaList (COMMA VA_LIST_PARAMETER)? # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => FunctionParameterListNoVaList (COMMA VA_LIST_PARAMETER)? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FunctionParameterListNoVaList
          $$ = _parse_FunctionParameterListNoVaList();
          // <= FunctionParameterListNoVaList
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA VA_LIST_PARAMETER)?
          var testing0 = _testing;
          _testing = _cursor;
          // => (COMMA VA_LIST_PARAMETER) # Choice
          switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
            // [,]
            case 0:
              // => COMMA VA_LIST_PARAMETER # Sequence
              var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                // => COMMA
                $$ = _parse_COMMA();
                // <= COMMA
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                // => VA_LIST_PARAMETER
                $$ = _parse_VA_LIST_PARAMETER();
                // <= VA_LIST_PARAMETER
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                if (success) {    
                  // COMMA
                  final $1 = seq[0];
                  // VA_LIST_PARAMETER
                  final $2 = seq[1];
                  final $start = startPos1;
                  $$ = $2;
                }
                break;
              }
              if (!success) {
                _ch = ch1;
                _cursor = pos1;
              }
              _startPos = startPos1;
              // <= COMMA VA_LIST_PARAMETER # Sequence
              break;
            // No matches
            // EOF
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: ','
            _failure(_expect6);
          }
          // <= (COMMA VA_LIST_PARAMETER) # Choice
          success = true; 
          _testing = testing0;
          // <= (COMMA VA_LIST_PARAMETER)?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // FunctionParameterListNoVaList
            final $1 = seq[0];
            // (COMMA VA_LIST_PARAMETER)?
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _createParameters($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionParameterListNoVaList (COMMA VA_LIST_PARAMETER)? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= FunctionParameterListNoVaList (COMMA VA_LIST_PARAMETER)? # Choice
    return $$;
  }
  
  dynamic _parse_FunctionParameterListNoVaList() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameterListNoVaList <- FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)*
    var $$;
    // => FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FunctionParameterDeclaration
          $$ = _parse_FunctionParameterDeclaration();
          // <= FunctionParameterDeclaration
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA FunctionParameterDeclaration)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA FunctionParameterDeclaration) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA FunctionParameterDeclaration # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => FunctionParameterDeclaration
                  $$ = _parse_FunctionParameterDeclaration();
                  // <= FunctionParameterDeclaration
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA FunctionParameterDeclaration # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect6);
            }
            // <= (COMMA FunctionParameterDeclaration) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA FunctionParameterDeclaration)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // FunctionParameterDeclaration
            final $1 = seq[0];
            // (COMMA FunctionParameterDeclaration)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* # Choice
    return $$;
  }
  
  dynamic _parse_FunctionParameters() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameters <- OPEN_PAREN FunctionParameterList? CLOSE_PAREN
    var $$;          
    var pos = _cursor;             
    if(_cachePos[15] >= pos) {
      $$ = _getFromCache(15);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[15] = pos;
    }  
    // => OPEN_PAREN FunctionParameterList? CLOSE_PAREN # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => OPEN_PAREN FunctionParameterList? CLOSE_PAREN # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => FunctionParameterList?
          var testing0 = _testing;
          _testing = _cursor;
          // => FunctionParameterList
          $$ = _parse_FunctionParameterList();
          // <= FunctionParameterList
          success = true; 
          _testing = testing0;
          // <= FunctionParameterList?
          if (!success) break;
          seq[1] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // OPEN_PAREN
            final $1 = seq[0];
            // FunctionParameterList?
            final $2 = seq[1];
            // CLOSE_PAREN
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new FunctionParameters($2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= OPEN_PAREN FunctionParameterList? CLOSE_PAREN # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect11);
    }
    // <= OPEN_PAREN FunctionParameterList? CLOSE_PAREN # Choice
    if (_cacheable[15]) {
      _addToCache($$, pos, 15);
    }    
    return $$;
  }
  
  dynamic _parse_FunctionPointerDeclarator() {
    // SENTENCE (NONTERMINAL)
    // FunctionPointerDeclarator <- PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN FunctionParameters ArrayDimensions? Metadata?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[44] >= pos) {
      $$ = _getFromCache(44);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[44] = pos;
    }  
    // => PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN FunctionParameters ArrayDimensions? Metadata? # Choice
    switch (_getState(_transitions21)) {
      // [(] [*]
      case 0:
        // => PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN FunctionParameters ArrayDimensions? Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing0;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(8)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          if (!success) break;
          seq[2] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[4] = $$;
          // => FunctionParameters
          $$ = _parse_FunctionParameters();
          // <= FunctionParameters
          if (!success) break;
          seq[5] = $$;
          // => ArrayDimensions?
          var testing1 = _testing;
          _testing = _cursor;
          // => ArrayDimensions
          $$ = _parse_ArrayDimensions();
          // <= ArrayDimensions
          success = true; 
          _testing = testing1;
          // <= ArrayDimensions?
          if (!success) break;
          seq[6] = $$;
          // => Metadata?
          var testing2 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing2;
          // <= Metadata?
          if (!success) break;
          seq[7] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // PointerSpecifiers
            final $3 = seq[2];
            // Identifier
            final $4 = seq[3];
            // CLOSE_PAREN
            final $5 = seq[4];
            // FunctionParameters
            final $6 = seq[5];
            // ArrayDimensions?
            final $7 = seq[6];
            // Metadata?
            final $8 = seq[7];
            final $start = startPos0;
            $$ = new Declarator(dimensions: $7, functionPointers: $3, identifier: $4, metadata: $8, parameters: $6, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN FunctionParameters ArrayDimensions? Metadata? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect11);
    }
    // <= PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN FunctionParameters ArrayDimensions? Metadata? # Choice
    if (_cacheable[44]) {
      _addToCache($$, pos, 44);
    }    
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_DIGIT() {
    // MORHEME
    // HEXADECIMAL_DIGIT <- [0-af]
    var $$;
    // => [0-af] # Choice
    switch (_getState(_transitions31)) {
      // [0-a] [f]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-af]
        $$ = _matchMapping(48, 102, _mapping1);
        // <= [0-af]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [0-af] # Choice
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_ESCAPE_SEQUENCE() {
    // MORHEME
    // HEXADECIMAL_ESCAPE_SEQUENCE <- '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1
    var $$;
    // => '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        // => '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '\\x'
          $$ = _matchString(_strings17, '\\x');
          // <= '\\x'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[1] = $$;
          // => HEXADECIMAL_ESCAPE_SEQUENCE1
          $$ = _parse_HEXADECIMAL_ESCAPE_SEQUENCE1();
          // <= HEXADECIMAL_ESCAPE_SEQUENCE1
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '\\x'
            final $1 = seq[0];
            // HEXADECIMAL_DIGIT
            final $2 = seq[1];
            // HEXADECIMAL_ESCAPE_SEQUENCE1
            final $3 = seq[2];
            final $start = startPos0;
            $$ = int.parse(_text(2), radix: 16);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: \x
      _failure(_expect52);
    }
    // <= '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Choice
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_ESCAPE_SEQUENCE1() {
    // MORHEME
    // HEXADECIMAL_ESCAPE_SEQUENCE1 <- HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 / ''
    var $$;
    // => HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 / '' # Choice
    switch (_getState(_transitions32)) {
      // [\u0000-/] [b-e] [g-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-a] [f]
      case 1:
        while (true) {
          // => HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => HEXADECIMAL_DIGIT
            $$ = _parse_HEXADECIMAL_DIGIT();
            // <= HEXADECIMAL_DIGIT
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => HEXADECIMAL_ESCAPE_SEQUENCE1
            $$ = _parse_HEXADECIMAL_ESCAPE_SEQUENCE1();
            // <= HEXADECIMAL_ESCAPE_SEQUENCE1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // HEXADECIMAL_DIGIT
              final $1 = seq[0];
              // HEXADECIMAL_ESCAPE_SEQUENCE1
              final $2 = seq[1];
              final $start = startPos1;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 / '' # Choice
    return $$;
  }
  
  dynamic _parse_HEX_QUAD() {
    // MORHEME
    // HEX_QUAD <- HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT
    var $$;
    // => HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT # Choice
    switch (_getState(_transitions31)) {
      // [0-a] [f]
      case 0:
        // => HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[1] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[2] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // HEXADECIMAL_DIGIT
            final $1 = seq[0];
            // HEXADECIMAL_DIGIT
            final $2 = seq[1];
            // HEXADECIMAL_DIGIT
            final $3 = seq[2];
            // HEXADECIMAL_DIGIT
            final $4 = seq[3];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT # Choice
    return $$;
  }
  
  dynamic _parse_IDENT() {
    // LEXEME (TOKEN)
    // IDENT <- IDENT_START IDENT_CONT* SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[71] >= pos) {
      $$ = _getFromCache(71);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[71] = pos;
    }  
    _token = 15;    
    _tokenStart = _cursor;    
    // => IDENT_START IDENT_CONT* SPACING # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      case 0:
        // => IDENT_START IDENT_CONT* SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENT_CONT*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => IDENT_CONT
            $$ = _parse_IDENT_CONT();
            // <= IDENT_CONT
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= IDENT_CONT*
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // IDENT_START
            final $1 = seq[0];
            // IDENT_CONT*
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _flatten([$1, $2]).join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= IDENT_START IDENT_CONT* SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT
      _failure(_expect5);
    }
    // <= IDENT_START IDENT_CONT* SPACING # Choice
    if (_cacheable[71]) {
      _addToCache($$, pos, 71);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_IDENTIFIER() {
    // MORHEME
    // IDENTIFIER <- !RESERVED_WORD IDENT_START IDENT_CONT* SPACING
    var $$;
    // => !RESERVED_WORD IDENT_START IDENT_CONT* SPACING # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => !RESERVED_WORD IDENT_START IDENT_CONT* SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !RESERVED_WORD
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => RESERVED_WORD
          $$ = _parse_RESERVED_WORD();
          // <= RESERVED_WORD
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !RESERVED_WORD
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          if (!success) break;
          seq[1] = $$;
          // => IDENT_CONT*
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => IDENT_CONT
            $$ = _parse_IDENT_CONT();
            // <= IDENT_CONT
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          // <= IDENT_CONT*
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // !RESERVED_WORD
            final $1 = seq[0];
            // IDENT_START
            final $2 = seq[1];
            // IDENT_CONT*
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            final $start = startPos0;
            $$ = _flatten([$2, $3]).join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !RESERVED_WORD IDENT_START IDENT_CONT* SPACING # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= !RESERVED_WORD IDENT_START IDENT_CONT* SPACING # Choice
    return $$;
  }
  
  dynamic _parse_IDENT_CONT() {
    // MORHEME
    // IDENT_CONT <- IDENT_START / [0-9]
    var $$;
    // => IDENT_START / [0-9] # Choice
    switch (_getState(_transitions33)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-9]
        $$ = _matchRange(48, 57);
        // <= [0-9]
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => IDENT_START
        $$ = _parse_IDENT_START();
        // <= IDENT_START
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= IDENT_START / [0-9] # Choice
    return $$;
  }
  
  dynamic _parse_IDENT_PART() {
    // MORHEME
    // IDENT_PART <- IDENT_START / IDENT_CONT
    var $$;
    // => IDENT_START / IDENT_CONT # Choice
    switch (_getState(_transitions33)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => IDENT_CONT
        $$ = _parse_IDENT_CONT();
        // <= IDENT_CONT
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => IDENT_CONT
          $$ = _parse_IDENT_CONT();
          // <= IDENT_CONT
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= IDENT_START / IDENT_CONT # Choice
    return $$;
  }
  
  dynamic _parse_IDENT_START() {
    // MORHEME
    // IDENT_START <- [A-Z_a-z]
    var $$;
    // => [A-Z_a-z] # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [A-Z_a-z]
        $$ = _matchMapping(65, 122, _mapping2);
        // <= [A-Z_a-z]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [A-Z_a-z] # Choice
    return $$;
  }
  
  dynamic _parse_INT() {
    // LEXEME (TOKEN)
    // INT <- 'int' !IDENT_PART SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[72] >= pos) {
      $$ = _getFromCache(72);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[72] = pos;
    }  
    _token = 16;    
    _tokenStart = _cursor;    
    // => 'int' !IDENT_PART SPACING # Choice
    switch (_ch == 105 ? 0 : _ch == -1 ? 2 : 1) {
      // [i]
      case 0:
        // => 'int' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'int'
          $$ = _matchString(_strings6, 'int');
          // <= 'int'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'int'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'int' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'int'
      _failure(_expect35);
    }
    // <= 'int' !IDENT_PART SPACING # Choice
    if (_cacheable[72]) {
      _addToCache($$, pos, 72);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_INTEGER() {
    // MORHEME
    // INTEGER <- SIGN? [0-9]+ SPACING
    var $$;
    // => SIGN? [0-9]+ SPACING # Choice
    switch (_getState(_transitions20)) {
      // [+] [-] [0-9]
      case 0:
        // => SIGN? [0-9]+ SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => SIGN?
          var testing0 = _testing;
          _testing = _cursor;
          // => SIGN
          $$ = _parse_SIGN();
          // <= SIGN
          success = true; 
          _testing = testing0;
          // <= SIGN?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => [0-9]+
          var testing1;
          for (var first = true, reps; ;) {  
            // => [0-9]  
            $$ = _matchRange(48, 57);  
            // <= [0-9]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing1 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing1;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0-9]+
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // SIGN?
            final $1 = seq[0];
            // [0-9]+
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _parseInt($1, $2.join(), 10);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SIGN? [0-9]+ SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= SIGN? [0-9]+ SPACING # Choice
    return $$;
  }
  
  dynamic _parse_Identifier() {
    // LEXEME (TOKEN)
    // Identifier <- IDENTIFIER
    var $$;          
    var pos = _cursor;             
    if(_cachePos[73] >= pos) {
      $$ = _getFromCache(73);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[73] = pos;
    }  
    _token = 17;    
    _tokenStart = _cursor;    
    // => IDENTIFIER # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => IDENTIFIER
        $$ = _parse_IDENTIFIER();
        // <= IDENTIFIER
        if (success) {    
          // IDENTIFIER
          final $1 = $$;
          final $start = startPos0;
          $$ = new Identifier(name: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= IDENTIFIER # Choice
    if (_cacheable[73]) {
      _addToCache($$, pos, 73);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_IntegerType() {
    // SENTENCE (NONTERMINAL)
    // IntegerType <- SIGNEDNESS? (SHORT / LONG_TYPE) INT? Metadata? TypeQualifiers? / SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? / SIGNEDNESS Metadata? TypeQualifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[22] >= pos) {
      $$ = _getFromCache(22);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[22] = pos;
    }  
    // => SIGNEDNESS? (SHORT / LONG_TYPE) INT? Metadata? TypeQualifiers? / SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? / SIGNEDNESS Metadata? TypeQualifiers? # Choice
    switch (_getState(_transitions9)) {
      // [c] [i]
      case 0:
        // => SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => SIGNEDNESS?
          var testing0 = _testing;
          _testing = _cursor;
          // => SIGNEDNESS
          $$ = _parse_SIGNEDNESS();
          // <= SIGNEDNESS
          success = true; 
          _testing = testing0;
          // <= SIGNEDNESS?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => (CHAR / INT / SHORT / LONG_TYPE) # Choice
          switch (_getState(_transitions10)) {
            // [c]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => CHAR
              $$ = _parse_CHAR();
              // <= CHAR
              _startPos = startPos1;
              break;
            // [i]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => INT
              $$ = _parse_INT();
              // <= INT
              _startPos = startPos2;
              break;
            // [l]
            case 2:
              var startPos3 = _startPos;
              _startPos = _cursor;
              // => LONG_TYPE
              $$ = _parse_LONG_TYPE();
              // <= LONG_TYPE
              _startPos = startPos3;
              break;
            // [s]
            case 3:
              var startPos4 = _startPos;
              _startPos = _cursor;
              // => SHORT
              $$ = _parse_SHORT();
              // <= SHORT
              _startPos = startPos4;
              break;
            // No matches
            // EOF
            case 4:
            case 5:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'char', 'int', 'short', 'long'
            _failure(_expect13);
          }
          // <= (CHAR / INT / SHORT / LONG_TYPE) # Choice
          if (!success) break;
          seq[1] = $$;
          // => Metadata?
          var testing1 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing1;
          // <= Metadata?
          if (!success) break;
          seq[2] = $$;
          // => TypeQualifiers?
          var testing2 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing2;
          // <= TypeQualifiers?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // SIGNEDNESS?
            final $1 = seq[0];
            // (CHAR / INT / SHORT / LONG_TYPE)
            final $2 = seq[1];
            // Metadata?
            final $3 = seq[2];
            // TypeQualifiers?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new BuiltinTypeSpecification(identifier: _ident([$1, $2]), metadata: $3, qualifiers: $4, typeKind: TypeSpecificationKind.INTEGER);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? # Sequence
        break;
      // [l]
      case 1:
        while (true) {
          // => SIGNEDNESS? (SHORT / LONG_TYPE) INT? Metadata? TypeQualifiers? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNEDNESS?
            var testing3 = _testing;
            _testing = _cursor;
            // => SIGNEDNESS
            $$ = _parse_SIGNEDNESS();
            // <= SIGNEDNESS
            success = true; 
            _testing = testing3;
            // <= SIGNEDNESS?
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => (SHORT / LONG_TYPE) # Choice
            switch (_getState(_transitions11)) {
              // [l]
              case 0:
                var startPos6 = _startPos;
                _startPos = _cursor;
                // => LONG_TYPE
                $$ = _parse_LONG_TYPE();
                // <= LONG_TYPE
                _startPos = startPos6;
                break;
              // [s]
              case 1:
                var startPos7 = _startPos;
                _startPos = _cursor;
                // => SHORT
                $$ = _parse_SHORT();
                // <= SHORT
                _startPos = startPos7;
                break;
              // No matches
              // EOF
              case 2:
              case 3:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'short', 'long'
              _failure(_expect14);
            }
            // <= (SHORT / LONG_TYPE) # Choice
            if (!success) break;
            seq[1] = $$;
            // => INT?
            var testing4 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing4;
            // <= INT?
            if (!success) break;
            seq[2] = $$;
            // => Metadata?
            var testing5 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing5;
            // <= Metadata?
            if (!success) break;
            seq[3] = $$;
            // => TypeQualifiers?
            var testing6 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing6;
            // <= TypeQualifiers?
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              // SIGNEDNESS?
              final $1 = seq[0];
              // (SHORT / LONG_TYPE)
              final $2 = seq[1];
              // INT?
              final $3 = seq[2];
              // Metadata?
              final $4 = seq[3];
              // TypeQualifiers?
              final $5 = seq[4];
              final $start = startPos5;
              $$ = new BuiltinTypeSpecification(identifier: _ident([$1, $2, $3]), metadata: $4, qualifiers: $5, typeKind: TypeSpecificationKind.INTEGER);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos5;
          // <= SIGNEDNESS? (SHORT / LONG_TYPE) INT? Metadata? TypeQualifiers? # Sequence
          if (success) break;
          // => SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos8 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNEDNESS?
            var testing7 = _testing;
            _testing = _cursor;
            // => SIGNEDNESS
            $$ = _parse_SIGNEDNESS();
            // <= SIGNEDNESS
            success = true; 
            _testing = testing7;
            // <= SIGNEDNESS?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => (CHAR / INT / SHORT / LONG_TYPE) # Choice
            switch (_getState(_transitions10)) {
              // [c]
              case 0:
                var startPos9 = _startPos;
                _startPos = _cursor;
                // => CHAR
                $$ = _parse_CHAR();
                // <= CHAR
                _startPos = startPos9;
                break;
              // [i]
              case 1:
                var startPos10 = _startPos;
                _startPos = _cursor;
                // => INT
                $$ = _parse_INT();
                // <= INT
                _startPos = startPos10;
                break;
              // [l]
              case 2:
                var startPos11 = _startPos;
                _startPos = _cursor;
                // => LONG_TYPE
                $$ = _parse_LONG_TYPE();
                // <= LONG_TYPE
                _startPos = startPos11;
                break;
              // [s]
              case 3:
                var startPos12 = _startPos;
                _startPos = _cursor;
                // => SHORT
                $$ = _parse_SHORT();
                // <= SHORT
                _startPos = startPos12;
                break;
              // No matches
              // EOF
              case 4:
              case 5:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'char', 'int', 'short', 'long'
              _failure(_expect13);
            }
            // <= (CHAR / INT / SHORT / LONG_TYPE) # Choice
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing8 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing8;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            // => TypeQualifiers?
            var testing9 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing9;
            // <= TypeQualifiers?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // SIGNEDNESS?
              final $1 = seq[0];
              // (CHAR / INT / SHORT / LONG_TYPE)
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              // TypeQualifiers?
              final $4 = seq[3];
              final $start = startPos8;
              $$ = new BuiltinTypeSpecification(identifier: _ident([$1, $2]), metadata: $3, qualifiers: $4, typeKind: TypeSpecificationKind.INTEGER);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos8;
          // <= SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? # Sequence
          break;
        }
        break;
      // [s] [u]
      case 2:
        while (true) {
          // => SIGNEDNESS? (SHORT / LONG_TYPE) INT? Metadata? TypeQualifiers? # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos13 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNEDNESS?
            var testing10 = _testing;
            _testing = _cursor;
            // => SIGNEDNESS
            $$ = _parse_SIGNEDNESS();
            // <= SIGNEDNESS
            success = true; 
            _testing = testing10;
            // <= SIGNEDNESS?
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => (SHORT / LONG_TYPE) # Choice
            switch (_getState(_transitions11)) {
              // [l]
              case 0:
                var startPos14 = _startPos;
                _startPos = _cursor;
                // => LONG_TYPE
                $$ = _parse_LONG_TYPE();
                // <= LONG_TYPE
                _startPos = startPos14;
                break;
              // [s]
              case 1:
                var startPos15 = _startPos;
                _startPos = _cursor;
                // => SHORT
                $$ = _parse_SHORT();
                // <= SHORT
                _startPos = startPos15;
                break;
              // No matches
              // EOF
              case 2:
              case 3:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'short', 'long'
              _failure(_expect14);
            }
            // <= (SHORT / LONG_TYPE) # Choice
            if (!success) break;
            seq[1] = $$;
            // => INT?
            var testing11 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing11;
            // <= INT?
            if (!success) break;
            seq[2] = $$;
            // => Metadata?
            var testing12 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing12;
            // <= Metadata?
            if (!success) break;
            seq[3] = $$;
            // => TypeQualifiers?
            var testing13 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing13;
            // <= TypeQualifiers?
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              // SIGNEDNESS?
              final $1 = seq[0];
              // (SHORT / LONG_TYPE)
              final $2 = seq[1];
              // INT?
              final $3 = seq[2];
              // Metadata?
              final $4 = seq[3];
              // TypeQualifiers?
              final $5 = seq[4];
              final $start = startPos13;
              $$ = new BuiltinTypeSpecification(identifier: _ident([$1, $2, $3]), metadata: $4, qualifiers: $5, typeKind: TypeSpecificationKind.INTEGER);
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos13;
          // <= SIGNEDNESS? (SHORT / LONG_TYPE) INT? Metadata? TypeQualifiers? # Sequence
          if (success) break;
          // => SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos16 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNEDNESS?
            var testing14 = _testing;
            _testing = _cursor;
            // => SIGNEDNESS
            $$ = _parse_SIGNEDNESS();
            // <= SIGNEDNESS
            success = true; 
            _testing = testing14;
            // <= SIGNEDNESS?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => (CHAR / INT / SHORT / LONG_TYPE) # Choice
            switch (_getState(_transitions10)) {
              // [c]
              case 0:
                var startPos17 = _startPos;
                _startPos = _cursor;
                // => CHAR
                $$ = _parse_CHAR();
                // <= CHAR
                _startPos = startPos17;
                break;
              // [i]
              case 1:
                var startPos18 = _startPos;
                _startPos = _cursor;
                // => INT
                $$ = _parse_INT();
                // <= INT
                _startPos = startPos18;
                break;
              // [l]
              case 2:
                var startPos19 = _startPos;
                _startPos = _cursor;
                // => LONG_TYPE
                $$ = _parse_LONG_TYPE();
                // <= LONG_TYPE
                _startPos = startPos19;
                break;
              // [s]
              case 3:
                var startPos20 = _startPos;
                _startPos = _cursor;
                // => SHORT
                $$ = _parse_SHORT();
                // <= SHORT
                _startPos = startPos20;
                break;
              // No matches
              // EOF
              case 4:
              case 5:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'char', 'int', 'short', 'long'
              _failure(_expect13);
            }
            // <= (CHAR / INT / SHORT / LONG_TYPE) # Choice
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing15 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing15;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            // => TypeQualifiers?
            var testing16 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing16;
            // <= TypeQualifiers?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // SIGNEDNESS?
              final $1 = seq[0];
              // (CHAR / INT / SHORT / LONG_TYPE)
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              // TypeQualifiers?
              final $4 = seq[3];
              final $start = startPos16;
              $$ = new BuiltinTypeSpecification(identifier: _ident([$1, $2]), metadata: $3, qualifiers: $4, typeKind: TypeSpecificationKind.INTEGER);
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos16;
          // <= SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? # Sequence
          if (success) break;
          // => SIGNEDNESS Metadata? TypeQualifiers? # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos21 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNEDNESS
            $$ = _parse_SIGNEDNESS();
            // <= SIGNEDNESS
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => Metadata?
            var testing17 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing17;
            // <= Metadata?
            if (!success) break;
            seq[1] = $$;
            // => TypeQualifiers?
            var testing18 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing18;
            // <= TypeQualifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIGNEDNESS
              final $1 = seq[0];
              // Metadata?
              final $2 = seq[1];
              // TypeQualifiers?
              final $3 = seq[2];
              final $start = startPos21;
              $$ = new BuiltinTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3, typeKind: TypeSpecificationKind.INTEGER);
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos21;
          // <= SIGNEDNESS Metadata? TypeQualifiers? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'short', 'long', 'char', 'int', SIGNEDNESS
      _failure(_expect12);
    }
    // <= SIGNEDNESS? (SHORT / LONG_TYPE) INT? Metadata? TypeQualifiers? / SIGNEDNESS? (CHAR / INT / SHORT / LONG_TYPE) Metadata? TypeQualifiers? / SIGNEDNESS Metadata? TypeQualifiers? # Choice
    if (_cacheable[22]) {
      _addToCache($$, pos, 22);
    }    
    return $$;
  }
  
  dynamic _parse_LEADING_SPACES() {
    // LEXEME (TOKEN)
    // LEADING_SPACES <- SPACING
    var $$;
    _token = 18;  
    _tokenStart = _cursor;  
    // => SPACING # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => SPACING
        $$ = _parse_SPACING();
        // <= SPACING
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: LEADING_SPACES
      _failure(_expect36);
    }
    // <= SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_LONG() {
    // MORHEME
    // LONG <- 'long' !IDENT_PART SPACING
    var $$;
    // => 'long' !IDENT_PART SPACING # Choice
    switch (_ch == 108 ? 0 : _ch == -1 ? 2 : 1) {
      // [l]
      case 0:
        // => 'long' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'long'
          $$ = _matchString(_strings18, 'long');
          // <= 'long'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'long'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'long' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: long
      _failure(_expect53);
    }
    // <= 'long' !IDENT_PART SPACING # Choice
    return $$;
  }
  
  dynamic _parse_LONG_TYPE() {
    // LEXEME (TOKEN)
    // LONG_TYPE <- LONG LONG / LONG
    var $$;          
    var pos = _cursor;             
    if(_cachePos[75] >= pos) {
      $$ = _getFromCache(75);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[75] = pos;
    }  
    _token = 19;    
    _tokenStart = _cursor;    
    // => LONG LONG / LONG # Choice
    switch (_ch == 108 ? 0 : _ch == -1 ? 2 : 1) {
      // [l]
      case 0:
        while (true) {
          // => LONG LONG # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => LONG
            $$ = _parse_LONG();
            // <= LONG
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => LONG
            $$ = _parse_LONG();
            // <= LONG
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // LONG
              final $1 = seq[0];
              // LONG
              final $2 = seq[1];
              final $start = startPos0;
              $$ = "long long";
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= LONG LONG # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => LONG
          $$ = _parse_LONG();
          // <= LONG
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'long'
      _failure(_expect37);
    }
    // <= LONG LONG / LONG # Choice
    if (_cacheable[75]) {
      _addToCache($$, pos, 75);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_MINUS() {
    // MORHEME
    // MINUS <- '-' SPACING
    var $$;
    // => '-' SPACING # Choice
    switch (_ch == 45 ? 0 : _ch == -1 ? 2 : 1) {
      // [-]
      case 0:
        // => '-' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '-'
          $$ = '-';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '-'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '-'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '-' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: -
      _failure(_expect39);
    }
    // <= '-' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_Metadata() {
    // SENTENCE (NONTERMINAL)
    // Metadata <- DeclarationSpecifier+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[4] >= pos) {
      $$ = _getFromCache(4);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[4] = pos;
    }  
    // => DeclarationSpecifier+ # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => DeclarationSpecifier+
        var testing0;
        for (var first = true, reps; ;) {  
          // => DeclarationSpecifier  
          $$ = _parse_DeclarationSpecifier();  
          // <= DeclarationSpecifier  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= DeclarationSpecifier+
        if (success) {    
          // DeclarationSpecifier+
          final $1 = $$;
          final $start = startPos0;
          $$ = new DeclarationSpecifiers($1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '__attribute__'
      _failure(_expect4);
    }
    // <= DeclarationSpecifier+ # Choice
    if (_cacheable[4]) {
      _addToCache($$, pos, 4);
    }    
    return $$;
  }
  
  dynamic _parse_NUMBER() {
    // LEXEME (TOKEN)
    // NUMBER <- OCTAL_NUMBER / INTEGER
    var $$;          
    var pos = _cursor;             
    if(_cachePos[76] >= pos) {
      $$ = _getFromCache(76);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[76] = pos;
    }  
    _token = 20;    
    _tokenStart = _cursor;    
    // => OCTAL_NUMBER / INTEGER # Choice
    switch (_getState(_transitions27)) {
      // [+] [-] [0]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => OCTAL_NUMBER
          $$ = _parse_OCTAL_NUMBER();
          // <= OCTAL_NUMBER
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => INTEGER
          $$ = _parse_INTEGER();
          // <= INTEGER
          _startPos = startPos1;
          break;
        }
        break;
      // [1-9]
      case 1:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => INTEGER
        $$ = _parse_INTEGER();
        // <= INTEGER
        _startPos = startPos2;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NUMBER
      _failure(_expect38);
    }
    // <= OCTAL_NUMBER / INTEGER # Choice
    if (_cacheable[76]) {
      _addToCache($$, pos, 76);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OCTAL_DIGIT() {
    // MORHEME
    // OCTAL_DIGIT <- [0-7]
    var $$;
    // => [0-7] # Choice
    switch (_ch >= 48 && _ch <= 55 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-7]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-7]
        $$ = _matchRange(48, 55);
        // <= [0-7]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [0-7] # Choice
    return $$;
  }
  
  dynamic _parse_OCTAL_ESCAPE_SEQUENCE() {
    // MORHEME
    // OCTAL_ESCAPE_SEQUENCE <- '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT
    var $$;
    // => '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          // => '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[1] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[2] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // OCTAL_DIGIT
              final $2 = seq[1];
              // OCTAL_DIGIT
              final $3 = seq[2];
              // OCTAL_DIGIT
              final $4 = seq[3];
              final $start = startPos0;
              $$ = int.parse(_text(1), radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT # Sequence
          if (success) break;
          // => '\\' OCTAL_DIGIT OCTAL_DIGIT # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[1] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // OCTAL_DIGIT
              final $2 = seq[1];
              // OCTAL_DIGIT
              final $3 = seq[2];
              final $start = startPos1;
              $$ = int.parse(_text(1), radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '\\' OCTAL_DIGIT OCTAL_DIGIT # Sequence
          if (success) break;
          // => '\\' OCTAL_DIGIT # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // OCTAL_DIGIT
              final $2 = seq[1];
              final $start = startPos2;
              $$ = int.parse($2, radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= '\\' OCTAL_DIGIT # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: \
      _failure(_expect54);
    }
    // <= '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT # Choice
    return $$;
  }
  
  dynamic _parse_OCTAL_NUMBER() {
    // MORHEME
    // OCTAL_NUMBER <- SIGN? [0] [0-9]+
    var $$;
    // => SIGN? [0] [0-9]+ # Choice
    switch (_getState(_transitions34)) {
      // [+] [-] [0]
      case 0:
        // => SIGN? [0] [0-9]+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => SIGN?
          var testing0 = _testing;
          _testing = _cursor;
          // => SIGN
          $$ = _parse_SIGN();
          // <= SIGN
          success = true; 
          _testing = testing0;
          // <= SIGN?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => [0]
          $$ = _matchChar(48, '0');
          // <= [0]
          if (!success) break;
          seq[1] = $$;
          // => [0-9]+
          var testing1;
          for (var first = true, reps; ;) {  
            // => [0-9]  
            $$ = _matchRange(48, 57);  
            // <= [0-9]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing1 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing1;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0-9]+
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // SIGN?
            final $1 = seq[0];
            // [0]
            final $2 = seq[1];
            // [0-9]+
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _parseInt($1, _flatten([$2, $3]).join(), 8);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SIGN? [0] [0-9]+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= SIGN? [0] [0-9]+ # Choice
    return $$;
  }
  
  dynamic _parse_OPEN_BRACE() {
    // LEXEME (TOKEN)
    // OPEN_BRACE <- '{' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[77] >= pos) {
      $$ = _getFromCache(77);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[77] = pos;
    }  
    _token = 21;    
    _tokenStart = _cursor;    
    // => '{' SPACING # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => '{' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '{'
          $$ = '{';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '{'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '{'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '{' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '{'
      _failure(_expect19);
    }
    // <= '{' SPACING # Choice
    if (_cacheable[77]) {
      _addToCache($$, pos, 77);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OPEN_BRACKET() {
    // LEXEME (TOKEN)
    // OPEN_BRACKET <- '[' SPACING
    var $$;
    _token = 22;  
    _tokenStart = _cursor;  
    // => '[' SPACING # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => '[' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '['
          $$ = '[';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '['
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '['
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '[' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect22);
    }
    // <= '[' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OPEN_PAREN() {
    // LEXEME (TOKEN)
    // OPEN_PAREN <- '(' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[79] >= pos) {
      $$ = _getFromCache(79);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[79] = pos;
    }  
    _token = 23;    
    _tokenStart = _cursor;    
    // => '(' SPACING # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => '(' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '('
          $$ = '(';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '('
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '('
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '(' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect11);
    }
    // <= '(' SPACING # Choice
    if (_cacheable[79]) {
      _addToCache($$, pos, 79);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_PLUS() {
    // MORHEME
    // PLUS <- '+' SPACING
    var $$;
    // => '+' SPACING # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        // => '+' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '+'
          $$ = '+';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '+'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '+'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '+' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: +
      _failure(_expect55);
    }
    // <= '+' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_POSITIVE_NUMBER() {
    // LEXEME (TOKEN)
    // POSITIVE_NUMBER <- !('-' SPACING) (OCTAL_NUMBER / INTEGER)
    var $$;          
    var pos = _cursor;             
    if(_cachePos[80] >= pos) {
      $$ = _getFromCache(80);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[80] = pos;
    }  
    _token = 24;    
    _tokenStart = _cursor;    
    // => !('-' SPACING) (OCTAL_NUMBER / INTEGER) # Choice
    switch (_getState(_transitions20)) {
      // [+] [-] [0-9]
      // EOF
      case 0:
      case 2:
        // => !('-' SPACING) (OCTAL_NUMBER / INTEGER) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !('-' SPACING)
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => ('-' SPACING) # Choice
          switch (_ch == 45 ? 0 : _ch == -1 ? 2 : 1) {
            // [-]
            case 0:
              // => '-' SPACING # Sequence
              var ch2 = _ch, pos2 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                // => '-'
                $$ = '-';
                success = true;
                if (++_cursor < _inputLen) {
                  _ch = _input[_cursor];
                } else {
                  _ch = -1;
                }
                // <= '-'
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                // => SPACING
                $$ = _parse_SPACING();
                // <= SPACING
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                break;
              }
              if (!success) {
                _ch = ch2;
                _cursor = pos2;
              }
              _startPos = startPos1;
              // <= '-' SPACING # Sequence
              break;
            // No matches
            // EOF
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: -
            _failure(_expect39);
          }
          // <= ('-' SPACING) # Choice
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !('-' SPACING)
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (OCTAL_NUMBER / INTEGER) # Choice
          switch (_getState(_transitions27)) {
            // [+] [-] [0]
            case 0:
              while (true) {
                var startPos2 = _startPos;
                _startPos = _cursor;
                // => OCTAL_NUMBER
                $$ = _parse_OCTAL_NUMBER();
                // <= OCTAL_NUMBER
                _startPos = startPos2;
                if (success) break;
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => INTEGER
                $$ = _parse_INTEGER();
                // <= INTEGER
                _startPos = startPos3;
                break;
              }
              break;
            // [1-9]
            case 1:
              var startPos4 = _startPos;
              _startPos = _cursor;
              // => INTEGER
              $$ = _parse_INTEGER();
              // <= INTEGER
              _startPos = startPos4;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (OCTAL_NUMBER / INTEGER) # Choice
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // !('-' SPACING)
            final $1 = seq[0];
            // (OCTAL_NUMBER / INTEGER)
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !('-' SPACING) (OCTAL_NUMBER / INTEGER) # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: POSITIVE_NUMBER
      _failure(_expect23);
    }
    // <= !('-' SPACING) (OCTAL_NUMBER / INTEGER) # Choice
    if (_cacheable[80]) {
      _addToCache($$, pos, 80);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ParameterDeclarationAbstract() {
    // SENTENCE (NONTERMINAL)
    // ParameterDeclarationAbstract <- Metadata? TypeQualifiers? Type DeclaratorAbstract / Metadata? TypeQualifiers? Type
    var $$;          
    var pos = _cursor;             
    if(_cachePos[33] >= pos) {
      $$ = _getFromCache(33);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[33] = pos;
    }  
    // => Metadata? TypeQualifiers? Type DeclaratorAbstract / Metadata? TypeQualifiers? Type # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => Metadata? TypeQualifiers? Type DeclaratorAbstract # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => DeclaratorAbstract
            $$ = _parse_DeclaratorAbstract();
            // <= DeclaratorAbstract
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // DeclaratorAbstract
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Metadata? TypeQualifiers? Type DeclaratorAbstract # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new ParameterDeclaration(metadata: $1, qualifiers: $2, type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Metadata? TypeQualifiers? Type # Sequence
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? Type DeclaratorAbstract / Metadata? TypeQualifiers? Type # Choice
    if (_cacheable[33]) {
      _addToCache($$, pos, 33);
    }    
    return $$;
  }
  
  dynamic _parse_ParameterDeclarationNotAbstract() {
    // SENTENCE (NONTERMINAL)
    // ParameterDeclarationNotAbstract <- Metadata? TypeQualifiers? Type FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionPointerDeclarator / Metadata? TypeQualifiers? Type DeclaratorNotAbstract
    var $$;          
    var pos = _cursor;             
    if(_cachePos[19] >= pos) {
      $$ = _getFromCache(19);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[19] = pos;
    }  
    // => Metadata? TypeQualifiers? Type FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionPointerDeclarator / Metadata? TypeQualifiers? Type DeclaratorNotAbstract # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => Metadata? TypeQualifiers? Type FunctionDeclarator # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => FunctionDeclarator
            $$ = _parse_FunctionDeclarator();
            // <= FunctionDeclarator
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // FunctionDeclarator
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Metadata? TypeQualifiers? Type FunctionDeclarator # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type FunctionPointerDeclarator # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => FunctionPointerDeclarator
            $$ = _parse_FunctionPointerDeclarator();
            // <= FunctionPointerDeclarator
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // FunctionPointerDeclarator
              final $4 = seq[3];
              final $start = startPos1;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Metadata? TypeQualifiers? Type FunctionPointerDeclarator # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type DeclaratorNotAbstract # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing4 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing4;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing5 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing5;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => DeclaratorNotAbstract
            $$ = _parse_DeclaratorNotAbstract();
            // <= DeclaratorNotAbstract
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // DeclaratorNotAbstract
              final $4 = seq[3];
              final $start = startPos2;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= Metadata? TypeQualifiers? Type DeclaratorNotAbstract # Sequence
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? Type FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionPointerDeclarator / Metadata? TypeQualifiers? Type DeclaratorNotAbstract # Choice
    if (_cacheable[19]) {
      _addToCache($$, pos, 19);
    }    
    return $$;
  }
  
  dynamic _parse_PointerSpecifier() {
    // SENTENCE (NONTERMINAL)
    // PointerSpecifier <- ASTERISK Metadata? TypeQualifiers?
    var $$;
    // => ASTERISK Metadata? TypeQualifiers? # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => ASTERISK Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ASTERISK
          $$ = _parse_ASTERISK();
          // <= ASTERISK
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ASTERISK
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new PointerSpecifier(metadata: $2, qualifiers: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ASTERISK Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '*'
      _failure(_expect10);
    }
    // <= ASTERISK Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_PointerSpecifiers() {
    // SENTENCE (NONTERMINAL)
    // PointerSpecifiers <- PointerSpecifier+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[13] >= pos) {
      $$ = _getFromCache(13);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[13] = pos;
    }  
    // => PointerSpecifier+ # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => PointerSpecifier+
        var testing0;
        for (var first = true, reps; ;) {  
          // => PointerSpecifier  
          $$ = _parse_PointerSpecifier();  
          // <= PointerSpecifier  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= PointerSpecifier+
        if (success) {    
          // PointerSpecifier+
          final $1 = $$;
          final $start = startPos0;
          $$ = new PointerSpecifiers($1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '*'
      _failure(_expect10);
    }
    // <= PointerSpecifier+ # Choice
    if (_cacheable[13]) {
      _addToCache($$, pos, 13);
    }    
    return $$;
  }
  
  dynamic _parse_RESERVED_WORD() {
    // MORHEME
    // RESERVED_WORD <- ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT)
    var $$;
    // => ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT) # Choice
    switch (_getState(_transitions35)) {
      // [_] [a-g] [i] [l] [r-w]
      case 0:
        // => ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') # Choice
          switch (_getState(_transitions36)) {
            // [_]
            case 0:
              while (true) {
                var startPos1 = _startPos;
                _startPos = _cursor;
                // => '_Bool'
                $$ = _matchString(_strings1, '_Bool');
                // <= '_Bool'
                _startPos = startPos1;
                if (success) break;
                var startPos2 = _startPos;
                _startPos = _cursor;
                // => '_Complex'
                $$ = _matchString(_strings19, '_Complex');
                // <= '_Complex'
                _startPos = startPos2;
                if (success) break;
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => '_Imaginary'
                $$ = _matchString(_strings20, '_Imaginary');
                // <= '_Imaginary'
                _startPos = startPos3;
                break;
              }
              break;
            // [a]
            case 1:
              var startPos4 = _startPos;
              _startPos = _cursor;
              // => 'auto'
              $$ = _matchString(_strings21, 'auto');
              // <= 'auto'
              _startPos = startPos4;
              break;
            // [b]
            case 2:
              var startPos5 = _startPos;
              _startPos = _cursor;
              // => 'break'
              $$ = _matchString(_strings22, 'break');
              // <= 'break'
              _startPos = startPos5;
              break;
            // [c]
            case 3:
              while (true) {
                var startPos6 = _startPos;
                _startPos = _cursor;
                // => 'case'
                $$ = _matchString(_strings23, 'case');
                // <= 'case'
                _startPos = startPos6;
                if (success) break;
                var startPos7 = _startPos;
                _startPos = _cursor;
                // => 'char'
                $$ = _matchString(_strings2, 'char');
                // <= 'char'
                _startPos = startPos7;
                if (success) break;
                var startPos8 = _startPos;
                _startPos = _cursor;
                // => 'const'
                $$ = _matchString(_strings14, 'const');
                // <= 'const'
                _startPos = startPos8;
                if (success) break;
                var startPos9 = _startPos;
                _startPos = _cursor;
                // => 'continue'
                $$ = _matchString(_strings24, 'continue');
                // <= 'continue'
                _startPos = startPos9;
                break;
              }
              break;
            // [d]
            case 4:
              while (true) {
                var startPos10 = _startPos;
                _startPos = _cursor;
                // => 'default'
                $$ = _matchString(_strings25, 'default');
                // <= 'default'
                _startPos = startPos10;
                if (success) break;
                var startPos11 = _startPos;
                _startPos = _cursor;
                // => 'do'
                $$ = _matchString(_strings26, 'do');
                // <= 'do'
                _startPos = startPos11;
                if (success) break;
                var startPos12 = _startPos;
                _startPos = _cursor;
                // => 'double'
                $$ = _matchString(_strings3, 'double');
                // <= 'double'
                _startPos = startPos12;
                break;
              }
              break;
            // [e]
            case 5:
              while (true) {
                var startPos13 = _startPos;
                _startPos = _cursor;
                // => 'else'
                $$ = _matchString(_strings27, 'else');
                // <= 'else'
                _startPos = startPos13;
                if (success) break;
                var startPos14 = _startPos;
                _startPos = _cursor;
                // => 'enum'
                $$ = _matchString(_strings4, 'enum');
                // <= 'enum'
                _startPos = startPos14;
                if (success) break;
                var startPos15 = _startPos;
                _startPos = _cursor;
                // => 'extern'
                $$ = _matchString(_strings28, 'extern');
                // <= 'extern'
                _startPos = startPos15;
                break;
              }
              break;
            // [f]
            case 6:
              while (true) {
                var startPos16 = _startPos;
                _startPos = _cursor;
                // => 'float'
                $$ = _matchString(_strings5, 'float');
                // <= 'float'
                _startPos = startPos16;
                if (success) break;
                var startPos17 = _startPos;
                _startPos = _cursor;
                // => 'for'
                $$ = _matchString(_strings29, 'for');
                // <= 'for'
                _startPos = startPos17;
                break;
              }
              break;
            // [g]
            case 7:
              var startPos18 = _startPos;
              _startPos = _cursor;
              // => 'goto'
              $$ = _matchString(_strings30, 'goto');
              // <= 'goto'
              _startPos = startPos18;
              break;
            // [i]
            case 8:
              while (true) {
                var startPos19 = _startPos;
                _startPos = _cursor;
                // => 'if'
                $$ = _matchString(_strings31, 'if');
                // <= 'if'
                _startPos = startPos19;
                if (success) break;
                var startPos20 = _startPos;
                _startPos = _cursor;
                // => 'inline'
                $$ = _matchString(_strings32, 'inline');
                // <= 'inline'
                _startPos = startPos20;
                if (success) break;
                var startPos21 = _startPos;
                _startPos = _cursor;
                // => 'int'
                $$ = _matchString(_strings6, 'int');
                // <= 'int'
                _startPos = startPos21;
                break;
              }
              break;
            // [l]
            case 9:
              var startPos22 = _startPos;
              _startPos = _cursor;
              // => 'long'
              $$ = _matchString(_strings18, 'long');
              // <= 'long'
              _startPos = startPos22;
              break;
            // [r]
            case 10:
              while (true) {
                var startPos23 = _startPos;
                _startPos = _cursor;
                // => 'register'
                $$ = _matchString(_strings33, 'register');
                // <= 'register'
                _startPos = startPos23;
                if (success) break;
                var startPos24 = _startPos;
                _startPos = _cursor;
                // => 'restrict'
                $$ = _matchString(_strings34, 'restrict');
                // <= 'restrict'
                _startPos = startPos24;
                if (success) break;
                var startPos25 = _startPos;
                _startPos = _cursor;
                // => 'return'
                $$ = _matchString(_strings35, 'return');
                // <= 'return'
                _startPos = startPos25;
                break;
              }
              break;
            // [s]
            case 11:
              while (true) {
                var startPos26 = _startPos;
                _startPos = _cursor;
                // => 'short'
                $$ = _matchString(_strings7, 'short');
                // <= 'short'
                _startPos = startPos26;
                if (success) break;
                var startPos27 = _startPos;
                _startPos = _cursor;
                // => 'signed'
                $$ = _matchString(_strings36, 'signed');
                // <= 'signed'
                _startPos = startPos27;
                if (success) break;
                var startPos28 = _startPos;
                _startPos = _cursor;
                // => 'sizeof'
                $$ = _matchString(_strings37, 'sizeof');
                // <= 'sizeof'
                _startPos = startPos28;
                if (success) break;
                var startPos29 = _startPos;
                _startPos = _cursor;
                // => 'static'
                $$ = _matchString(_strings38, 'static');
                // <= 'static'
                _startPos = startPos29;
                if (success) break;
                var startPos30 = _startPos;
                _startPos = _cursor;
                // => 'struct'
                $$ = _matchString(_strings9, 'struct');
                // <= 'struct'
                _startPos = startPos30;
                if (success) break;
                var startPos31 = _startPos;
                _startPos = _cursor;
                // => 'switch'
                $$ = _matchString(_strings39, 'switch');
                // <= 'switch'
                _startPos = startPos31;
                break;
              }
              break;
            // [t]
            case 12:
              var startPos32 = _startPos;
              _startPos = _cursor;
              // => 'typedef'
              $$ = _matchString(_strings10, 'typedef');
              // <= 'typedef'
              _startPos = startPos32;
              break;
            // [u]
            case 13:
              while (true) {
                var startPos33 = _startPos;
                _startPos = _cursor;
                // => 'union'
                $$ = _matchString(_strings11, 'union');
                // <= 'union'
                _startPos = startPos33;
                if (success) break;
                var startPos34 = _startPos;
                _startPos = _cursor;
                // => 'unsigned'
                $$ = _matchString(_strings40, 'unsigned');
                // <= 'unsigned'
                _startPos = startPos34;
                break;
              }
              break;
            // [v]
            case 14:
              while (true) {
                var startPos35 = _startPos;
                _startPos = _cursor;
                // => 'void'
                $$ = _matchString(_strings12, 'void');
                // <= 'void'
                _startPos = startPos35;
                if (success) break;
                var startPos36 = _startPos;
                _startPos = _cursor;
                // => 'volatile'
                $$ = _matchString(_strings41, 'volatile');
                // <= 'volatile'
                _startPos = startPos36;
                break;
              }
              break;
            // [w]
            case 15:
              var startPos37 = _startPos;
              _startPos = _cursor;
              // => 'while'
              $$ = _matchString(_strings42, 'while');
              // <= 'while'
              _startPos = startPos37;
              break;
            // No matches
            // EOF
            case 16:
            case 17:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while, _Bool, _Complex, _Imaginary
            _failure(_expect56);
          }
          // <= ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') # Choice
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => !(IDENT_START / IDENT_CONT)
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => (IDENT_START / IDENT_CONT) # Choice
          switch (_getState(_transitions33)) {
            // [0-9]
            case 0:
              var startPos38 = _startPos;
              _startPos = _cursor;
              // => IDENT_CONT
              $$ = _parse_IDENT_CONT();
              // <= IDENT_CONT
              _startPos = startPos38;
              break;
            // [A-Z] [_] [a-z]
            case 1:
              while (true) {
                var startPos39 = _startPos;
                _startPos = _cursor;
                // => IDENT_START
                $$ = _parse_IDENT_START();
                // <= IDENT_START
                _startPos = startPos39;
                if (success) break;
                var startPos40 = _startPos;
                _startPos = _cursor;
                // => IDENT_CONT
                $$ = _parse_IDENT_CONT();
                // <= IDENT_CONT
                _startPos = startPos40;
                break;
              }
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (IDENT_START / IDENT_CONT) # Choice
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !(IDENT_START / IDENT_CONT)
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary')
            final $1 = seq[0];
            // !(IDENT_START / IDENT_CONT)
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT) # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while, _Bool, _Complex, _Imaginary
      _failure(_expect56);
    }
    // <= ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT) # Choice
    return $$;
  }
  
  dynamic _parse_SEMICOLON() {
    // LEXEME (TOKEN)
    // SEMICOLON <- ';' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[81] >= pos) {
      $$ = _getFromCache(81);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[81] = pos;
    }  
    _token = 25;    
    _tokenStart = _cursor;    
    // => ';' SPACING # Choice
    switch (_ch == 59 ? 0 : _ch == -1 ? 2 : 1) {
      // [;]
      case 0:
        // => ';' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ';'
          $$ = ';';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ';'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ';'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ';' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ';'
      _failure(_expect40);
    }
    // <= ';' SPACING # Choice
    if (_cacheable[81]) {
      _addToCache($$, pos, 81);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SHORT() {
    // LEXEME (TOKEN)
    // SHORT <- 'short' !IDENT_PART SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[82] >= pos) {
      $$ = _getFromCache(82);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[82] = pos;
    }  
    _token = 26;    
    _tokenStart = _cursor;    
    // => 'short' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'short' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'short'
          $$ = _matchString(_strings7, 'short');
          // <= 'short'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'short'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'short' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'short'
      _failure(_expect41);
    }
    // <= 'short' !IDENT_PART SPACING # Choice
    if (_cacheable[82]) {
      _addToCache($$, pos, 82);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SIGN() {
    // MORHEME
    // SIGN <- PLUS / MINUS
    var $$;
    // => PLUS / MINUS # Choice
    switch (_getState(_transitions37)) {
      // [+]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => PLUS
        $$ = _parse_PLUS();
        // <= PLUS
        _startPos = startPos0;
        break;
      // [-]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => MINUS
        $$ = _parse_MINUS();
        // <= MINUS
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: +, -
      _failure(_expect57);
    }
    // <= PLUS / MINUS # Choice
    return $$;
  }
  
  dynamic _parse_SIGNED() {
    // MORHEME
    // SIGNED <- 'signed' !IDENT_PART SPACING
    var $$;
    // => 'signed' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'signed' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'signed'
          $$ = _matchString(_strings36, 'signed');
          // <= 'signed'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'signed'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'signed' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: signed
      _failure(_expect58);
    }
    // <= 'signed' !IDENT_PART SPACING # Choice
    return $$;
  }
  
  dynamic _parse_SIGNEDNESS() {
    // LEXEME (TOKEN)
    // SIGNEDNESS <- SIGNED / UNSIGNED
    var $$;          
    var pos = _cursor;             
    if(_cachePos[83] >= pos) {
      $$ = _getFromCache(83);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[83] = pos;
    }  
    _token = 27;    
    _tokenStart = _cursor;    
    // => SIGNED / UNSIGNED # Choice
    switch (_getState(_transitions15)) {
      // [s]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => SIGNED
        $$ = _parse_SIGNED();
        // <= SIGNED
        _startPos = startPos0;
        break;
      // [u]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => UNSIGNED
        $$ = _parse_UNSIGNED();
        // <= UNSIGNED
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SIGNEDNESS
      _failure(_expect42);
    }
    // <= SIGNED / UNSIGNED # Choice
    if (_cacheable[83]) {
      _addToCache($$, pos, 83);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SIMPLE_ESCAPE_SEQUENCE() {
    // MORHEME
    // SIMPLE_ESCAPE_SEQUENCE <- [\\] ["'?\\a-bfnrtv]
    var $$;
    // => [\\] ["'?\\a-bfnrtv] # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        // => [\\] ["'?\\a-bfnrtv] # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => [\\]
          $$ = '\\';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= [\\]
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ["'?\\a-bfnrtv]
          $$ = _matchMapping(34, 118, _mapping3);
          // <= ["'?\\a-bfnrtv]
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // [\\]
            final $1 = seq[0];
            // ["'?\\a-bfnrtv]
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _escape($1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= [\\] ["'?\\a-bfnrtv] # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [\\] ["'?\\a-bfnrtv] # Choice
    return $$;
  }
  
  dynamic _parse_SPACE() {
    // MORHEME
    // SPACE <- [\t-\n\r ]
    var $$;
    // => [\t-\n\r ] # Choice
    switch (_getState(_transitions38)) {
      // [\t-\n] [\r] [ ]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\t-\n\r ]
        $$ = _matchMapping(9, 32, _mapping4);
        // <= [\t-\n\r ]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [\t-\n\r ] # Choice
    return $$;
  }
  
  dynamic _parse_SPACING() {
    // MORHEME
    // SPACING <- (SPACE / COMMENT)*
    var $$;
    // => (SPACE / COMMENT)* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (SPACE / COMMENT)*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => (SPACE / COMMENT) # Choice
          switch (_getState(_transitions39)) {
            // [\t-\n] [\r] [ ]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => SPACE
              $$ = _parse_SPACE();
              // <= SPACE
              _startPos = startPos1;
              break;
            // [/]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => COMMENT
              $$ = _parse_COMMENT();
              // <= COMMENT
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (SPACE / COMMENT) # Choice
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= (SPACE / COMMENT)*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= (SPACE / COMMENT)* # Choice
    return $$;
  }
  
  dynamic _parse_STRING() {
    // LEXEME (TOKEN)
    // STRING <- '"' STRING_CHAR_SEQUENCE? '"' / 'L"' STRING_CHAR_SEQUENCE? '"'
    var $$;
    _token = 28;  
    _tokenStart = _cursor;  
    // => '"' STRING_CHAR_SEQUENCE? '"' / 'L"' STRING_CHAR_SEQUENCE? '"' # Choice
    switch (_getState(_transitions28)) {
      // [\"]
      case 0:
        // => '"' STRING_CHAR_SEQUENCE? '"' # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '"'
          $$ = '\"';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '"'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => STRING_CHAR_SEQUENCE?
          var testing0 = _testing;
          _testing = _cursor;
          // => STRING_CHAR_SEQUENCE
          $$ = _parse_STRING_CHAR_SEQUENCE();
          // <= STRING_CHAR_SEQUENCE
          success = true; 
          _testing = testing0;
          // <= STRING_CHAR_SEQUENCE?
          if (!success) break;
          seq[1] = $$;
          // => '"'
          $$ = _matchChar(34, '\"');
          // <= '"'
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '"'
            final $1 = seq[0];
            // STRING_CHAR_SEQUENCE?
            final $2 = seq[1];
            // '"'
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2 == null ? "" : new String.fromCharCodes($2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '"' STRING_CHAR_SEQUENCE? '"' # Sequence
        break;
      // [L]
      case 1:
        // => 'L"' STRING_CHAR_SEQUENCE? '"' # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'L"'
          $$ = _matchString(_strings8, 'L\"');
          // <= 'L"'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => STRING_CHAR_SEQUENCE?
          var testing1 = _testing;
          _testing = _cursor;
          // => STRING_CHAR_SEQUENCE
          $$ = _parse_STRING_CHAR_SEQUENCE();
          // <= STRING_CHAR_SEQUENCE
          success = true; 
          _testing = testing1;
          // <= STRING_CHAR_SEQUENCE?
          if (!success) break;
          seq[1] = $$;
          // => '"'
          $$ = _matchChar(34, '\"');
          // <= '"'
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'L"'
            final $1 = seq[0];
            // STRING_CHAR_SEQUENCE?
            final $2 = seq[1];
            // '"'
            final $3 = seq[2];
            final $start = startPos1;
            $$ = $2 == null ? "" : new String.fromCharCodes($2);
          }
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= 'L"' STRING_CHAR_SEQUENCE? '"' # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: STRING
      _failure(_expect43);
    }
    // <= '"' STRING_CHAR_SEQUENCE? '"' / 'L"' STRING_CHAR_SEQUENCE? '"' # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_STRING_CHAR() {
    // MORHEME
    // STRING_CHAR <- ![\n\r"\\] . / ESCAPE_SEQUENCE
    var $$;
    // => ![\n\r"\\] . / ESCAPE_SEQUENCE # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        while (true) {
          // => ![\n\r"\\] . # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ![\n\r"\\]
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            // => [\n\r"\\]
            $$ = _matchMapping(10, 92, _mapping5);
            // <= [\n\r"\\]
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            // <= ![\n\r"\\]
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => .
            $$ = _matchAny();
            // <= .
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ![\n\r"\\]
              final $1 = seq[0];
              // .
              final $2 = seq[1];
              final $start = startPos0;
              $$ = $2.codeUnitAt(0);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= ![\n\r"\\] . # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => ESCAPE_SEQUENCE
          $$ = _parse_ESCAPE_SEQUENCE();
          // <= ESCAPE_SEQUENCE
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
      // EOF
      case 2:
        // => ![\n\r"\\] . # Sequence
        var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ![\n\r"\\]
          var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          // => [\n\r"\\]
          $$ = _matchMapping(10, 92, _mapping5);
          // <= [\n\r"\\]
          _ch = ch3;
          _cursor = pos3; 
          _testing = testing1;
          $$ = null;
          success = !success;
          // <= ![\n\r"\\]
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => .
          $$ = _matchAny();
          // <= .
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ![\n\r"\\]
            final $1 = seq[0];
            // .
            final $2 = seq[1];
            final $start = startPos2;
            $$ = $2.codeUnitAt(0);
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos2;
        // <= ![\n\r"\\] . # Sequence
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= ![\n\r"\\] . / ESCAPE_SEQUENCE # Choice
    return $$;
  }
  
  dynamic _parse_STRING_CHAR_SEQUENCE() {
    // MORHEME
    // STRING_CHAR_SEQUENCE <- STRING_CHAR+
    var $$;
    // => STRING_CHAR+ # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => STRING_CHAR+
        var testing0;
        for (var first = true, reps; ;) {  
          // => STRING_CHAR  
          $$ = _parse_STRING_CHAR();  
          // <= STRING_CHAR  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= STRING_CHAR+
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= STRING_CHAR+ # Choice
    return $$;
  }
  
  dynamic _parse_STRUCT() {
    // LEXEME (TOKEN)
    // STRUCT <- 'struct' !IDENT_PART SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[85] >= pos) {
      $$ = _getFromCache(85);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[85] = pos;
    }  
    _token = 29;    
    _tokenStart = _cursor;    
    // => 'struct' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'struct' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'struct'
          $$ = _matchString(_strings9, 'struct');
          // <= 'struct'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'struct'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'struct' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct'
      _failure(_expect44);
    }
    // <= 'struct' !IDENT_PART SPACING # Choice
    if (_cacheable[85]) {
      _addToCache($$, pos, 85);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_StructureDeclaration() {
    // SENTENCE (NONTERMINAL)
    // StructureDeclaration <- Metadata? TypeQualifiers? StructureType
    var $$;
    // => Metadata? TypeQualifiers? StructureType # Choice
    switch (_getState(_transitions22)) {
      // [_] [c] [s] [u-v]
      case 0:
        // => Metadata? TypeQualifiers? StructureType # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => StructureType
          $$ = _parse_StructureType();
          // <= StructureType
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // StructureType
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new StructureDeclaration(metadata: $1, qualifiers: $2, type: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? StructureType # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union'
      _failure(_expect18);
    }
    // <= Metadata? TypeQualifiers? StructureType # Choice
    return $$;
  }
  
  dynamic _parse_StructureMember() {
    // SENTENCE (NONTERMINAL)
    // StructureMember <- BitFieldParameterDeclaration SEMICOLON / ParameterDeclarationNotAbstract SEMICOLON / ParameterDeclarationAbstract SEMICOLON
    var $$;
    // => BitFieldParameterDeclaration SEMICOLON / ParameterDeclarationNotAbstract SEMICOLON / ParameterDeclarationAbstract SEMICOLON # Choice
    switch (_getState(_transitions16)) {
      // [A-Z] [a-b] [d-h] [j-k] [m-r] [t] [w-z]
      // EOF
      case 0:
      case 3:
        while (true) {
          // => ParameterDeclarationNotAbstract SEMICOLON # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ParameterDeclarationNotAbstract
            $$ = _parse_ParameterDeclarationNotAbstract();
            // <= ParameterDeclarationNotAbstract
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ParameterDeclarationNotAbstract
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos0;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= ParameterDeclarationNotAbstract SEMICOLON # Sequence
          if (success) break;
          // => ParameterDeclarationAbstract SEMICOLON # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ParameterDeclarationAbstract
            $$ = _parse_ParameterDeclarationAbstract();
            // <= ParameterDeclarationAbstract
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ParameterDeclarationAbstract
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos1;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= ParameterDeclarationAbstract SEMICOLON # Sequence
          break;
        }
        break;
      // [_] [c] [i] [l] [s] [u-v]
      case 1:
        while (true) {
          // => BitFieldParameterDeclaration SEMICOLON # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => BitFieldParameterDeclaration
            $$ = _parse_BitFieldParameterDeclaration();
            // <= BitFieldParameterDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // BitFieldParameterDeclaration
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos2;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= BitFieldParameterDeclaration SEMICOLON # Sequence
          if (success) break;
          // => ParameterDeclarationNotAbstract SEMICOLON # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ParameterDeclarationNotAbstract
            $$ = _parse_ParameterDeclarationNotAbstract();
            // <= ParameterDeclarationNotAbstract
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ParameterDeclarationNotAbstract
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos3;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos3;
          // <= ParameterDeclarationNotAbstract SEMICOLON # Sequence
          if (success) break;
          // => ParameterDeclarationAbstract SEMICOLON # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ParameterDeclarationAbstract
            $$ = _parse_ParameterDeclarationAbstract();
            // <= ParameterDeclarationAbstract
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ParameterDeclarationAbstract
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos4;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos4;
          // <= ParameterDeclarationAbstract SEMICOLON # Sequence
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'short', 'long', 'char', 'int', SIGNEDNESS, Identifier, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= BitFieldParameterDeclaration SEMICOLON / ParameterDeclarationNotAbstract SEMICOLON / ParameterDeclarationAbstract SEMICOLON # Choice
    return $$;
  }
  
  dynamic _parse_StructureMemberList() {
    // SENTENCE (NONTERMINAL)
    // StructureMemberList <- OPEN_BRACE StructureMember+ CLOSE_BRACE
    var $$;
    // => OPEN_BRACE StructureMember+ CLOSE_BRACE # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => OPEN_BRACE StructureMember+ CLOSE_BRACE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => OPEN_BRACE
          $$ = _parse_OPEN_BRACE();
          // <= OPEN_BRACE
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => StructureMember+
          var testing0;
          for (var first = true, reps; ;) {  
            // => StructureMember  
            $$ = _parse_StructureMember();  
            // <= StructureMember  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= StructureMember+
          if (!success) break;
          seq[1] = $$;
          // => CLOSE_BRACE
          $$ = _parse_CLOSE_BRACE();
          // <= CLOSE_BRACE
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // OPEN_BRACE
            final $1 = seq[0];
            // StructureMember+
            final $2 = seq[1];
            // CLOSE_BRACE
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= OPEN_BRACE StructureMember+ CLOSE_BRACE # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '{'
      _failure(_expect19);
    }
    // <= OPEN_BRACE StructureMember+ CLOSE_BRACE # Choice
    return $$;
  }
  
  dynamic _parse_StructureType() {
    // SENTENCE (NONTERMINAL)
    // StructureType <- StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? / StructureTypeSpecifierWithTag Metadata? TypeQualifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[26] >= pos) {
      $$ = _getFromCache(26);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[26] = pos;
    }  
    // => StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? / StructureTypeSpecifierWithTag Metadata? TypeQualifiers? # Choice
    switch (_getState(_transitions14)) {
      // [s] [u]
      case 0:
        while (true) {
          // => StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => StructureTypeSpecifier
            $$ = _parse_StructureTypeSpecifier();
            // <= StructureTypeSpecifier
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => StructureMemberList
            $$ = _parse_StructureMemberList();
            // <= StructureMemberList
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // StructureTypeSpecifier
              final $1 = seq[0];
              // StructureMemberList
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              // TypeQualifiers?
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new StructureTypeSpecification(metadata: $3, elaboratedType: $1, members: $2, qualifiers: $4);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? # Sequence
          if (success) break;
          // => StructureTypeSpecifierWithTag Metadata? TypeQualifiers? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => StructureTypeSpecifierWithTag
            $$ = _parse_StructureTypeSpecifierWithTag();
            // <= StructureTypeSpecifierWithTag
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            seq[1] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // StructureTypeSpecifierWithTag
              final $1 = seq[0];
              // Metadata?
              final $2 = seq[1];
              // TypeQualifiers?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new StructureTypeSpecification(metadata: $2, elaboratedType: $1, qualifiers: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= StructureTypeSpecifierWithTag Metadata? TypeQualifiers? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union'
      _failure(_expect18);
    }
    // <= StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? / StructureTypeSpecifierWithTag Metadata? TypeQualifiers? # Choice
    if (_cacheable[26]) {
      _addToCache($$, pos, 26);
    }    
    return $$;
  }
  
  dynamic _parse_StructureTypeSpecifier() {
    // SENTENCE (NONTERMINAL)
    // StructureTypeSpecifier <- (STRUCT / UNION) Metadata? Identifier?
    var $$;
    // => (STRUCT / UNION) Metadata? Identifier? # Choice
    switch (_getState(_transitions14)) {
      // [s] [u]
      case 0:
        // => (STRUCT / UNION) Metadata? Identifier? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (STRUCT / UNION) # Choice
          switch (_getState(_transitions15)) {
            // [s]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => STRUCT
              $$ = _parse_STRUCT();
              // <= STRUCT
              _startPos = startPos1;
              break;
            // [u]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => UNION
              $$ = _parse_UNION();
              // <= UNION
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'struct', 'union'
            _failure(_expect18);
          }
          // <= (STRUCT / UNION) # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => Identifier?
          var testing1 = _testing;
          _testing = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          success = true; 
          _testing = testing1;
          // <= Identifier?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // (STRUCT / UNION)
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // Identifier?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (STRUCT / UNION) Metadata? Identifier? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union'
      _failure(_expect18);
    }
    // <= (STRUCT / UNION) Metadata? Identifier? # Choice
    return $$;
  }
  
  dynamic _parse_StructureTypeSpecifierWithTag() {
    // SENTENCE (NONTERMINAL)
    // StructureTypeSpecifierWithTag <- (STRUCT / UNION) Metadata? Identifier
    var $$;
    // => (STRUCT / UNION) Metadata? Identifier # Choice
    switch (_getState(_transitions14)) {
      // [s] [u]
      case 0:
        // => (STRUCT / UNION) Metadata? Identifier # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (STRUCT / UNION) # Choice
          switch (_getState(_transitions15)) {
            // [s]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => STRUCT
              $$ = _parse_STRUCT();
              // <= STRUCT
              _startPos = startPos1;
              break;
            // [u]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => UNION
              $$ = _parse_UNION();
              // <= UNION
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'struct', 'union'
            _failure(_expect18);
          }
          // <= (STRUCT / UNION) # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // (STRUCT / UNION)
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // Identifier
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (STRUCT / UNION) Metadata? Identifier # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union'
      _failure(_expect18);
    }
    // <= (STRUCT / UNION) Metadata? Identifier # Choice
    return $$;
  }
  
  dynamic _parse_TYPEDEF() {
    // LEXEME (TOKEN)
    // TYPEDEF <- 'typedef' SPACING
    var $$;
    _token = 30;  
    _tokenStart = _cursor;  
    // => 'typedef' SPACING # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => 'typedef' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'typedef'
          $$ = _matchString(_strings10, 'typedef');
          // <= 'typedef'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'typedef'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'typedef' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'typedef'
      _failure(_expect25);
    }
    // <= 'typedef' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_Type() {
    // SENTENCE (NONTERMINAL)
    // Type <- DefinedType / IntegerType / FloatType / VoidType / BoolType / StructureType / EnumType
    var $$;          
    var pos = _cursor;             
    if(_cachePos[20] >= pos) {
      $$ = _getFromCache(20);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[20] = pos;
    }  
    // => DefinedType / IntegerType / FloatType / VoidType / BoolType / StructureType / EnumType # Choice
    switch (_getState(_transitions8)) {
      // [A-Z]
      // EOF
      case 0:
      case 4:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => DefinedType
        $$ = _parse_DefinedType();
        // <= DefinedType
        _startPos = startPos0;
        break;
      // [_]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => DefinedType
          $$ = _parse_DefinedType();
          // <= DefinedType
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => BoolType
          $$ = _parse_BoolType();
          // <= BoolType
          _startPos = startPos2;
          break;
        }
        break;
      // [a-z]
      case 2:
        while (true) {
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => DefinedType
          $$ = _parse_DefinedType();
          // <= DefinedType
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => IntegerType
          $$ = _parse_IntegerType();
          // <= IntegerType
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          // => FloatType
          $$ = _parse_FloatType();
          // <= FloatType
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          _startPos = _cursor;
          // => VoidType
          $$ = _parse_VoidType();
          // <= VoidType
          _startPos = startPos6;
          if (success) break;
          var startPos7 = _startPos;
          _startPos = _cursor;
          // => StructureType
          $$ = _parse_StructureType();
          // <= StructureType
          _startPos = startPos7;
          if (success) break;
          var startPos8 = _startPos;
          _startPos = _cursor;
          // => EnumType
          $$ = _parse_EnumType();
          // <= EnumType
          _startPos = startPos8;
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= DefinedType / IntegerType / FloatType / VoidType / BoolType / StructureType / EnumType # Choice
    if (_cacheable[20]) {
      _addToCache($$, pos, 20);
    }    
    return $$;
  }
  
  dynamic _parse_TypeDeclarator() {
    // SENTENCE (NONTERMINAL)
    // TypeDeclarator <- FunctionDeclarator / FunctionPointerDeclarator / DeclaratorNotAbstract / TypedefFunctionDeclarator
    var $$;          
    var pos = _cursor;             
    if(_cachePos[51] >= pos) {
      $$ = _getFromCache(51);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[51] = pos;
    }  
    // => FunctionDeclarator / FunctionPointerDeclarator / DeclaratorNotAbstract / TypedefFunctionDeclarator # Choice
    switch (_getState(_transitions26)) {
      // [(]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => FunctionPointerDeclarator
          $$ = _parse_FunctionPointerDeclarator();
          // <= FunctionPointerDeclarator
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => TypedefFunctionDeclarator
          $$ = _parse_TypedefFunctionDeclarator();
          // <= TypedefFunctionDeclarator
          _startPos = startPos1;
          break;
        }
        break;
      // [*]
      case 1:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => FunctionDeclarator
          $$ = _parse_FunctionDeclarator();
          // <= FunctionDeclarator
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => FunctionPointerDeclarator
          $$ = _parse_FunctionPointerDeclarator();
          // <= FunctionPointerDeclarator
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => DeclaratorNotAbstract
          $$ = _parse_DeclaratorNotAbstract();
          // <= DeclaratorNotAbstract
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          // => TypedefFunctionDeclarator
          $$ = _parse_TypedefFunctionDeclarator();
          // <= TypedefFunctionDeclarator
          _startPos = startPos5;
          break;
        }
        break;
      // [A-Z] [_] [a-z]
      // EOF
      case 2:
      case 4:
        while (true) {
          var startPos6 = _startPos;
          _startPos = _cursor;
          // => FunctionDeclarator
          $$ = _parse_FunctionDeclarator();
          // <= FunctionDeclarator
          _startPos = startPos6;
          if (success) break;
          var startPos7 = _startPos;
          _startPos = _cursor;
          // => DeclaratorNotAbstract
          $$ = _parse_DeclaratorNotAbstract();
          // <= DeclaratorNotAbstract
          _startPos = startPos7;
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, '('
      _failure(_expect26);
    }
    // <= FunctionDeclarator / FunctionPointerDeclarator / DeclaratorNotAbstract / TypedefFunctionDeclarator # Choice
    if (_cacheable[51]) {
      _addToCache($$, pos, 51);
    }    
    return $$;
  }
  
  dynamic _parse_TypeDeclaratorList() {
    // SENTENCE (NONTERMINAL)
    // TypeDeclaratorList <- TypeDeclarator (COMMA TypeDeclarator)*
    var $$;
    // => TypeDeclarator (COMMA TypeDeclarator)* # Choice
    switch (_getState(_transitions25)) {
      // [(] [*] [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => TypeDeclarator (COMMA TypeDeclarator)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => TypeDeclarator
          $$ = _parse_TypeDeclarator();
          // <= TypeDeclarator
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA TypeDeclarator)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA TypeDeclarator) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA TypeDeclarator # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => TypeDeclarator
                  $$ = _parse_TypeDeclarator();
                  // <= TypeDeclarator
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA TypeDeclarator # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect6);
            }
            // <= (COMMA TypeDeclarator) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA TypeDeclarator)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // TypeDeclarator
            final $1 = seq[0];
            // (COMMA TypeDeclarator)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TypeDeclarator (COMMA TypeDeclarator)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, '('
      _failure(_expect26);
    }
    // <= TypeDeclarator (COMMA TypeDeclarator)* # Choice
    return $$;
  }
  
  dynamic _parse_TypeQualifier() {
    // SENTENCE (NONTERMINAL)
    // TypeQualifier <- (Const / Volatile) Metadata?
    var $$;
    // => (Const / Volatile) Metadata? # Choice
    switch (_getState(_transitions5)) {
      // [c] [v]
      case 0:
        // => (Const / Volatile) Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (Const / Volatile) # Choice
          switch (_getState(_transitions6)) {
            // [c]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => Const
              $$ = _parse_Const();
              // <= Const
              _startPos = startPos1;
              break;
            // [v]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => Volatile
              $$ = _parse_Volatile();
              // <= Volatile
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'const', 'volatile'
            _failure(_expect8);
          }
          // <= (Const / Volatile) # Choice
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // (Const / Volatile)
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new TypeQualifier(identifier: $1, metadata: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (Const / Volatile) Metadata? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'const', 'volatile'
      _failure(_expect8);
    }
    // <= (Const / Volatile) Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_TypeQualifiers() {
    // SENTENCE (NONTERMINAL)
    // TypeQualifiers <- TypeQualifier+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[10] >= pos) {
      $$ = _getFromCache(10);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[10] = pos;
    }  
    // => TypeQualifier+ # Choice
    switch (_getState(_transitions5)) {
      // [c] [v]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => TypeQualifier+
        var testing0;
        for (var first = true, reps; ;) {  
          // => TypeQualifier  
          $$ = _parse_TypeQualifier();  
          // <= TypeQualifier  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= TypeQualifier+
        if (success) {    
          // TypeQualifier+
          final $1 = $$;
          final $start = startPos0;
          $$ = new TypeQualifiers($1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'const', 'volatile'
      _failure(_expect8);
    }
    // <= TypeQualifier+ # Choice
    if (_cacheable[10]) {
      _addToCache($$, pos, 10);
    }    
    return $$;
  }
  
  dynamic _parse_TypedefDeclaration() {
    // SENTENCE (NONTERMINAL)
    // TypedefDeclaration <- Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList
    var $$;
    // => Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList # Choice
    switch (_getState(_transitions24)) {
      // [_] [c] [t] [v]
      case 0:
        // => Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => TypedefSpecifier
          $$ = _parse_TypedefSpecifier();
          // <= TypedefSpecifier
          if (!success) break;
          seq[2] = $$;
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          seq[3] = $$;
          // => TypeDeclaratorList
          $$ = _parse_TypeDeclaratorList();
          // <= TypeDeclaratorList
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // TypedefSpecifier
            final $3 = seq[2];
            // Type
            final $4 = seq[3];
            // TypeDeclaratorList
            final $5 = seq[4];
            final $start = startPos0;
            $$ = new TypedefDeclaration(declarators: $5, metadata: $1, qualifiers: $2, type: $4, typedef: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'typedef'
      _failure(_expect25);
    }
    // <= Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList # Choice
    return $$;
  }
  
  dynamic _parse_TypedefFunctionDeclarator() {
    // SENTENCE (NONTERMINAL)
    // TypedefFunctionDeclarator <- PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN FunctionParameters Metadata?
    var $$;
    // => PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN FunctionParameters Metadata? # Choice
    switch (_getState(_transitions21)) {
      // [(] [*]
      case 0:
        // => PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN FunctionParameters Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing0;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(6)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[2] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[3] = $$;
          // => FunctionParameters
          $$ = _parse_FunctionParameters();
          // <= FunctionParameters
          if (!success) break;
          seq[4] = $$;
          // => Metadata?
          var testing1 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing1;
          // <= Metadata?
          if (!success) break;
          seq[5] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // Identifier
            final $3 = seq[2];
            // CLOSE_PAREN
            final $4 = seq[3];
            // FunctionParameters
            final $5 = seq[4];
            // Metadata?
            final $6 = seq[5];
            final $start = startPos0;
            $$ = new Declarator(identifier: $3, metadata: $6, parameters: $5, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN FunctionParameters Metadata? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect11);
    }
    // <= PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN FunctionParameters Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_TypedefSpecifier() {
    // SENTENCE (NONTERMINAL)
    // TypedefSpecifier <- TYPEDEF Metadata? TypeQualifiers?
    var $$;
    // => TYPEDEF Metadata? TypeQualifiers? # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => TYPEDEF Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => TYPEDEF
          $$ = _parse_TYPEDEF();
          // <= TYPEDEF
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // TYPEDEF
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new TypedefSpecifier(metadata: $2, qualifiers: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TYPEDEF Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'typedef'
      _failure(_expect25);
    }
    // <= TYPEDEF Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_UNION() {
    // LEXEME (TOKEN)
    // UNION <- 'union' !IDENT_PART SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[87] >= pos) {
      $$ = _getFromCache(87);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[87] = pos;
    }  
    _token = 31;    
    _tokenStart = _cursor;    
    // => 'union' !IDENT_PART SPACING # Choice
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      // [u]
      case 0:
        // => 'union' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'union'
          $$ = _matchString(_strings11, 'union');
          // <= 'union'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'union'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'union' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'union'
      _failure(_expect45);
    }
    // <= 'union' !IDENT_PART SPACING # Choice
    if (_cacheable[87]) {
      _addToCache($$, pos, 87);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_UNIVERSAL_CHARCTER_NAME() {
    // MORHEME
    // UNIVERSAL_CHARCTER_NAME <- '\\U' HEX_QUAD HEX_QUAD / '\\u' HEX_QUAD
    var $$;
    // => '\\U' HEX_QUAD HEX_QUAD / '\\u' HEX_QUAD # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          // => '\\U' HEX_QUAD HEX_QUAD # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\U'
            $$ = _matchString(_strings43, '\\U');
            // <= '\\U'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => HEX_QUAD
            $$ = _parse_HEX_QUAD();
            // <= HEX_QUAD
            if (!success) break;
            seq[1] = $$;
            // => HEX_QUAD
            $$ = _parse_HEX_QUAD();
            // <= HEX_QUAD
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // '\\U'
              final $1 = seq[0];
              // HEX_QUAD
              final $2 = seq[1];
              // HEX_QUAD
              final $3 = seq[2];
              final $start = startPos0;
              $$ = int.parse(_text(2), radix: 16);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '\\U' HEX_QUAD HEX_QUAD # Sequence
          if (success) break;
          // => '\\u' HEX_QUAD # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\u'
            $$ = _matchString(_strings44, '\\u');
            // <= '\\u'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => HEX_QUAD
            $$ = _parse_HEX_QUAD();
            // <= HEX_QUAD
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // '\\u'
              final $1 = seq[0];
              // HEX_QUAD
              final $2 = seq[1];
              final $start = startPos1;
              $$ = int.parse(_text(2), radix: 16);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '\\u' HEX_QUAD # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: \U, \u
      _failure(_expect59);
    }
    // <= '\\U' HEX_QUAD HEX_QUAD / '\\u' HEX_QUAD # Choice
    return $$;
  }
  
  dynamic _parse_UNSIGNED() {
    // MORHEME
    // UNSIGNED <- 'unsigned' !IDENT_PART SPACING
    var $$;
    // => 'unsigned' !IDENT_PART SPACING # Choice
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      // [u]
      case 0:
        // => 'unsigned' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'unsigned'
          $$ = _matchString(_strings40, 'unsigned');
          // <= 'unsigned'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'unsigned'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'unsigned' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: unsigned
      _failure(_expect60);
    }
    // <= 'unsigned' !IDENT_PART SPACING # Choice
    return $$;
  }
  
  dynamic _parse_VA_LIST_PARAMETER() {
    // LEXEME (TOKEN)
    // VA_LIST_PARAMETER <- VA_LIST_TYPE
    var $$;
    _token = 32;  
    _tokenStart = _cursor;  
    // => VA_LIST_TYPE # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => VA_LIST_TYPE
        $$ = _parse_VA_LIST_TYPE();
        // <= VA_LIST_TYPE
        if (success) {    
          // VA_LIST_TYPE
          final $1 = $$;
          final $start = startPos0;
          $$ = new ParameterDeclaration(type: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '...'
      _failure(_expect46);
    }
    // <= VA_LIST_TYPE # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_VA_LIST_TYPE() {
    // MORHEME
    // VA_LIST_TYPE <- ELLIPSIS
    var $$;
    // => ELLIPSIS # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => ELLIPSIS
        $$ = _parse_ELLIPSIS();
        // <= ELLIPSIS
        if (success) {    
          // ELLIPSIS
          final $1 = $$;
          final $start = startPos0;
          $$ = new VaListTypeSpecification();
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ...
      _failure(_expect51);
    }
    // <= ELLIPSIS # Choice
    return $$;
  }
  
  dynamic _parse_VOID() {
    // LEXEME (TOKEN)
    // VOID <- 'void' !IDENT_PART SPACING
    var $$;
    _token = 33;  
    _tokenStart = _cursor;  
    // => 'void' !IDENT_PART SPACING # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        // => 'void' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'void'
          $$ = _matchString(_strings12, 'void');
          // <= 'void'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'void'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'void' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'void'
      _failure(_expect16);
    }
    // <= 'void' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_VOLATILE() {
    // MORHEME
    // VOLATILE <- 'volatile' SPACING
    var $$;
    // => 'volatile' SPACING # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        // => 'volatile' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'volatile'
          $$ = _matchString(_strings41, 'volatile');
          // <= 'volatile'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'volatile'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'volatile' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: volatile
      _failure(_expect61);
    }
    // <= 'volatile' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_VariableDeclaration() {
    // SENTENCE (NONTERMINAL)
    // VariableDeclaration <- Metadata? TypeQualifiers? Type VariableDeclaratorList
    var $$;
    // => Metadata? TypeQualifiers? Type VariableDeclaratorList # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Metadata? TypeQualifiers? Type VariableDeclaratorList # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          seq[2] = $$;
          // => VariableDeclaratorList
          $$ = _parse_VariableDeclaratorList();
          // <= VariableDeclaratorList
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // Type
            final $3 = seq[2];
            // VariableDeclaratorList
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new VariableDeclaration(declarators: $4, metadata: $1, qualifiers: $2, type: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? Type VariableDeclaratorList # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier, 'short', 'long', 'char', 'int', SIGNEDNESS, 'float', 'double', 'void', '_Bool', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? Type VariableDeclaratorList # Choice
    return $$;
  }
  
  dynamic _parse_VariableDeclarator() {
    // SENTENCE (NONTERMINAL)
    // VariableDeclarator <- DeclaratorNotAbstract
    var $$;          
    var pos = _cursor;             
    if(_cachePos[55] >= pos) {
      $$ = _getFromCache(55);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[55] = pos;
    }  
    // => DeclaratorNotAbstract # Choice
    switch (_getState(_transitions7)) {
      // [*] [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => DeclaratorNotAbstract
        $$ = _parse_DeclaratorNotAbstract();
        // <= DeclaratorNotAbstract
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= DeclaratorNotAbstract # Choice
    if (_cacheable[55]) {
      _addToCache($$, pos, 55);
    }    
    return $$;
  }
  
  dynamic _parse_VariableDeclaratorList() {
    // SENTENCE (NONTERMINAL)
    // VariableDeclaratorList <- VariableDeclarator (COMMA VariableDeclarator)*
    var $$;
    // => VariableDeclarator (COMMA VariableDeclarator)* # Choice
    switch (_getState(_transitions7)) {
      // [*] [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => VariableDeclarator (COMMA VariableDeclarator)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => VariableDeclarator
          $$ = _parse_VariableDeclarator();
          // <= VariableDeclarator
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA VariableDeclarator)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA VariableDeclarator) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA VariableDeclarator # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => VariableDeclarator
                  $$ = _parse_VariableDeclarator();
                  // <= VariableDeclarator
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA VariableDeclarator # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect6);
            }
            // <= (COMMA VariableDeclarator) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA VariableDeclarator)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // VariableDeclarator
            final $1 = seq[0];
            // (COMMA VariableDeclarator)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= VariableDeclarator (COMMA VariableDeclarator)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Identifier
      _failure(_expect9);
    }
    // <= VariableDeclarator (COMMA VariableDeclarator)* # Choice
    return $$;
  }
  
  dynamic _parse_VoidType() {
    // SENTENCE (NONTERMINAL)
    // VoidType <- VOID Metadata? TypeQualifiers?
    var $$;
    // => VOID Metadata? TypeQualifiers? # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        // => VOID Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => VOID
          $$ = _parse_VOID();
          // <= VOID
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // VOID
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new BuiltinTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3, typeKind: TypeSpecificationKind.VOID);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= VOID Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'void'
      _failure(_expect16);
    }
    // <= VOID Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_Volatile() {
    // LEXEME (TOKEN)
    // Volatile <- VOLATILE
    var $$;
    _token = 34;  
    _tokenStart = _cursor;  
    // => VOLATILE # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => VOLATILE
        $$ = _parse_VOLATILE();
        // <= VOLATILE
        if (success) {    
          // VOLATILE
          final $1 = $$;
          final $start = startPos0;
          $$ = new Identifier(name: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'volatile'
      _failure(_expect47);
    }
    // <= VOLATILE # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ZERO() {
    // MORHEME
    // ZERO <- [0]+ ![0-9]+
    var $$;
    // => [0]+ ![0-9]+ # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => [0]+ ![0-9]+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => [0]+
          var testing0;
          for (var first = true, reps; ;) {  
            // => [0]  
            $$ = _matchChar(48, '0');  
            // <= [0]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0]+
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ![0-9]+
          var ch1 = _ch, pos1 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          // => [0-9]+
          var testing2;
          for (var first = true, reps; ;) {  
            // => [0-9]  
            $$ = _matchRange(48, 57);  
            // <= [0-9]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing2 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing2;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0-9]+
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing1;
          $$ = null;
          success = !success;
          // <= ![0-9]+
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // [0]+
            final $1 = seq[0];
            // ![0-9]+
            final $2 = seq[1];
            final $start = startPos0;
            $$ = 0;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= [0]+ ![0-9]+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [0]+ ![0-9]+ # Choice
    return $$;
  }
  
  dynamic _parse_ZERO_NUMBER() {
    // LEXEME (TOKEN)
    // ZERO_NUMBER <- ZERO SPACING
    var $$;
    _token = 35;  
    _tokenStart = _cursor;  
    // => ZERO SPACING # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => ZERO SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ZERO
          $$ = _parse_ZERO();
          // <= ZERO
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ZERO
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ZERO SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ZERO_NUMBER
      _failure(_expect48);
    }
    // <= ZERO SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  String _text([int offset = 0]) {
    return new String.fromCharCodes(_input.sublist(_startPos + offset, _cursor));
  }
  
  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }
  
    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }
  
    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }
  
    return start;
  }
  
  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }
  
    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }
  
    codePoints.length = pos;
    return codePoints;
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<CParserError> errors() {
    if (success) {
      return <CParserError>[];
    }
  
    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    } 
    
    String getc(int position) {  
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";      
      }       
      return "end of file";
    }
  
    var errors = <CParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<CParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();  
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new CParserError(CParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {      
        var found = getc(_failurePos);      
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new CParserError(CParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }        
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;  
  }
  
  dynamic parse_Declarations() {
    // SENTENCE (NONTERMINAL)
    // Declarations <- LEADING_SPACES? DeclarationList? EOF
    var $$;
    // => LEADING_SPACES? DeclarationList? EOF # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        // => LEADING_SPACES? DeclarationList? EOF # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => LEADING_SPACES?
          var testing0 = _testing;
          _testing = _cursor;
          // => LEADING_SPACES
          $$ = _parse_LEADING_SPACES();
          // <= LEADING_SPACES
          success = true; 
          _testing = testing0;
          // <= LEADING_SPACES?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => DeclarationList?
          var testing1 = _testing;
          _testing = _cursor;
          // => DeclarationList
          $$ = _parse_DeclarationList();
          // <= DeclarationList
          success = true; 
          _testing = testing1;
          // <= DeclarationList?
          if (!success) break;
          seq[1] = $$;
          // => EOF
          $$ = _parse_EOF();
          // <= EOF
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // LEADING_SPACES?
            final $1 = seq[0];
            // DeclarationList?
            final $2 = seq[1];
            // EOF
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= LEADING_SPACES? DeclarationList? EOF # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= LEADING_SPACES? DeclarationList? EOF # Choice
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }      
    _cursor = pos;
    _cache = new List<Map<int, List>>(126);
    _cachePos = new List<int>.filled(126, -1);  
    _cacheable = new List<bool>.filled(126, false);
    _ch = -1;
    _errors = <CParserError>[];   
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;        
    _testing = -1;
    _token = null;
    _tokenStart = null;  
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;    
  }
  
}

class CParserError {
  static const int EXPECTED = 1;    
      
  static const int MALFORMED = 2;    
      
  static const int MISSING = 3;    
      
  static const int UNEXPECTED = 4;    
      
  static const int UNTERMINATED = 5;    
      
  final int hashCode = 0;
  
  final String message;
  
  final int position;
  
  final int start;
  
  final int type;
  
  CParserError(this.type, this.position, this.start, this.message);
  
  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is CParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;  
    }
    return false;
  }
  
}

