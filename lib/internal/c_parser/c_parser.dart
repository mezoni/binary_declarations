// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

import "package:binary_declarations/binary_declarations.dart";

ArrayTypeSpecification _createArray(TypeSpecification type, List dimensions) {
  return new ArrayTypeSpecification(dimensions: dimensions, type: type);
}

String _createInt(List parts) {
  var list = [];
  for (var part in parts) {
    if (part != null) {
      list.add(part);
    }
  }

  return list.join(" ");
}

List _createParameters(List parameters, ParameterDeclaration vaList) {
  var list = <ParameterDeclaration>[];
  list.addAll(parameters);
  if (vaList != null) {
    list.add(vaList);
  }

  return list;
}

PointerTypeSpecification _createPointer(TypeSpecification type, List stars) {
  for (var star in stars) {
    type = new PointerTypeSpecification(type: type);
  }

  return type;
}
class CParser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));

  static final List<String> _expect0 = <String>["EOF"];

  static final List<String> _expect1 = <String>[];

  static final List<String> _expect10 = <String>["\'}\'"];

  static final List<String> _expect11 = <String>["\'enum\'"];

  static final List<String> _expect12 = <String>["FunctionDeclartion"];

  static final List<String> _expect13 = <String>["IDENTIFIER"];

  static final List<String> _expect14 = <String>["\'struct\'"];

  static final List<String> _expect15 = <String>["\'union\'"];

  static final List<String> _expect16 = <String>["\'{\'"];

  static final List<String> _expect17 = <String>["PointerVariableDeclaration"];

  static final List<String> _expect18 = <String>["\';\'"];

  static final List<String> _expect19 = <String>["SPACING"];

  static final List<String> _expect2 = <String>["\';\'", "\'enum\'", "\'struct\'", "\'typedef\'", "\'union\'", "ArrayVariableDeclaration", "FunctionDeclartion", "PointerVariableDeclaration", "SimpleVariableDeclaration"];

  static final List<String> _expect20 = <String>["\'//\'", "SPACE"];

  static final List<String> _expect21 = <String>["SimpleVariableDeclaration"];

  static final List<String> _expect22 = <String>["TypedefArrayTypeDeclaration"];

  static final List<String> _expect23 = <String>["TypedefSimpleTypeDeclaration"];

  static final List<String> _expect24 = <String>["\'=\'"];

  static final List<String> _expect25 = <String>["\'*\'"];

  static final List<String> _expect26 = <String>["ArrayParameter"];

  static final List<String> _expect27 = <String>["ArrayType"];

  static final List<String> _expect28 = <String>["Attribute"];

  static final List<String> _expect29 = <String>["AttributeList"];

  static final List<String> _expect3 = <String>["\'typedef\'"];

  static final List<String> _expect30 = <String>["\',\'"];

  static final List<String> _expect31 = <String>["AttributeParameter"];

  static final List<String> _expect32 = <String>["AttributeParameterList"];

  static final List<String> _expect33 = <String>["\']\'"];

  static final List<String> _expect34 = <String>["\')\'"];

  static final List<String> _expect35 = <String>["\'//\'"];

  static final List<String> _expect36 = <String>[null];

  static final List<String> _expect37 = <String>["EOF", "EOL"];

  static final List<String> _expect38 = <String>["\'const\'"];

  static final List<String> _expect39 = <String>["ConstPointerParameter"];

  static final List<String> _expect4 = <String>["\'enum\'", "\'struct\'", "\'union\'", "TypedefArrayTypeDeclaration", "TypedefSimpleTypeDeclaration"];

  static final List<String> _expect40 = <String>["\'[\'"];

  static final List<String> _expect41 = <String>["Dimension"];

  static final List<String> _expect42 = <String>["INTEGER", "OCTAL_NUMBER"];

  static final List<String> _expect43 = <String>["\'...\'"];

  static final List<String> _expect44 = <String>["EOL"];

  static final List<String> _expect45 = <String>["EnumValue"];

  static final List<String> _expect46 = <String>["EnumValueList"];

  static final List<String> _expect47 = <String>["FunctionParameter"];

  static final List<String> _expect48 = <String>["FunctionParameterList"];

  static final List<String> _expect49 = <String>["FunctionParameters"];

  static final List<String> _expect5 = <String>["\'enum\'", "\'struct\'", "\'union\'"];

  static final List<String> _expect50 = <String>["IDENT"];

  static final List<String> _expect51 = <String>["IDENT_CONT"];

  static final List<String> _expect52 = <String>["IDENT_PART"];

  static final List<String> _expect53 = <String>["IDENT_START"];

  static final List<String> _expect54 = <String>["\'char\'"];

  static final List<String> _expect55 = <String>["\'double\'"];

  static final List<String> _expect56 = <String>["\'float\'"];

  static final List<String> _expect57 = <String>["\'int\'"];

  static final List<String> _expect58 = <String>["\'long\'"];

  static final List<String> _expect59 = <String>["\'short\'"];

  static final List<String> _expect6 = <String>["\'struct\'", "\'union\'"];

  static final List<String> _expect60 = <String>["\'signed\'"];

  static final List<String> _expect61 = <String>["\'unsigned\'"];

  static final List<String> _expect62 = <String>["\'void\'"];

  static final List<String> _expect63 = <String>["INTEGER"];

  static final List<String> _expect64 = <String>["\'-\'"];

  static final List<String> _expect65 = <String>["NUMBER"];

  static final List<String> _expect66 = <String>["OCTAL_NUMBER"];

  static final List<String> _expect67 = <String>["\'(\'"];

  static final List<String> _expect68 = <String>["\'+\'"];

  static final List<String> _expect69 = <String>["PointerParameter"];

  static final List<String> _expect7 = <String>["\'enum\'", "\'struct\'", "\'union\'", "ArrayVariableDeclaration", "PointerVariableDeclaration", "SimpleVariableDeclaration"];

  static final List<String> _expect70 = <String>["PointerType"];

  static final List<String> _expect71 = <String>["ReservedWord"];

  static final List<String> _expect72 = <String>["char", "double", "enum", "float", "int", "long", "short", "signed", "struct", "typedef", "union", "unsigned", "void"];

  static final List<String> _expect73 = <String>["IDENT_CONT", "IDENT_START"];

  static final List<String> _expect74 = <String>["SIGN"];

  static final List<String> _expect75 = <String>["\'+\'", "\'-\'"];

  static final List<String> _expect76 = <String>["SPACE"];

  static final List<String> _expect77 = <String>["SimpleParameter"];

  static final List<String> _expect78 = <String>["Type"];

  static final List<String> _expect79 = <String>["TypeName"];

  static final List<String> _expect8 = <String>["ArrayVariableDeclaration"];

  static final List<String> _expect80 = <String>["\'char\'", "\'int\'"];

  static final List<String> _expect81 = <String>["\'long\'", "\'short\'"];

  static final List<String> _expect82 = <String>["TypeSign"];

  static final List<String> _expect83 = <String>["ZERO"];

  static final List<String> _expect9 = <String>["\'__attribute__\'"];

  static final List<bool> _lookahead = _unmap([0x7ffe03ff, 0x7ffd0fff, 0x7ff83fff, 0x7ff43fff, 0x9ffff, 0x50004180, 0xf024f]);

  // '\n', '\r'
  static final List<bool> _mapping0 = _unmap([0x9]);

  // 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  static final List<bool> _mapping1 = _unmap([0x43ffffff, 0x7fffffe]);

  // '\t', '\n', '\r', ' '
  static final List<bool> _mapping2 = _unmap([0x800013]);

  // 'struct'
  static final List<int> _strings0 = <int>[115, 116, 114, 117, 99, 116];

  // 'union'
  static final List<int> _strings1 = <int>[117, 110, 105, 111, 110];

  // 'enum'
  static final List<int> _strings10 = <int>[101, 110, 117, 109];

  // 'float'
  static final List<int> _strings11 = <int>[102, 108, 111, 97, 116];

  // 'int'
  static final List<int> _strings12 = <int>[105, 110, 116];

  // 'long'
  static final List<int> _strings13 = <int>[108, 111, 110, 103];

  // 'short'
  static final List<int> _strings14 = <int>[115, 104, 111, 114, 116];

  // 'signed'
  static final List<int> _strings15 = <int>[115, 105, 103, 110, 101, 100];

  // 'unsigned'
  static final List<int> _strings16 = <int>[117, 110, 115, 105, 103, 110, 101, 100];

  // 'void'
  static final List<int> _strings17 = <int>[118, 111, 105, 100];

  // 'typedef'
  static final List<int> _strings2 = <int>[116, 121, 112, 101, 100, 101, 102];

  // '__attribute__'
  static final List<int> _strings3 = <int>[95, 95, 97, 116, 116, 114, 105, 98, 117, 116, 101, 95, 95];

  // '//'
  static final List<int> _strings4 = <int>[47, 47];

  // 'const'
  static final List<int> _strings5 = <int>[99, 111, 110, 115, 116];

  // '...'
  static final List<int> _strings6 = <int>[46, 46, 46];

  // '\r\n'
  static final List<int> _strings7 = <int>[13, 10];

  // 'char'
  static final List<int> _strings8 = <int>[99, 104, 97, 114];

  // 'double'
  static final List<int> _strings9 = <int>[100, 111, 117, 98, 108, 101];

  final List<int> _tokenFlags = [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1];

  final List<String> _tokenNames = ["\'__attribute__\'", "\'}\'", "EOF", "IDENTIFIER", "\'struct\'", "\'union\'", "\'{\'", "SPACING", "\'=\'", "\'*\'", "\'__attribute__\'", "ArrayParameter", "ArrayType", "Attribute", "AttributeList", "AttributeParameter", "AttributeParameterList", "\']\'", "\')\'", "\',\'", "\'//\'", "\'const\'", "ConstPointerParameter", "\'[\'", "\'[\'", "Dimension", "\'...\'", "EOL", "EnumValue", "EnumValueList", "FunctionParameter", "FunctionParameterList", "FunctionParameters", "IDENT", "IDENT_CONT", "IDENT_PART", "IDENT_START", "\'char\'", "\'double\'", "\'enum\'", "\'float\'", "\'int\'", "\'long\'", "\'short\'", "\'signed\'", "\'unsigned\'", "\'void\'", "INTEGER", "\'long\'", "\'-\'", "NUMBER", "OCTAL_NUMBER", "\'[\'", "\'(\'", "\'+\'", "PointerParameter", "PointerType", "ReservedWord", "SIGN", "SPACE", "SimpleParameter", "Type", "TypeName", "TypeSign", "\'...\'", "ZERO"];

  static final List<List<int>> _transitions0 = [[59, 59], [65, 90, 95, 95], [97, 122]];

  static final List<List<int>> _transitions1 = [[65, 90], [95, 95, 97, 122]];

  static final List<List<int>> _transitions10 = [[0, 64, 91, 94, 96, 96, 123, 1114111], [65, 90, 95, 95, 97, 122]];

  static final List<List<int>> _transitions11 = [[0, 9, 11, 12, 14, 1114111], [10, 10, 13, 13]];

  static final List<List<int>> _transitions12 = [[10, 10], [13, 13]];

  static final List<List<int>> _transitions13 = [[48, 57], [65, 90, 95, 95, 97, 122]];

  static final List<List<int>> _transitions14 = [[99, 102, 105, 105, 108, 108, 115, 118]];

  static final List<List<int>> _transitions15 = [[99, 99], [100, 100], [101, 101], [102, 102], [105, 105], [108, 108], [115, 115], [116, 116], [117, 117], [118, 118]];

  static final List<List<int>> _transitions16 = [[43, 43], [45, 45]];

  static final List<List<int>> _transitions17 = [[9, 10, 13, 13, 32, 32]];

  static final List<List<int>> _transitions18 = [[99, 99], [105, 105]];

  static final List<List<int>> _transitions19 = [[108, 108], [115, 115]];

  static final List<List<int>> _transitions2 = [[95, 95, 101, 101, 115, 115, 117, 117]];

  static final List<List<int>> _transitions3 = [[101, 101], [115, 115, 117, 117]];

  static final List<List<int>> _transitions4 = [[115, 115, 117, 117]];

  static final List<List<int>> _transitions5 = [[115, 115], [117, 117]];

  static final List<List<int>> _transitions6 = [[65, 90, 95, 95, 97, 122]];

  static final List<List<int>> _transitions7 = [[65, 90, 95, 95], [97, 122]];

  static final List<List<int>> _transitions8 = [[101, 101, 115, 115, 117, 117]];

  static final List<List<int>> _transitions9 = [[9, 10, 13, 13, 32, 32], [47, 47]];

  List _cache;

  int _cachePos;

  List<int> _cacheRule;

  List<int> _cacheState;

  int _ch;

  int _cursor;

  List<CParserError> _errors;

  List<String> _expected;

  int _failurePos;

  List<int> _input;

  int _inputLen;

  int _startPos;

  int _testing;

  int _token;

  int _tokenLevel;

  int _tokenStart;

  bool success;

  final String text;

  CParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }
    _input = _toCodePoints(text);
    _inputLen = _input.length;
    if (_inputLen >= 0x3fffffe8 / 32) {
      throw new StateError('File size to big: $_inputLen');
    }
    reset(0);
  }

  void _addToCache(dynamic result, int start, int id) {
    var cached = _cache[start];
    if (cached == null) {
      _cacheRule[start] = id;
      _cache[start] = [result, _cursor, success];
    } else {
      var slot = start >> 5;
      var r1 = (slot << 5) & 0x3fffffff;
      var mask = 1 << (start - r1);
      if ((_cacheState[slot] & mask) == 0) {
        _cacheState[slot] |= mask;
        cached = [new List.filled(4, 0), new Map<int, List>()];
        _cache[start] = cached;
      }
      slot = id >> 5;
      r1 = (slot << 5) & 0x3fffffff;
      mask = 1 << (id - r1);
      cached[0][slot] |= mask;
      cached[1][id] = [result, _cursor, success];
    }
    if (_cachePos < start) {
      _cachePos = start;
    }
  }

  void _beginToken(int tokenId) {
    if (_tokenLevel++ == 0) {
      _token = tokenId;
      _tokenStart = _cursor;
    }
  }

  void _endToken() {
    if (--_tokenLevel == 0) {
      _token = null;
      _tokenStart = null;
    }
  }

  void _failure([List<String> expected]) {
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos == _inputLen && (flag & 1) != 0) {
        var message = "Unterminated $name";
        _errors.add(new CParserError(CParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {
        var message = "Malformed $name";
        _errors.add(new CParserError(CParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);
      } else {
        _expected.add(name);
      }
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }
  }

  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }

  dynamic _getFromCache(int id) {
    var result = _cache[_cursor];
    if (result == null) {
      return null;
    }
    var slot = _cursor >> 5;
    var r1 = (slot << 5) & 0x3fffffff;
    var mask = 1 << (_cursor - r1);
    if ((_cacheState[slot] & mask) == 0) {
      if (_cacheRule[_cursor] == id) {
        _cursor = result[1];
        success = result[2];
        if (_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }
        return result;
      } else {
        return null;
      }
    }
    slot = id >> 5;
    r1 = (slot << 5) & 0x3fffffff;
    mask = 1 << (id - r1);
    if ((result[0][slot] & mask) == 0) {
      return null;
    }
    var data = result[1][id];
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }
    return data;
  }

  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state;
      }
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;
  }

  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }

  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];
      } else {
        result = new String.fromCharCode(_ch);
      }
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }
      return result;
    }
    return null;
  }

  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }
      return result;
    }
    return null;
  }

  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];
        } else {
          result = new String.fromCharCode(_ch);
        }
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }
        return result;
      }
      success = false;
    }
    return null;
  }

  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];
      } else {
        result = new String.fromCharCode(_ch);
      }
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }
      return result;
    }
    return null;
  }

  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];
          } else {
            result = new String.fromCharCode(_ch);
          }
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;
          return result;
        }
      } else break;
    }
    success = false;
    return null;
  }

  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }
    if (success) {
      _cursor += length;
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }
      return string;
    }
    return null;
  }

  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }
  }

  dynamic _parse_ASSIGN() {
    // MORPHEME
    // ASSIGN <- '=' SPACING
    var $$;
    _beginToken(8);
    // => '=' SPACING # Choice
    switch (_ch == 61 ? 0 : _ch == -1 ? 2 : 1) {
      // [=]
      case 0:
        // => '=' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '='
          $$ = '=';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '='
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '=' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '='
      _failure(_expect24);
    }
    // <= '=' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ASTERISK() {
    // MORPHEME
    // ASTERISK <- '*' SPACING
    var $$;
    _beginToken(9);
    // => '*' SPACING # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => '*' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '*'
          $$ = '*';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '*'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '*'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '*' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '*'
      _failure(_expect25);
    }
    // <= '*' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ATTRIBUTE() {
    // MORPHEME
    // ATTRIBUTE <- '__attribute__' SPACING
    var $$;
    _beginToken(10);
    // => '__attribute__' SPACING # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => '__attribute__' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '__attribute__'
          $$ = _matchString(_strings3, '__attribute__');
          // <= '__attribute__'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '__attribute__'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '__attribute__' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '__attribute__'
      _failure(_expect9);
    }
    // <= '__attribute__' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ArrayParameter() {
    // MORPHEME
    // ArrayParameter <- Type IDENTIFIER? DIMENSIONS
    var $$;
    _beginToken(11);
    // => Type IDENTIFIER? DIMENSIONS # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER? DIMENSIONS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true;
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          // => DIMENSIONS
          $$ = _parse_DIMENSIONS();
          // <= DIMENSIONS
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // Type
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            // DIMENSIONS
            final $3 = seq[2];
            $$ = new ParameterDeclaration(name: $2, type: _createArray($1, $3));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER? DIMENSIONS # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ArrayParameter
      _failure(_expect26);
    }
    // <= Type IDENTIFIER? DIMENSIONS # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ArrayType() {
    // MORPHEME
    // ArrayType <- TypeName DIMENSIONS
    var $$;
    _beginToken(12);
    // => TypeName DIMENSIONS # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => TypeName DIMENSIONS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => TypeName
          $$ = _parse_TypeName();
          // <= TypeName
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => DIMENSIONS
          $$ = _parse_DIMENSIONS();
          // <= DIMENSIONS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // TypeName
            final $1 = seq[0];
            // DIMENSIONS
            final $2 = seq[1];
            $$ = _createArray($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TypeName DIMENSIONS # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ArrayType
      _failure(_expect27);
    }
    // <= TypeName DIMENSIONS # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ArrayVariableDeclaration() {
    // LEXEME
    // ArrayVariableDeclaration <- Type IDENTIFIER DIMENSIONS
    var $$;
    // => Type IDENTIFIER DIMENSIONS # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER DIMENSIONS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => DIMENSIONS
          $$ = _parse_DIMENSIONS();
          // <= DIMENSIONS
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // Type
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // DIMENSIONS
            final $3 = seq[2];
            $$ = new VariableDeclaration(name: $2, type: _createArray($1, $3));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER DIMENSIONS # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ArrayVariableDeclaration
      _failure(_expect8);
    }
    // <= Type IDENTIFIER DIMENSIONS # Choice
    return $$;
  }

  dynamic _parse_Attribute() {
    // MORPHEME
    // Attribute <- IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN / IDENT
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(34);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(13);
    // => IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN / IDENT # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      case 0:
        while (true) {
          // => IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => IDENT
            $$ = _parse_IDENT();
            // <= IDENT
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => OPEN_PAREN
            $$ = _parse_OPEN_PAREN();
            // <= OPEN_PAREN
            if (!success) break;
            seq[1] = $$;
            // => AttributeParameterList?
            var testing0 = _testing;
            _testing = _cursor;
            // => AttributeParameterList
            $$ = _parse_AttributeParameterList();
            // <= AttributeParameterList
            success = true;
            _testing = testing0;
            // <= AttributeParameterList?
            if (!success) break;
            seq[2] = $$;
            // => CLOSE_PAREN
            $$ = _parse_CLOSE_PAREN();
            // <= CLOSE_PAREN
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {
              // IDENT
              final $1 = seq[0];
              // OPEN_PAREN
              final $2 = seq[1];
              // AttributeParameterList?
              final $3 = seq[2];
              // CLOSE_PAREN
              final $4 = seq[3];
              $$ = new BinaryAttribute($1, $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN # Sequence
          if (success) break;
          var startPos1 = _startPos;
          // => IDENT
          $$ = _parse_IDENT();
          // <= IDENT
          if (success) {
            // IDENT
            final $1 = $$;
            $$ = new BinaryAttribute($1);
          }
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Attribute
      _failure(_expect28);
    }
    // <= IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN / IDENT # Choice
    _addToCache($$, pos, 34);
    _endToken();
    return $$;
  }

  dynamic _parse_AttributeList() {
    // MORPHEME
    // AttributeList <- Attribute (COMMA Attribute)*
    var $$;
    _beginToken(14);
    // => Attribute (COMMA Attribute)* # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      case 0:
        // => Attribute (COMMA Attribute)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => Attribute
          $$ = _parse_Attribute();
          // <= Attribute
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA Attribute)*
          var testing0 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA Attribute) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA Attribute # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => Attribute
                  $$ = _parse_Attribute();
                  // <= Attribute
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA Attribute # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect30);
            }
            // <= (COMMA Attribute) # Choice
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break;
            }
          }
          // <= (COMMA Attribute)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // Attribute
            final $1 = seq[0];
            // (COMMA Attribute)*
            final $2 = seq[1];
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Attribute (COMMA Attribute)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: AttributeList
      _failure(_expect29);
    }
    // <= Attribute (COMMA Attribute)* # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_AttributeParameter() {
    // MORPHEME
    // AttributeParameter <- IDENT / NUMBER
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(36);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(15);
    // => IDENT / NUMBER # Choice
    switch (_getState(_transitions10)) {
      // [\u0000-@] [[-^] [`] [{-\u0010ffff]
      case 0:
        var startPos0 = _startPos;
        // => NUMBER
        $$ = _parse_NUMBER();
        // <= NUMBER
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          // => IDENT
          $$ = _parse_IDENT();
          // <= IDENT
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => NUMBER
          $$ = _parse_NUMBER();
          // <= NUMBER
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: AttributeParameter
      _failure(_expect31);
    }
    // <= IDENT / NUMBER # Choice
    _addToCache($$, pos, 36);
    _endToken();
    return $$;
  }

  dynamic _parse_AttributeParameterList() {
    // MORPHEME
    // AttributeParameterList <- AttributeParameter (COMMA AttributeParameter)*
    var $$;
    _beginToken(16);
    // => AttributeParameter (COMMA AttributeParameter)* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        // => AttributeParameter (COMMA AttributeParameter)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => AttributeParameter
          $$ = _parse_AttributeParameter();
          // <= AttributeParameter
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA AttributeParameter)*
          var testing0 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA AttributeParameter) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA AttributeParameter # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => AttributeParameter
                  $$ = _parse_AttributeParameter();
                  // <= AttributeParameter
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA AttributeParameter # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect30);
            }
            // <= (COMMA AttributeParameter) # Choice
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break;
            }
          }
          // <= (COMMA AttributeParameter)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // AttributeParameter
            final $1 = seq[0];
            // (COMMA AttributeParameter)*
            final $2 = seq[1];
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= AttributeParameter (COMMA AttributeParameter)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: AttributeParameterList
      _failure(_expect32);
    }
    // <= AttributeParameter (COMMA AttributeParameter)* # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_Attributes() {
    // LEXEME & MORPHEME
    // Attributes <- ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(13);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(0);
    // => ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => ATTRIBUTE
          $$ = _parse_ATTRIBUTE();
          // <= ATTRIBUTE
          if (!success) break;
          var seq = new List(6)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[2] = $$;
          // => AttributeList?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeList
          $$ = _parse_AttributeList();
          // <= AttributeList
          success = true;
          _testing = testing0;
          // <= AttributeList?
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[4] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[5] = $$;
          $$ = seq;
          if (success) {
            // ATTRIBUTE
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // OPEN_PAREN
            final $3 = seq[2];
            // AttributeList?
            final $4 = seq[3];
            // CLOSE_PAREN
            final $5 = seq[4];
            // CLOSE_PAREN
            final $6 = seq[5];
            $$ = new BinaryAttributes($4);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '__attribute__'
      _failure(_expect9);
    }
    // <= ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN # Choice
    _addToCache($$, pos, 13);
    _endToken();
    return $$;
  }

  dynamic _parse_CLOSE_BRACE() {
    // LEXEME & MORPHEME
    // CLOSE_BRACE <- '}' SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(14);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(1);
    // => '}' SPACING # Choice
    switch (_ch == 125 ? 0 : _ch == -1 ? 2 : 1) {
      // [}]
      case 0:
        // => '}' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '}'
          $$ = '}';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '}'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '}'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '}' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '}'
      _failure(_expect10);
    }
    // <= '}' SPACING # Choice
    _addToCache($$, pos, 14);
    _endToken();
    return $$;
  }

  dynamic _parse_CLOSE_BRACKET() {
    // MORPHEME
    // CLOSE_BRACKET <- ']' SPACING
    var $$;
    _beginToken(17);
    // => ']' SPACING # Choice
    switch (_ch == 93 ? 0 : _ch == -1 ? 2 : 1) {
      // []]
      case 0:
        // => ']' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => ']'
          $$ = ']';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ']'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // ']'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ']' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ']'
      _failure(_expect33);
    }
    // <= ']' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_CLOSE_PAREN() {
    // MORPHEME
    // CLOSE_PAREN <- ')' SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(39);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(18);
    // => ')' SPACING # Choice
    switch (_ch == 41 ? 0 : _ch == -1 ? 2 : 1) {
      // [)]
      case 0:
        // => ')' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => ')'
          $$ = ')';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ')'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // ')'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ')' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ')'
      _failure(_expect34);
    }
    // <= ')' SPACING # Choice
    _addToCache($$, pos, 39);
    _endToken();
    return $$;
  }

  dynamic _parse_COMMA() {
    // MORPHEME
    // COMMA <- ',' SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(40);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(19);
    // => ',' SPACING # Choice
    switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
      // [,]
      case 0:
        // => ',' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => ','
          $$ = ',';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ','
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // ','
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ',' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ','
      _failure(_expect30);
    }
    // <= ',' SPACING # Choice
    _addToCache($$, pos, 40);
    _endToken();
    return $$;
  }

  dynamic _parse_COMMENT() {
    // MORPHEME
    // COMMENT <- '//' (!EOL .)* (EOL / EOF)
    var $$;
    _beginToken(20);
    // => '//' (!EOL .)* (EOL / EOF) # Choice
    switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
      // [/]
      case 0:
        // => '//' (!EOL .)* (EOL / EOF) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '//'
          $$ = _matchString(_strings4, '//');
          // <= '//'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (!EOL .)*
          var testing0 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (!EOL .) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              // EOF
              case 0:
              case 2:
                // => !EOL . # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {
                  // => !EOL
                  var ch2 = _ch, pos2 = _cursor, testing1 = _testing;
                  _testing = _inputLen + 1;
                  // => EOL
                  $$ = _parse_EOL();
                  // <= EOL
                  _ch = ch2;
                  _cursor = pos2;
                  _testing = testing1;
                  $$ = null;
                  success = !success;
                  // <= !EOL
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => .
                  $$ = _matchAny();
                  // <= .
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= !EOL . # Sequence
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: null
              _failure(_expect36);
            }
            // <= (!EOL .) # Choice
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break;
            }
          }
          // <= (!EOL .)*
          if (!success) break;
          seq[1] = $$;
          // => (EOL / EOF) # Choice
          switch (_getState(_transitions11)) {
            // [\u0000-\t] [\u000b-\u000c] [\u000e-\u0010ffff]
            // EOF
            case 0:
            case 3:
              var startPos2 = _startPos;
              // => EOF
              $$ = _parse_EOF();
              // <= EOF
              _startPos = startPos2;
              break;
            // [\n] [\r]
            case 1:
              while (true) {
                var startPos3 = _startPos;
                // => EOL
                $$ = _parse_EOL();
                // <= EOL
                _startPos = startPos3;
                if (success) break;
                var startPos4 = _startPos;
                // => EOF
                $$ = _parse_EOF();
                // <= EOF
                _startPos = startPos4;
                break;
              }
              break;
            // No matches
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: EOL, EOF
            _failure(_expect37);
          }
          // <= (EOL / EOF) # Choice
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '//' (!EOL .)* (EOL / EOF) # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '//'
      _failure(_expect35);
    }
    // <= '//' (!EOL .)* (EOL / EOF) # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_CONST() {
    // MORPHEME
    // CONST <- 'const' SPACING
    var $$;
    _beginToken(21);
    // => 'const' SPACING # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        // => 'const' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'const'
          $$ = _matchString(_strings5, 'const');
          // <= 'const'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // 'const'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'const' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'const'
      _failure(_expect38);
    }
    // <= 'const' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ConstPointerParameter() {
    // MORPHEME
    // ConstPointerParameter <- CONST? PointerType IDENTIFIER?
    var $$;
    _beginToken(22);
    // => CONST? PointerType IDENTIFIER? # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => CONST? PointerType IDENTIFIER? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => CONST?
          var testing0 = _testing;
          _testing = _cursor;
          // => CONST
          $$ = _parse_CONST();
          // <= CONST
          success = true;
          _testing = testing0;
          // <= CONST?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => PointerType
          $$ = _parse_PointerType();
          // <= PointerType
          if (!success) break;
          seq[1] = $$;
          // => IDENTIFIER?
          var testing1 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true;
          _testing = testing1;
          // <= IDENTIFIER?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // CONST?
            final $1 = seq[0];
            // PointerType
            final $2 = seq[1];
            // IDENTIFIER?
            final $3 = seq[2];
            $$ = new ParameterDeclaration(name: $3, type: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= CONST? PointerType IDENTIFIER? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ConstPointerParameter
      _failure(_expect39);
    }
    // <= CONST? PointerType IDENTIFIER? # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_DIMENSION() {
    // MORPHEME
    // DIMENSION <- OPEN_BRACKET Dimension? CLOSE_BRACKET
    var $$;
    _beginToken(23);
    // => OPEN_BRACKET Dimension? CLOSE_BRACKET # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => OPEN_BRACKET Dimension? CLOSE_BRACKET # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => OPEN_BRACKET
          $$ = _parse_OPEN_BRACKET();
          // <= OPEN_BRACKET
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Dimension?
          var testing0 = _testing;
          _testing = _cursor;
          // => Dimension
          $$ = _parse_Dimension();
          // <= Dimension
          success = true;
          _testing = testing0;
          // <= Dimension?
          if (!success) break;
          seq[1] = $$;
          // => CLOSE_BRACKET
          $$ = _parse_CLOSE_BRACKET();
          // <= CLOSE_BRACKET
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // OPEN_BRACKET
            final $1 = seq[0];
            // Dimension?
            final $2 = seq[1];
            // CLOSE_BRACKET
            final $3 = seq[2];
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= OPEN_BRACKET Dimension? CLOSE_BRACKET # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect40);
    }
    // <= OPEN_BRACKET Dimension? CLOSE_BRACKET # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_DIMENSIONS() {
    // MORPHEME
    // DIMENSIONS <- DIMENSION+
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(45);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(24);
    // => DIMENSION+ # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        var startPos0 = _startPos;
        // => DIMENSION+
        var testing0;
        for (var first = true, reps; ;) {
          // => DIMENSION
          $$ = _parse_DIMENSION();
          // <= DIMENSION
          if (success) {
           if (first) {
              first = false;
              reps = [$$];
              testing0 = _testing;
            } else {
              reps.add($$);
            }
            _testing = _cursor;
          } else {
            success = !first;
            if (success) {
              _testing = testing0;
              $$ = reps;
            } else $$ = null;
            break;
          }
        }
        // <= DIMENSION+
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect40);
    }
    // <= DIMENSION+ # Choice
    _addToCache($$, pos, 45);
    _endToken();
    return $$;
  }

  dynamic _parse_Declaration() {
    // NONTERMINAL
    // Declaration <- FunctionDeclartion SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / StructDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / SEMICOLON+
    var $$;
    // => FunctionDeclartion SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / StructDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / SEMICOLON+ # Choice
    switch (_getState(_transitions0)) {
      // [;]
      case 0:
        var startPos0 = _startPos;
        // => SEMICOLON+
        var testing0;
        for (var first = true, reps; ;) {
          // => SEMICOLON
          $$ = _parse_SEMICOLON();
          // <= SEMICOLON
          if (success) {
           if (first) {
              first = false;
              reps = [$$];
              testing0 = _testing;
            } else {
              reps.add($$);
            }
            _testing = _cursor;
          } else {
            success = !first;
            if (success) {
              _testing = testing0;
              $$ = reps;
            } else $$ = null;
            break;
          }
        }
        // <= SEMICOLON+
        if (success) {
          // SEMICOLON+
          final $1 = $$;
          $$ = new EmptyDeclaration();
        }
        _startPos = startPos0;
        break;
      // [A-Z] [_]
      // EOF
      case 1:
      case 4:
        while (true) {
          // => FunctionDeclartion SEMICOLON+ # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => FunctionDeclartion
            $$ = _parse_FunctionDeclartion();
            // <= FunctionDeclartion
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing1;
            for (var first = true, reps; ;) {
              // => SEMICOLON
              $$ = _parse_SEMICOLON();
              // <= SEMICOLON
              if (success) {
               if (first) {
                  first = false;
                  reps = [$$];
                  testing1 = _testing;
                } else {
                  reps.add($$);
                }
                _testing = _cursor;
              } else {
                success = !first;
                if (success) {
                  _testing = testing1;
                  $$ = reps;
                } else $$ = null;
                break;
              }
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // FunctionDeclartion
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= FunctionDeclartion SEMICOLON+ # Sequence
          if (success) break;
          // => VariableDeclaration SEMICOLON+ # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => VariableDeclaration
            $$ = _parse_VariableDeclaration();
            // <= VariableDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing2;
            for (var first = true, reps; ;) {
              // => SEMICOLON
              $$ = _parse_SEMICOLON();
              // <= SEMICOLON
              if (success) {
               if (first) {
                  first = false;
                  reps = [$$];
                  testing2 = _testing;
                } else {
                  reps.add($$);
                }
                _testing = _cursor;
              } else {
                success = !first;
                if (success) {
                  _testing = testing2;
                  $$ = reps;
                } else $$ = null;
                break;
              }
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // VariableDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos2;
          // <= VariableDeclaration SEMICOLON+ # Sequence
          break;
        }
        break;
      // [a-z]
      case 2:
        while (true) {
          // => FunctionDeclartion SEMICOLON+ # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => FunctionDeclartion
            $$ = _parse_FunctionDeclartion();
            // <= FunctionDeclartion
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing3;
            for (var first = true, reps; ;) {
              // => SEMICOLON
              $$ = _parse_SEMICOLON();
              // <= SEMICOLON
              if (success) {
               if (first) {
                  first = false;
                  reps = [$$];
                  testing3 = _testing;
                } else {
                  reps.add($$);
                }
                _testing = _cursor;
              } else {
                success = !first;
                if (success) {
                  _testing = testing3;
                  $$ = reps;
                } else $$ = null;
                break;
              }
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // FunctionDeclartion
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos3;
          // <= FunctionDeclartion SEMICOLON+ # Sequence
          if (success) break;
          // => TypedefDeclaration SEMICOLON+ # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => TypedefDeclaration
            $$ = _parse_TypedefDeclaration();
            // <= TypedefDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing4;
            for (var first = true, reps; ;) {
              // => SEMICOLON
              $$ = _parse_SEMICOLON();
              // <= SEMICOLON
              if (success) {
               if (first) {
                  first = false;
                  reps = [$$];
                  testing4 = _testing;
                } else {
                  reps.add($$);
                }
                _testing = _cursor;
              } else {
                success = !first;
                if (success) {
                  _testing = testing4;
                  $$ = reps;
                } else $$ = null;
                break;
              }
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // TypedefDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos4;
          // <= TypedefDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => VariableDeclaration SEMICOLON+ # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => VariableDeclaration
            $$ = _parse_VariableDeclaration();
            // <= VariableDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing5;
            for (var first = true, reps; ;) {
              // => SEMICOLON
              $$ = _parse_SEMICOLON();
              // <= SEMICOLON
              if (success) {
               if (first) {
                  first = false;
                  reps = [$$];
                  testing5 = _testing;
                } else {
                  reps.add($$);
                }
                _testing = _cursor;
              } else {
                success = !first;
                if (success) {
                  _testing = testing5;
                  $$ = reps;
                } else $$ = null;
                break;
              }
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // VariableDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos5;
          // <= VariableDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => StructDeclaration SEMICOLON+ # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => StructDeclaration
            $$ = _parse_StructDeclaration();
            // <= StructDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing6;
            for (var first = true, reps; ;) {
              // => SEMICOLON
              $$ = _parse_SEMICOLON();
              // <= SEMICOLON
              if (success) {
               if (first) {
                  first = false;
                  reps = [$$];
                  testing6 = _testing;
                } else {
                  reps.add($$);
                }
                _testing = _cursor;
              } else {
                success = !first;
                if (success) {
                  _testing = testing6;
                  $$ = reps;
                } else $$ = null;
                break;
              }
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // StructDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos6;
          // <= StructDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => EnumDeclaration SEMICOLON+ # Sequence
          var ch6 = _ch, pos6 = _cursor, startPos7 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => EnumDeclaration
            $$ = _parse_EnumDeclaration();
            // <= EnumDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing7;
            for (var first = true, reps; ;) {
              // => SEMICOLON
              $$ = _parse_SEMICOLON();
              // <= SEMICOLON
              if (success) {
               if (first) {
                  first = false;
                  reps = [$$];
                  testing7 = _testing;
                } else {
                  reps.add($$);
                }
                _testing = _cursor;
              } else {
                success = !first;
                if (success) {
                  _testing = testing7;
                  $$ = reps;
                } else $$ = null;
                break;
              }
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // EnumDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos7;
          // <= EnumDeclaration SEMICOLON+ # Sequence
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: FunctionDeclartion, 'typedef', ArrayVariableDeclaration, 'enum', PointerVariableDeclaration, SimpleVariableDeclaration, 'struct', 'union', ';'
      _failure(_expect2);
    }
    // <= FunctionDeclartion SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / StructDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / SEMICOLON+ # Choice
    return $$;
  }

  dynamic _parse_DeclarationList() {
    // NONTERMINAL
    // DeclarationList <- Declaration*
    var $$;
    // => Declaration* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        var startPos0 = _startPos;
        // => Declaration*
        var testing0 = _testing;
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => Declaration
          $$ = _parse_Declaration();
          // <= Declaration
          if (success) {
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break;
          }
        }
        // <= Declaration*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
      // EOF
      case 2:
        while (true) {
          var startPos1 = _startPos;
          // => Declaration*
          var testing1 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => Declaration
            $$ = _parse_Declaration();
            // <= Declaration
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break;
            }
          }
          // <= Declaration*
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => Declaration*
          var testing2 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => Declaration
            $$ = _parse_Declaration();
            // <= Declaration
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing2;
              $$ = reps;
              break;
            }
          }
          // <= Declaration*
          _startPos = startPos2;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected:
      _failure(_expect1);
    }
    // <= Declaration* # Choice
    return $$;
  }

  dynamic _parse_Dimension() {
    // MORPHEME
    // Dimension <- !ZERO (OCTAL_NUMBER / INTEGER)
    var $$;
    _beginToken(25);
    // => !ZERO (OCTAL_NUMBER / INTEGER) # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        // => !ZERO (OCTAL_NUMBER / INTEGER) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => !ZERO
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => ZERO
          $$ = _parse_ZERO();
          // <= ZERO
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !ZERO
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (OCTAL_NUMBER / INTEGER) # Choice
          switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
            // [\u0000-\u0010ffff]
            case 0:
              while (true) {
                var startPos1 = _startPos;
                // => OCTAL_NUMBER
                $$ = _parse_OCTAL_NUMBER();
                // <= OCTAL_NUMBER
                _startPos = startPos1;
                if (success) break;
                var startPos2 = _startPos;
                // => INTEGER
                $$ = _parse_INTEGER();
                // <= INTEGER
                _startPos = startPos2;
                break;
              }
              break;
            // No matches
            // EOF
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: OCTAL_NUMBER, INTEGER
            _failure(_expect42);
          }
          // <= (OCTAL_NUMBER / INTEGER) # Choice
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // !ZERO
            final $1 = seq[0];
            // (OCTAL_NUMBER / INTEGER)
            final $2 = seq[1];
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !ZERO (OCTAL_NUMBER / INTEGER) # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Dimension
      _failure(_expect41);
    }
    // <= !ZERO (OCTAL_NUMBER / INTEGER) # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ELLIPSIS() {
    // MORPHEME
    // ELLIPSIS <- '...' SPACING
    var $$;
    _beginToken(26);
    // => '...' SPACING # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        // => '...' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '...'
          $$ = _matchString(_strings6, '...');
          // <= '...'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '...'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '...' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '...'
      _failure(_expect43);
    }
    // <= '...' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_EOF() {
    // LEXEME & MORPHEME
    // EOF <- !.
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(15);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(2);
    // => !. # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => !.
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing;
        _testing = _inputLen + 1;
        // => .
        $$ = _matchAny();
        // <= .
        _ch = ch0;
        _cursor = pos0;
        _testing = testing0;
        $$ = null;
        success = !success;
        // <= !.
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= !. # Choice
    _addToCache($$, pos, 15);
    _endToken();
    return $$;
  }

  dynamic _parse_EOL() {
    // MORPHEME
    // EOL <- '\r\n' / [\n\r]
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(48);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(27);
    // => '\r\n' / [\n\r] # Choice
    switch (_getState(_transitions12)) {
      // [\n]
      case 0:
        var startPos0 = _startPos;
        // => [\n\r]
        $$ = _matchMapping(10, 13, _mapping0);
        // <= [\n\r]
        _startPos = startPos0;
        break;
      // [\r]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          // => '\r\n'
          $$ = _matchString(_strings7, '\r\n');
          // <= '\r\n'
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => [\n\r]
          $$ = _matchMapping(10, 13, _mapping0);
          // <= [\n\r]
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOL
      _failure(_expect44);
    }
    // <= '\r\n' / [\n\r] # Choice
    _addToCache($$, pos, 48);
    _endToken();
    return $$;
  }

  dynamic _parse_EnumDeclaration() {
    // LEXEME
    // EnumDeclaration <- ID_ENUM IDENTIFIER? OPEN_BRACE EnumValueList CLOSE_BRACE
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(16);
    }
    if($$ != null) {
      return $$[0];
    }
    // => ID_ENUM IDENTIFIER? OPEN_BRACE EnumValueList CLOSE_BRACE # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => ID_ENUM IDENTIFIER? OPEN_BRACE EnumValueList CLOSE_BRACE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => ID_ENUM
          $$ = _parse_ID_ENUM();
          // <= ID_ENUM
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true;
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          // => OPEN_BRACE
          $$ = _parse_OPEN_BRACE();
          // <= OPEN_BRACE
          if (!success) break;
          seq[2] = $$;
          // => EnumValueList
          $$ = _parse_EnumValueList();
          // <= EnumValueList
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_BRACE
          $$ = _parse_CLOSE_BRACE();
          // <= CLOSE_BRACE
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          if (success) {
            // ID_ENUM
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            // OPEN_BRACE
            final $3 = seq[2];
            // EnumValueList
            final $4 = seq[3];
            // CLOSE_BRACE
            final $5 = seq[4];
            $$ = new EnumDeclaration(kind: $1, tag: $2, values: $4);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ID_ENUM IDENTIFIER? OPEN_BRACE EnumValueList CLOSE_BRACE # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect11);
    }
    // <= ID_ENUM IDENTIFIER? OPEN_BRACE EnumValueList CLOSE_BRACE # Choice
    _addToCache($$, pos, 16);
    return $$;
  }

  dynamic _parse_EnumValue() {
    // MORPHEME
    // EnumValue <- IDENTIFIER ASSIGN NUMBER / IDENTIFIER
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(49);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(28);
    // => IDENTIFIER ASSIGN NUMBER / IDENTIFIER # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => IDENTIFIER ASSIGN NUMBER # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => IDENTIFIER
            $$ = _parse_IDENTIFIER();
            // <= IDENTIFIER
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ASSIGN
            $$ = _parse_ASSIGN();
            // <= ASSIGN
            if (!success) break;
            seq[1] = $$;
            // => NUMBER
            $$ = _parse_NUMBER();
            // <= NUMBER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {
              // IDENTIFIER
              final $1 = seq[0];
              // ASSIGN
              final $2 = seq[1];
              // NUMBER
              final $3 = seq[2];
              $$ = new EnumValueDeclaration(name: $1, value: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= IDENTIFIER ASSIGN NUMBER # Sequence
          if (success) break;
          var startPos1 = _startPos;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (success) {
            // IDENTIFIER
            final $1 = $$;
            $$ = new EnumValueDeclaration(name: $1);
          }
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EnumValue
      _failure(_expect45);
    }
    // <= IDENTIFIER ASSIGN NUMBER / IDENTIFIER # Choice
    _addToCache($$, pos, 49);
    _endToken();
    return $$;
  }

  dynamic _parse_EnumValueList() {
    // MORPHEME
    // EnumValueList <- EnumValue (COMMA EnumValue)* COMMA?
    var $$;
    _beginToken(29);
    // => EnumValue (COMMA EnumValue)* COMMA? # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => EnumValue (COMMA EnumValue)* COMMA? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => EnumValue
          $$ = _parse_EnumValue();
          // <= EnumValue
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (COMMA EnumValue)*
          var testing0 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA EnumValue) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA EnumValue # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => EnumValue
                  $$ = _parse_EnumValue();
                  // <= EnumValue
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA EnumValue # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect30);
            }
            // <= (COMMA EnumValue) # Choice
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break;
            }
          }
          // <= (COMMA EnumValue)*
          if (!success) break;
          seq[1] = $$;
          // => COMMA?
          var testing1 = _testing;
          _testing = _cursor;
          // => COMMA
          $$ = _parse_COMMA();
          // <= COMMA
          success = true;
          _testing = testing1;
          // <= COMMA?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // EnumValue
            final $1 = seq[0];
            // (COMMA EnumValue)*
            final $2 = seq[1];
            // COMMA?
            final $3 = seq[2];
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= EnumValue (COMMA EnumValue)* COMMA? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EnumValueList
      _failure(_expect46);
    }
    // <= EnumValue (COMMA EnumValue)* COMMA? # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_FunctionDeclartion() {
    // LEXEME
    // FunctionDeclartion <- IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN / Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN
    var $$;
    // => IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN / Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => IDENTIFIER
            $$ = _parse_IDENTIFIER();
            // <= IDENTIFIER
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => OPEN_PAREN
            $$ = _parse_OPEN_PAREN();
            // <= OPEN_PAREN
            if (!success) break;
            seq[1] = $$;
            // => FunctionParameters?
            var testing0 = _testing;
            _testing = _cursor;
            // => FunctionParameters
            $$ = _parse_FunctionParameters();
            // <= FunctionParameters
            success = true;
            _testing = testing0;
            // <= FunctionParameters?
            if (!success) break;
            seq[2] = $$;
            // => CLOSE_PAREN
            $$ = _parse_CLOSE_PAREN();
            // <= CLOSE_PAREN
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {
              // IDENTIFIER
              final $1 = seq[0];
              // OPEN_PAREN
              final $2 = seq[1];
              // FunctionParameters?
              final $3 = seq[2];
              // CLOSE_PAREN
              final $4 = seq[3];
              $$ = new FunctionDeclaration(name: $1, parameters: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN # Sequence
          if (success) break;
          // => Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => IDENTIFIER
            $$ = _parse_IDENTIFIER();
            // <= IDENTIFIER
            if (!success) break;
            seq[1] = $$;
            // => OPEN_PAREN
            $$ = _parse_OPEN_PAREN();
            // <= OPEN_PAREN
            if (!success) break;
            seq[2] = $$;
            // => FunctionParameters?
            var testing1 = _testing;
            _testing = _cursor;
            // => FunctionParameters
            $$ = _parse_FunctionParameters();
            // <= FunctionParameters
            success = true;
            _testing = testing1;
            // <= FunctionParameters?
            if (!success) break;
            seq[3] = $$;
            // => CLOSE_PAREN
            $$ = _parse_CLOSE_PAREN();
            // <= CLOSE_PAREN
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {
              // Type
              final $1 = seq[0];
              // IDENTIFIER
              final $2 = seq[1];
              // OPEN_PAREN
              final $3 = seq[2];
              // FunctionParameters?
              final $4 = seq[3];
              // CLOSE_PAREN
              final $5 = seq[4];
              $$ = new FunctionDeclaration(name: $2, parameters: $4, returnType: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN # Sequence
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: FunctionDeclartion
      _failure(_expect12);
    }
    // <= IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN / Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN # Choice
    return $$;
  }

  dynamic _parse_FunctionParameter() {
    // MORPHEME
    // FunctionParameter <- ArrayParameter / ConstPointerParameter / PointerParameter / SimpleParameter
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(51);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(30);
    // => ArrayParameter / ConstPointerParameter / PointerParameter / SimpleParameter # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          var startPos0 = _startPos;
          // => ArrayParameter
          $$ = _parse_ArrayParameter();
          // <= ArrayParameter
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => ConstPointerParameter
          $$ = _parse_ConstPointerParameter();
          // <= ConstPointerParameter
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => PointerParameter
          $$ = _parse_PointerParameter();
          // <= PointerParameter
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          // => SimpleParameter
          $$ = _parse_SimpleParameter();
          // <= SimpleParameter
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: FunctionParameter
      _failure(_expect47);
    }
    // <= ArrayParameter / ConstPointerParameter / PointerParameter / SimpleParameter # Choice
    _addToCache($$, pos, 51);
    _endToken();
    return $$;
  }

  dynamic _parse_FunctionParameterList() {
    // MORPHEME
    // FunctionParameterList <- FunctionParameter (COMMA FunctionParameter)*
    var $$;
    _beginToken(31);
    // => FunctionParameter (COMMA FunctionParameter)* # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => FunctionParameter (COMMA FunctionParameter)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => FunctionParameter
          $$ = _parse_FunctionParameter();
          // <= FunctionParameter
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA FunctionParameter)*
          var testing0 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA FunctionParameter) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA FunctionParameter # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => FunctionParameter
                  $$ = _parse_FunctionParameter();
                  // <= FunctionParameter
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA FunctionParameter # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect30);
            }
            // <= (COMMA FunctionParameter) # Choice
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break;
            }
          }
          // <= (COMMA FunctionParameter)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // FunctionParameter
            final $1 = seq[0];
            // (COMMA FunctionParameter)*
            final $2 = seq[1];
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionParameter (COMMA FunctionParameter)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: FunctionParameterList
      _failure(_expect48);
    }
    // <= FunctionParameter (COMMA FunctionParameter)* # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_FunctionParameters() {
    // MORPHEME
    // FunctionParameters <- FunctionParameterList (COMMA VaListParameter)?
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(53);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(32);
    // => FunctionParameterList (COMMA VaListParameter)? # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => FunctionParameterList (COMMA VaListParameter)? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => FunctionParameterList
          $$ = _parse_FunctionParameterList();
          // <= FunctionParameterList
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA VaListParameter)?
          var testing0 = _testing;
          _testing = _cursor;
          // => (COMMA VaListParameter) # Choice
          switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
            // [,]
            case 0:
              // => COMMA VaListParameter # Sequence
              var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {
                // => COMMA
                $$ = _parse_COMMA();
                // <= COMMA
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                // => VaListParameter
                $$ = _parse_VaListParameter();
                // <= VaListParameter
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                if (success) {
                  // COMMA
                  final $1 = seq[0];
                  // VaListParameter
                  final $2 = seq[1];
                  $$ = $2;
                }
                break;
              }
              if (!success) {
                _ch = ch1;
                _cursor = pos1;
              }
              _startPos = startPos1;
              // <= COMMA VaListParameter # Sequence
              break;
            // No matches
            // EOF
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: ','
            _failure(_expect30);
          }
          // <= (COMMA VaListParameter) # Choice
          success = true;
          _testing = testing0;
          // <= (COMMA VaListParameter)?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // FunctionParameterList
            final $1 = seq[0];
            // (COMMA VaListParameter)?
            final $2 = seq[1];
            $$ = _createParameters($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionParameterList (COMMA VaListParameter)? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: FunctionParameters
      _failure(_expect49);
    }
    // <= FunctionParameterList (COMMA VaListParameter)? # Choice
    _addToCache($$, pos, 53);
    _endToken();
    return $$;
  }

  dynamic _parse_IDENT() {
    // MORPHEME
    // IDENT <- IDENT_START IDENT_CONT* SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(54);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(33);
    // => IDENT_START IDENT_CONT* SPACING # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      case 0:
        // => IDENT_START IDENT_CONT* SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENT_CONT*
          var testing0 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => IDENT_CONT
            $$ = _parse_IDENT_CONT();
            // <= IDENT_CONT
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break;
            }
          }
          // <= IDENT_CONT*
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // IDENT_START
            final $1 = seq[0];
            // IDENT_CONT*
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = _flatten([$1, $2]).join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= IDENT_START IDENT_CONT* SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT
      _failure(_expect50);
    }
    // <= IDENT_START IDENT_CONT* SPACING # Choice
    _addToCache($$, pos, 54);
    _endToken();
    return $$;
  }

  dynamic _parse_IDENTIFIER() {
    // LEXEME & MORPHEME
    // IDENTIFIER <- !ReservedWord IDENT_START IDENT_CONT* SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(18);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(3);
    // => !ReservedWord IDENT_START IDENT_CONT* SPACING # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => !ReservedWord IDENT_START IDENT_CONT* SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => !ReservedWord
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => ReservedWord
          $$ = _parse_ReservedWord();
          // <= ReservedWord
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !ReservedWord
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          if (!success) break;
          seq[1] = $$;
          // => IDENT_CONT*
          var testing1 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => IDENT_CONT
            $$ = _parse_IDENT_CONT();
            // <= IDENT_CONT
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break;
            }
          }
          // <= IDENT_CONT*
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {
            // !ReservedWord
            final $1 = seq[0];
            // IDENT_START
            final $2 = seq[1];
            // IDENT_CONT*
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            $$ = _flatten([$2, $3]).join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !ReservedWord IDENT_START IDENT_CONT* SPACING # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER
      _failure(_expect13);
    }
    // <= !ReservedWord IDENT_START IDENT_CONT* SPACING # Choice
    _addToCache($$, pos, 18);
    _endToken();
    return $$;
  }

  dynamic _parse_IDENT_CONT() {
    // MORPHEME
    // IDENT_CONT <- IDENT_START / [0-9]
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(55);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(34);
    // => IDENT_START / [0-9] # Choice
    switch (_getState(_transitions13)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        // => [0-9]
        $$ = _matchRange(48, 57);
        // <= [0-9]
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        var startPos1 = _startPos;
        // => IDENT_START
        $$ = _parse_IDENT_START();
        // <= IDENT_START
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT_CONT
      _failure(_expect51);
    }
    // <= IDENT_START / [0-9] # Choice
    _addToCache($$, pos, 55);
    _endToken();
    return $$;
  }

  dynamic _parse_IDENT_PART() {
    // MORPHEME
    // IDENT_PART <- IDENT_START / IDENT_CONT
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(56);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(35);
    // => IDENT_START / IDENT_CONT # Choice
    switch (_getState(_transitions13)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        // => IDENT_CONT
        $$ = _parse_IDENT_CONT();
        // <= IDENT_CONT
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => IDENT_CONT
          $$ = _parse_IDENT_CONT();
          // <= IDENT_CONT
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT_PART
      _failure(_expect52);
    }
    // <= IDENT_START / IDENT_CONT # Choice
    _addToCache($$, pos, 56);
    _endToken();
    return $$;
  }

  dynamic _parse_IDENT_START() {
    // MORPHEME
    // IDENT_START <- [A-Z_a-z]
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(57);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(36);
    // => [A-Z_a-z] # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        // => [A-Z_a-z]
        $$ = _matchMapping(65, 122, _mapping1);
        // <= [A-Z_a-z]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT_START
      _failure(_expect53);
    }
    // <= [A-Z_a-z] # Choice
    _addToCache($$, pos, 57);
    _endToken();
    return $$;
  }

  dynamic _parse_ID_CHAR() {
    // MORPHEME
    // ID_CHAR <- 'char' !IDENT_PART SPACING
    var $$;
    _beginToken(37);
    // => 'char' !IDENT_PART SPACING # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        // => 'char' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'char'
          $$ = _matchString(_strings8, 'char');
          // <= 'char'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'char'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'char' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'char'
      _failure(_expect54);
    }
    // <= 'char' !IDENT_PART SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ID_DOUBLE() {
    // MORPHEME
    // ID_DOUBLE <- 'double' !IDENT_PART SPACING
    var $$;
    _beginToken(38);
    // => 'double' !IDENT_PART SPACING # Choice
    switch (_ch == 100 ? 0 : _ch == -1 ? 2 : 1) {
      // [d]
      case 0:
        // => 'double' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'double'
          $$ = _matchString(_strings9, 'double');
          // <= 'double'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'double'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'double' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'double'
      _failure(_expect55);
    }
    // <= 'double' !IDENT_PART SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ID_ENUM() {
    // MORPHEME
    // ID_ENUM <- 'enum' !IDENT_PART SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(60);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(39);
    // => 'enum' !IDENT_PART SPACING # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => 'enum' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'enum'
          $$ = _matchString(_strings10, 'enum');
          // <= 'enum'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'enum'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'enum' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect11);
    }
    // <= 'enum' !IDENT_PART SPACING # Choice
    _addToCache($$, pos, 60);
    _endToken();
    return $$;
  }

  dynamic _parse_ID_FLOAT() {
    // MORPHEME
    // ID_FLOAT <- 'float' !IDENT_PART SPACING
    var $$;
    _beginToken(40);
    // => 'float' !IDENT_PART SPACING # Choice
    switch (_ch == 102 ? 0 : _ch == -1 ? 2 : 1) {
      // [f]
      case 0:
        // => 'float' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'float'
          $$ = _matchString(_strings11, 'float');
          // <= 'float'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'float'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'float' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'float'
      _failure(_expect56);
    }
    // <= 'float' !IDENT_PART SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ID_INT() {
    // MORPHEME
    // ID_INT <- 'int' !IDENT_PART SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(62);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(41);
    // => 'int' !IDENT_PART SPACING # Choice
    switch (_ch == 105 ? 0 : _ch == -1 ? 2 : 1) {
      // [i]
      case 0:
        // => 'int' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'int'
          $$ = _matchString(_strings12, 'int');
          // <= 'int'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'int'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'int' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'int'
      _failure(_expect57);
    }
    // <= 'int' !IDENT_PART SPACING # Choice
    _addToCache($$, pos, 62);
    _endToken();
    return $$;
  }

  dynamic _parse_ID_LONG() {
    // MORPHEME
    // ID_LONG <- 'long' !IDENT_PART SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(63);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(42);
    // => 'long' !IDENT_PART SPACING # Choice
    switch (_ch == 108 ? 0 : _ch == -1 ? 2 : 1) {
      // [l]
      case 0:
        // => 'long' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'long'
          $$ = _matchString(_strings13, 'long');
          // <= 'long'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'long'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'long' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'long'
      _failure(_expect58);
    }
    // <= 'long' !IDENT_PART SPACING # Choice
    _addToCache($$, pos, 63);
    _endToken();
    return $$;
  }

  dynamic _parse_ID_SHORT() {
    // MORPHEME
    // ID_SHORT <- 'short' !IDENT_PART SPACING
    var $$;
    _beginToken(43);
    // => 'short' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'short' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'short'
          $$ = _matchString(_strings14, 'short');
          // <= 'short'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'short'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'short' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'short'
      _failure(_expect59);
    }
    // <= 'short' !IDENT_PART SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ID_SIGNED() {
    // MORPHEME
    // ID_SIGNED <- 'signed' !IDENT_PART SPACING
    var $$;
    _beginToken(44);
    // => 'signed' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'signed' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'signed'
          $$ = _matchString(_strings15, 'signed');
          // <= 'signed'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'signed'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'signed' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'signed'
      _failure(_expect60);
    }
    // <= 'signed' !IDENT_PART SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ID_STRUCT() {
    // LEXEME & MORPHEME
    // ID_STRUCT <- 'struct' !IDENT_PART SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(19);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(4);
    // => 'struct' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'struct' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'struct'
          $$ = _matchString(_strings0, 'struct');
          // <= 'struct'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'struct'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'struct' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct'
      _failure(_expect14);
    }
    // <= 'struct' !IDENT_PART SPACING # Choice
    _addToCache($$, pos, 19);
    _endToken();
    return $$;
  }

  dynamic _parse_ID_UNION() {
    // LEXEME & MORPHEME
    // ID_UNION <- 'union' !IDENT_PART SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(20);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(5);
    // => 'union' !IDENT_PART SPACING # Choice
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      // [u]
      case 0:
        // => 'union' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'union'
          $$ = _matchString(_strings1, 'union');
          // <= 'union'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'union'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'union' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'union'
      _failure(_expect15);
    }
    // <= 'union' !IDENT_PART SPACING # Choice
    _addToCache($$, pos, 20);
    _endToken();
    return $$;
  }

  dynamic _parse_ID_UNSIGNED() {
    // MORPHEME
    // ID_UNSIGNED <- 'unsigned' !IDENT_PART SPACING
    var $$;
    _beginToken(45);
    // => 'unsigned' !IDENT_PART SPACING # Choice
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      // [u]
      case 0:
        // => 'unsigned' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'unsigned'
          $$ = _matchString(_strings16, 'unsigned');
          // <= 'unsigned'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'unsigned'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'unsigned' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'unsigned'
      _failure(_expect61);
    }
    // <= 'unsigned' !IDENT_PART SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_ID_VOID() {
    // MORPHEME
    // ID_VOID <- 'void' !IDENT_PART SPACING
    var $$;
    _beginToken(46);
    // => 'void' !IDENT_PART SPACING # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        // => 'void' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'void'
          $$ = _matchString(_strings17, 'void');
          // <= 'void'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // 'void'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'void' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'void'
      _failure(_expect62);
    }
    // <= 'void' !IDENT_PART SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_INTEGER() {
    // MORPHEME
    // INTEGER <- SIGN [0-9]+ SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(68);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(47);
    // => SIGN [0-9]+ SPACING # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        // => SIGN [0-9]+ SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => SIGN
          $$ = _parse_SIGN();
          // <= SIGN
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => [0-9]+
          var testing0;
          for (var first = true, reps; ;) {
            // => [0-9]
            $$ = _matchRange(48, 57);
            // <= [0-9]
            if (success) {
             if (first) {
                first = false;
                reps = [$$];
                testing0 = _testing;
              } else {
                reps.add($$);
              }
              _testing = _cursor;
            } else {
              success = !first;
              if (success) {
                _testing = testing0;
                $$ = reps;
              } else $$ = null;
              break;
            }
          }
          // <= [0-9]+
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // SIGN
            final $1 = seq[0];
            // [0-9]+
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            $$ = $1 * int.parse($2.join());
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SIGN [0-9]+ SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: INTEGER
      _failure(_expect63);
    }
    // <= SIGN [0-9]+ SPACING # Choice
    _addToCache($$, pos, 68);
    _endToken();
    return $$;
  }

  dynamic _parse_LongType() {
    // MORPHEME
    // LongType <- ID_LONG ID_LONG / ID_LONG
    var $$;
    _beginToken(48);
    // => ID_LONG ID_LONG / ID_LONG # Choice
    switch (_ch == 108 ? 0 : _ch == -1 ? 2 : 1) {
      // [l]
      case 0:
        while (true) {
          // => ID_LONG ID_LONG # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => ID_LONG
            $$ = _parse_ID_LONG();
            // <= ID_LONG
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => ID_LONG
            $$ = _parse_ID_LONG();
            // <= ID_LONG
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // ID_LONG
              final $1 = seq[0];
              // ID_LONG
              final $2 = seq[1];
              $$ = _createInt([$1, $2]);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= ID_LONG ID_LONG # Sequence
          if (success) break;
          var startPos1 = _startPos;
          // => ID_LONG
          $$ = _parse_ID_LONG();
          // <= ID_LONG
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'long'
      _failure(_expect58);
    }
    // <= ID_LONG ID_LONG / ID_LONG # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_MINUS() {
    // MORPHEME
    // MINUS <- '-' SPACING
    var $$;
    _beginToken(49);
    // => '-' SPACING # Choice
    switch (_ch == 45 ? 0 : _ch == -1 ? 2 : 1) {
      // [-]
      case 0:
        // => '-' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '-'
          $$ = '-';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '-'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '-'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '-' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '-'
      _failure(_expect64);
    }
    // <= '-' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_NUMBER() {
    // MORPHEME
    // NUMBER <- OCTAL_NUMBER / INTEGER
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(71);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(50);
    // => OCTAL_NUMBER / INTEGER # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => OCTAL_NUMBER
          $$ = _parse_OCTAL_NUMBER();
          // <= OCTAL_NUMBER
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => INTEGER
          $$ = _parse_INTEGER();
          // <= INTEGER
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NUMBER
      _failure(_expect65);
    }
    // <= OCTAL_NUMBER / INTEGER # Choice
    _addToCache($$, pos, 71);
    _endToken();
    return $$;
  }

  dynamic _parse_OCTAL_NUMBER() {
    // MORPHEME
    // OCTAL_NUMBER <- SIGN [0] [0-9]+
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(72);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(51);
    // => SIGN [0] [0-9]+ # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        // => SIGN [0] [0-9]+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => SIGN
          $$ = _parse_SIGN();
          // <= SIGN
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => [0]
          $$ = _matchChar(48, '0');
          // <= [0]
          if (!success) break;
          seq[1] = $$;
          // => [0-9]+
          var testing0;
          for (var first = true, reps; ;) {
            // => [0-9]
            $$ = _matchRange(48, 57);
            // <= [0-9]
            if (success) {
             if (first) {
                first = false;
                reps = [$$];
                testing0 = _testing;
              } else {
                reps.add($$);
              }
              _testing = _cursor;
            } else {
              success = !first;
              if (success) {
                _testing = testing0;
                $$ = reps;
              } else $$ = null;
              break;
            }
          }
          // <= [0-9]+
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // SIGN
            final $1 = seq[0];
            // [0]
            final $2 = seq[1];
            // [0-9]+
            final $3 = seq[2];
            $$ = $1 * int.parse(_flatten([$2, $3]).join(), radix: 8);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SIGN [0] [0-9]+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: OCTAL_NUMBER
      _failure(_expect66);
    }
    // <= SIGN [0] [0-9]+ # Choice
    _addToCache($$, pos, 72);
    _endToken();
    return $$;
  }

  dynamic _parse_OPEN_BRACE() {
    // LEXEME & MORPHEME
    // OPEN_BRACE <- '{' SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(21);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(6);
    // => '{' SPACING # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => '{' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '{'
          $$ = '{';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '{'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '{'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '{' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '{'
      _failure(_expect16);
    }
    // <= '{' SPACING # Choice
    _addToCache($$, pos, 21);
    _endToken();
    return $$;
  }

  dynamic _parse_OPEN_BRACKET() {
    // MORPHEME
    // OPEN_BRACKET <- '[' SPACING
    var $$;
    _beginToken(52);
    // => '[' SPACING # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => '[' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '['
          $$ = '[';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '['
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '['
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '[' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect40);
    }
    // <= '[' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_OPEN_PAREN() {
    // MORPHEME
    // OPEN_PAREN <- '(' SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(74);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(53);
    // => '(' SPACING # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => '(' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '('
          $$ = '(';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '('
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '('
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '(' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect67);
    }
    // <= '(' SPACING # Choice
    _addToCache($$, pos, 74);
    _endToken();
    return $$;
  }

  dynamic _parse_PLUS() {
    // MORPHEME
    // PLUS <- '+' SPACING
    var $$;
    _beginToken(54);
    // => '+' SPACING # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        // => '+' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => '+'
          $$ = '+';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '+'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // '+'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '+' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '+'
      _failure(_expect68);
    }
    // <= '+' SPACING # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_PointerParameter() {
    // MORPHEME
    // PointerParameter <- PointerType IDENTIFIER?
    var $$;
    _beginToken(55);
    // => PointerType IDENTIFIER? # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => PointerType IDENTIFIER? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => PointerType
          $$ = _parse_PointerType();
          // <= PointerType
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true;
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // PointerType
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            $$ = new ParameterDeclaration(name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerType IDENTIFIER? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: PointerParameter
      _failure(_expect69);
    }
    // <= PointerType IDENTIFIER? # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_PointerType() {
    // MORPHEME
    // PointerType <- TypeName ASTERISK+
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(77);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(56);
    // => TypeName ASTERISK+ # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => TypeName ASTERISK+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => TypeName
          $$ = _parse_TypeName();
          // <= TypeName
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ASTERISK+
          var testing0;
          for (var first = true, reps; ;) {
            // => ASTERISK
            $$ = _parse_ASTERISK();
            // <= ASTERISK
            if (success) {
             if (first) {
                first = false;
                reps = [$$];
                testing0 = _testing;
              } else {
                reps.add($$);
              }
              _testing = _cursor;
            } else {
              success = !first;
              if (success) {
                _testing = testing0;
                $$ = reps;
              } else $$ = null;
              break;
            }
          }
          // <= ASTERISK+
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // TypeName
            final $1 = seq[0];
            // ASTERISK+
            final $2 = seq[1];
            $$ = _createPointer($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TypeName ASTERISK+ # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: PointerType
      _failure(_expect70);
    }
    // <= TypeName ASTERISK+ # Choice
    _addToCache($$, pos, 77);
    _endToken();
    return $$;
  }

  dynamic _parse_PointerVariableDeclaration() {
    // LEXEME
    // PointerVariableDeclaration <- PointerType IDENTIFIER
    var $$;
    // => PointerType IDENTIFIER # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => PointerType IDENTIFIER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => PointerType
          $$ = _parse_PointerType();
          // <= PointerType
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // PointerType
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            $$ = new VariableDeclaration(name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerType IDENTIFIER # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: PointerVariableDeclaration
      _failure(_expect17);
    }
    // <= PointerType IDENTIFIER # Choice
    return $$;
  }

  dynamic _parse_ReservedWord() {
    // MORPHEME
    // ReservedWord <- ('signed' / 'unsigned' / 'char' / 'int' / 'short' / 'long' / 'float' / 'double' / 'enum' / 'struct' / 'typedef' / 'union' / 'void') !(IDENT_START / IDENT_CONT)
    var $$;
    _beginToken(57);
    // => ('signed' / 'unsigned' / 'char' / 'int' / 'short' / 'long' / 'float' / 'double' / 'enum' / 'struct' / 'typedef' / 'union' / 'void') !(IDENT_START / IDENT_CONT) # Choice
    switch (_getState(_transitions14)) {
      // [c-f] [i] [l] [s-v]
      case 0:
        // => ('signed' / 'unsigned' / 'char' / 'int' / 'short' / 'long' / 'float' / 'double' / 'enum' / 'struct' / 'typedef' / 'union' / 'void') !(IDENT_START / IDENT_CONT) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => ('signed' / 'unsigned' / 'char' / 'int' / 'short' / 'long' / 'float' / 'double' / 'enum' / 'struct' / 'typedef' / 'union' / 'void') # Choice
          switch (_getState(_transitions15)) {
            // [c]
            case 0:
              var startPos1 = _startPos;
              // => 'char'
              $$ = _matchString(_strings8, 'char');
              // <= 'char'
              _startPos = startPos1;
              break;
            // [d]
            case 1:
              var startPos2 = _startPos;
              // => 'double'
              $$ = _matchString(_strings9, 'double');
              // <= 'double'
              _startPos = startPos2;
              break;
            // [e]
            case 2:
              var startPos3 = _startPos;
              // => 'enum'
              $$ = _matchString(_strings10, 'enum');
              // <= 'enum'
              _startPos = startPos3;
              break;
            // [f]
            case 3:
              var startPos4 = _startPos;
              // => 'float'
              $$ = _matchString(_strings11, 'float');
              // <= 'float'
              _startPos = startPos4;
              break;
            // [i]
            case 4:
              var startPos5 = _startPos;
              // => 'int'
              $$ = _matchString(_strings12, 'int');
              // <= 'int'
              _startPos = startPos5;
              break;
            // [l]
            case 5:
              var startPos6 = _startPos;
              // => 'long'
              $$ = _matchString(_strings13, 'long');
              // <= 'long'
              _startPos = startPos6;
              break;
            // [s]
            case 6:
              while (true) {
                var startPos7 = _startPos;
                // => 'signed'
                $$ = _matchString(_strings15, 'signed');
                // <= 'signed'
                _startPos = startPos7;
                if (success) break;
                var startPos8 = _startPos;
                // => 'short'
                $$ = _matchString(_strings14, 'short');
                // <= 'short'
                _startPos = startPos8;
                if (success) break;
                var startPos9 = _startPos;
                // => 'struct'
                $$ = _matchString(_strings0, 'struct');
                // <= 'struct'
                _startPos = startPos9;
                break;
              }
              break;
            // [t]
            case 7:
              var startPos10 = _startPos;
              // => 'typedef'
              $$ = _matchString(_strings2, 'typedef');
              // <= 'typedef'
              _startPos = startPos10;
              break;
            // [u]
            case 8:
              while (true) {
                var startPos11 = _startPos;
                // => 'unsigned'
                $$ = _matchString(_strings16, 'unsigned');
                // <= 'unsigned'
                _startPos = startPos11;
                if (success) break;
                var startPos12 = _startPos;
                // => 'union'
                $$ = _matchString(_strings1, 'union');
                // <= 'union'
                _startPos = startPos12;
                break;
              }
              break;
            // [v]
            case 9:
              var startPos13 = _startPos;
              // => 'void'
              $$ = _matchString(_strings17, 'void');
              // <= 'void'
              _startPos = startPos13;
              break;
            // No matches
            // EOF
            case 10:
            case 11:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: signed, unsigned, char, int, short, long, float, double, enum, struct, typedef, union, void
            _failure(_expect72);
          }
          // <= ('signed' / 'unsigned' / 'char' / 'int' / 'short' / 'long' / 'float' / 'double' / 'enum' / 'struct' / 'typedef' / 'union' / 'void') # Choice
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => !(IDENT_START / IDENT_CONT)
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing;
          _testing = _inputLen + 1;
          // => (IDENT_START / IDENT_CONT) # Choice
          switch (_getState(_transitions13)) {
            // [0-9]
            case 0:
              var startPos14 = _startPos;
              // => IDENT_CONT
              $$ = _parse_IDENT_CONT();
              // <= IDENT_CONT
              _startPos = startPos14;
              break;
            // [A-Z] [_] [a-z]
            case 1:
              while (true) {
                var startPos15 = _startPos;
                // => IDENT_START
                $$ = _parse_IDENT_START();
                // <= IDENT_START
                _startPos = startPos15;
                if (success) break;
                var startPos16 = _startPos;
                // => IDENT_CONT
                $$ = _parse_IDENT_CONT();
                // <= IDENT_CONT
                _startPos = startPos16;
                break;
              }
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: IDENT_START, IDENT_CONT
            _failure(_expect73);
          }
          // <= (IDENT_START / IDENT_CONT) # Choice
          _ch = ch1;
          _cursor = pos1;
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !(IDENT_START / IDENT_CONT)
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // ('signed' / 'unsigned' / 'char' / 'int' / 'short' / 'long' / 'float' / 'double' / 'enum' / 'struct' / 'typedef' / 'union' / 'void')
            final $1 = seq[0];
            // !(IDENT_START / IDENT_CONT)
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('signed' / 'unsigned' / 'char' / 'int' / 'short' / 'long' / 'float' / 'double' / 'enum' / 'struct' / 'typedef' / 'union' / 'void') !(IDENT_START / IDENT_CONT) # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ReservedWord
      _failure(_expect71);
    }
    // <= ('signed' / 'unsigned' / 'char' / 'int' / 'short' / 'long' / 'float' / 'double' / 'enum' / 'struct' / 'typedef' / 'union' / 'void') !(IDENT_START / IDENT_CONT) # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_SEMICOLON() {
    // LEXEME
    // SEMICOLON <- ';' SPACING
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(23);
    }
    if($$ != null) {
      return $$[0];
    }
    // => ';' SPACING # Choice
    switch (_ch == 59 ? 0 : _ch == -1 ? 2 : 1) {
      // [;]
      case 0:
        // => ';' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => ';'
          $$ = ';';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ';'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // ';'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ';' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ';'
      _failure(_expect18);
    }
    // <= ';' SPACING # Choice
    _addToCache($$, pos, 23);
    return $$;
  }

  dynamic _parse_SIGN() {
    // MORPHEME
    // SIGN <- (PLUS / MINUS)?
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(79);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(58);
    // => (PLUS / MINUS)? # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => (PLUS / MINUS)?
        var testing0 = _testing;
        _testing = _cursor;
        // => (PLUS / MINUS) # Choice
        switch (_getState(_transitions16)) {
          // [+]
          case 0:
            var startPos1 = _startPos;
            // => PLUS
            $$ = _parse_PLUS();
            // <= PLUS
            _startPos = startPos1;
            break;
          // [-]
          case 1:
            var startPos2 = _startPos;
            // => MINUS
            $$ = _parse_MINUS();
            // <= MINUS
            _startPos = startPos2;
            break;
          // No matches
          // EOF
          case 2:
          case 3:
            $$ = null;
            success = false;
            break;
        }
        if (!success && _cursor > _testing) {
          // Expected: '+', '-'
          _failure(_expect75);
        }
        // <= (PLUS / MINUS) # Choice
        success = true;
        _testing = testing0;
        // <= (PLUS / MINUS)?
        if (success) {
          // (PLUS / MINUS)?
          final $1 = $$;
          $$ = $1 == "-" ? -1 : 1;
        }
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SIGN
      _failure(_expect74);
    }
    // <= (PLUS / MINUS)? # Choice
    _addToCache($$, pos, 79);
    _endToken();
    return $$;
  }

  dynamic _parse_SPACE() {
    // MORPHEME
    // SPACE <- [\t-\n\r ]
    var $$;
    _beginToken(59);
    // => [\t-\n\r ] # Choice
    switch (_getState(_transitions17)) {
      // [\t-\n] [\r] [ ]
      case 0:
        var startPos0 = _startPos;
        // => [\t-\n\r ]
        $$ = _matchMapping(9, 32, _mapping2);
        // <= [\t-\n\r ]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SPACE
      _failure(_expect76);
    }
    // <= [\t-\n\r ] # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_SPACING() {
    // LEXEME & MORPHEME
    // SPACING <- (SPACE / COMMENT)*
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(24);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(7);
    // => (SPACE / COMMENT)* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => (SPACE / COMMENT)*
        var testing0 = _testing;
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => (SPACE / COMMENT) # Choice
          switch (_getState(_transitions9)) {
            // [\t-\n] [\r] [ ]
            case 0:
              var startPos1 = _startPos;
              // => SPACE
              $$ = _parse_SPACE();
              // <= SPACE
              _startPos = startPos1;
              break;
            // [/]
            case 1:
              var startPos2 = _startPos;
              // => COMMENT
              $$ = _parse_COMMENT();
              // <= COMMENT
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: SPACE, '//'
            _failure(_expect20);
          }
          // <= (SPACE / COMMENT) # Choice
          if (success) {
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break;
          }
        }
        // <= (SPACE / COMMENT)*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SPACING
      _failure(_expect19);
    }
    // <= (SPACE / COMMENT)* # Choice
    _addToCache($$, pos, 24);
    _endToken();
    return $$;
  }

  dynamic _parse_SimpleParameter() {
    // MORPHEME
    // SimpleParameter <- Type IDENTIFIER?
    var $$;
    _beginToken(60);
    // => Type IDENTIFIER? # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true;
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // Type
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            $$ = new ParameterDeclaration(name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SimpleParameter
      _failure(_expect77);
    }
    // <= Type IDENTIFIER? # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_SimpleVariableDeclaration() {
    // LEXEME
    // SimpleVariableDeclaration <- Type IDENTIFIER
    var $$;
    // => Type IDENTIFIER # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // Type
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            $$ = new VariableDeclaration(name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SimpleVariableDeclaration
      _failure(_expect21);
    }
    // <= Type IDENTIFIER # Choice
    return $$;
  }

  dynamic _parse_StructDeclaration() {
    // NONTERMINAL
    // StructDeclaration <- (ID_STRUCT / ID_UNION) IDENTIFIER? OPEN_BRACE StructMemberList? CLOSE_BRACE
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(7);
    }
    if($$ != null) {
      return $$[0];
    }
    // => (ID_STRUCT / ID_UNION) IDENTIFIER? OPEN_BRACE StructMemberList? CLOSE_BRACE # Choice
    switch (_getState(_transitions4)) {
      // [s] [u]
      case 0:
        // => (ID_STRUCT / ID_UNION) IDENTIFIER? OPEN_BRACE StructMemberList? CLOSE_BRACE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => (ID_STRUCT / ID_UNION) # Choice
          switch (_getState(_transitions5)) {
            // [s]
            case 0:
              var startPos1 = _startPos;
              // => ID_STRUCT
              $$ = _parse_ID_STRUCT();
              // <= ID_STRUCT
              _startPos = startPos1;
              break;
            // [u]
            case 1:
              var startPos2 = _startPos;
              // => ID_UNION
              $$ = _parse_ID_UNION();
              // <= ID_UNION
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'struct', 'union'
            _failure(_expect6);
          }
          // <= (ID_STRUCT / ID_UNION) # Choice
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true;
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          // => OPEN_BRACE
          $$ = _parse_OPEN_BRACE();
          // <= OPEN_BRACE
          if (!success) break;
          seq[2] = $$;
          // => StructMemberList?
          var testing1 = _testing;
          _testing = _cursor;
          // => StructMemberList
          $$ = _parse_StructMemberList();
          // <= StructMemberList
          success = true;
          _testing = testing1;
          // <= StructMemberList?
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_BRACE
          $$ = _parse_CLOSE_BRACE();
          // <= CLOSE_BRACE
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          if (success) {
            // (ID_STRUCT / ID_UNION)
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            // OPEN_BRACE
            final $3 = seq[2];
            // StructMemberList?
            final $4 = seq[3];
            // CLOSE_BRACE
            final $5 = seq[4];
            $$ = new StructureDeclaration(kind: $1, members: $4, tag: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (ID_STRUCT / ID_UNION) IDENTIFIER? OPEN_BRACE StructMemberList? CLOSE_BRACE # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union'
      _failure(_expect6);
    }
    // <= (ID_STRUCT / ID_UNION) IDENTIFIER? OPEN_BRACE StructMemberList? CLOSE_BRACE # Choice
    _addToCache($$, pos, 7);
    return $$;
  }

  dynamic _parse_StructMember() {
    // NONTERMINAL
    // StructMember <- VariableDeclaration SEMICOLON
    var $$;
    // => VariableDeclaration SEMICOLON # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => VariableDeclaration SEMICOLON # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => VariableDeclaration
          $$ = _parse_VariableDeclaration();
          // <= VariableDeclaration
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SEMICOLON
          $$ = _parse_SEMICOLON();
          // <= SEMICOLON
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // VariableDeclaration
            final $1 = seq[0];
            // SEMICOLON
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= VariableDeclaration SEMICOLON # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ArrayVariableDeclaration, 'enum', PointerVariableDeclaration, SimpleVariableDeclaration, 'struct', 'union'
      _failure(_expect7);
    }
    // <= VariableDeclaration SEMICOLON # Choice
    return $$;
  }

  dynamic _parse_StructMemberList() {
    // NONTERMINAL
    // StructMemberList <- (StructMember)*
    var $$;
    // => (StructMember)* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        var startPos0 = _startPos;
        // => (StructMember)*
        var testing0 = _testing;
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => (StructMember) # Choice
          switch (_getState(_transitions6)) {
            // [A-Z] [_] [a-z]
            // EOF
            case 0:
            case 2:
              var startPos1 = _startPos;
              // => StructMember
              $$ = _parse_StructMember();
              // <= StructMember
              _startPos = startPos1;
              break;
            // No matches
            case 1:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: ArrayVariableDeclaration, 'enum', PointerVariableDeclaration, SimpleVariableDeclaration, 'struct', 'union'
            _failure(_expect7);
          }
          // <= (StructMember) # Choice
          if (success) {
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break;
          }
        }
        // <= (StructMember)*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
      // EOF
      case 2:
        while (true) {
          var startPos2 = _startPos;
          // => (StructMember)*
          var testing1 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (StructMember) # Choice
            switch (_getState(_transitions6)) {
              // [A-Z] [_] [a-z]
              // EOF
              case 0:
              case 2:
                var startPos3 = _startPos;
                // => StructMember
                $$ = _parse_StructMember();
                // <= StructMember
                _startPos = startPos3;
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ArrayVariableDeclaration, 'enum', PointerVariableDeclaration, SimpleVariableDeclaration, 'struct', 'union'
              _failure(_expect7);
            }
            // <= (StructMember) # Choice
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break;
            }
          }
          // <= (StructMember)*
          _startPos = startPos2;
          if (success) break;
          var startPos4 = _startPos;
          // => (StructMember)*
          var testing2 = _testing;
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (StructMember) # Choice
            switch (_getState(_transitions6)) {
              // [A-Z] [_] [a-z]
              // EOF
              case 0:
              case 2:
                var startPos5 = _startPos;
                // => StructMember
                $$ = _parse_StructMember();
                // <= StructMember
                _startPos = startPos5;
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ArrayVariableDeclaration, 'enum', PointerVariableDeclaration, SimpleVariableDeclaration, 'struct', 'union'
              _failure(_expect7);
            }
            // <= (StructMember) # Choice
            if (success) {
              reps.add($$);
            } else {
              success = true;
              _testing = testing2;
              $$ = reps;
              break;
            }
          }
          // <= (StructMember)*
          _startPos = startPos4;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected:
      _failure(_expect1);
    }
    // <= (StructMember)* # Choice
    return $$;
  }

  dynamic _parse_TYPEDEF() {
    // LEXEME
    // TYPEDEF <- 'typedef' SPACING
    var $$;
    // => 'typedef' SPACING # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => 'typedef' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => 'typedef'
          $$ = _matchString(_strings2, 'typedef');
          // <= 'typedef'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // 'typedef'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'typedef' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'typedef'
      _failure(_expect3);
    }
    // <= 'typedef' SPACING # Choice
    return $$;
  }

  dynamic _parse_TaggedTypeDeclaration() {
    // NONTERMINAL
    // TaggedTypeDeclaration <- StructDeclaration / EnumDeclaration
    var $$;
    // => StructDeclaration / EnumDeclaration # Choice
    switch (_getState(_transitions3)) {
      // [e]
      case 0:
        var startPos0 = _startPos;
        // => EnumDeclaration
        $$ = _parse_EnumDeclaration();
        // <= EnumDeclaration
        _startPos = startPos0;
        break;
      // [s] [u]
      case 1:
        var startPos1 = _startPos;
        // => StructDeclaration
        $$ = _parse_StructDeclaration();
        // <= StructDeclaration
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union', 'enum'
      _failure(_expect5);
    }
    // <= StructDeclaration / EnumDeclaration # Choice
    return $$;
  }

  dynamic _parse_TaggedTypeVariableDeclaration() {
    // NONTERMINAL
    // TaggedTypeVariableDeclaration <- (StructDeclaration / EnumDeclaration) IDENTIFIER
    var $$;
    // => (StructDeclaration / EnumDeclaration) IDENTIFIER # Choice
    switch (_getState(_transitions8)) {
      // [e] [s] [u]
      case 0:
        // => (StructDeclaration / EnumDeclaration) IDENTIFIER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => (StructDeclaration / EnumDeclaration) # Choice
          switch (_getState(_transitions3)) {
            // [e]
            case 0:
              var startPos1 = _startPos;
              // => EnumDeclaration
              $$ = _parse_EnumDeclaration();
              // <= EnumDeclaration
              _startPos = startPos1;
              break;
            // [s] [u]
            case 1:
              var startPos2 = _startPos;
              // => StructDeclaration
              $$ = _parse_StructDeclaration();
              // <= StructDeclaration
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'enum', 'struct', 'union'
            _failure(_expect5);
          }
          // <= (StructDeclaration / EnumDeclaration) # Choice
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // (StructDeclaration / EnumDeclaration)
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            $$ = new VariableDeclaration(name: $2, type: $1.type);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (StructDeclaration / EnumDeclaration) IDENTIFIER # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum', 'struct', 'union'
      _failure(_expect5);
    }
    // <= (StructDeclaration / EnumDeclaration) IDENTIFIER # Choice
    return $$;
  }

  dynamic _parse_Type() {
    // MORPHEME
    // Type <- PointerType / ArrayType / TypeName
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(82);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(61);
    // => PointerType / ArrayType / TypeName # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          var startPos0 = _startPos;
          // => PointerType
          $$ = _parse_PointerType();
          // <= PointerType
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => ArrayType
          $$ = _parse_ArrayType();
          // <= ArrayType
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => TypeName
          $$ = _parse_TypeName();
          // <= TypeName
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: Type
      _failure(_expect78);
    }
    // <= PointerType / ArrayType / TypeName # Choice
    _addToCache($$, pos, 82);
    _endToken();
    return $$;
  }

  dynamic _parse_TypeName() {
    // MORPHEME
    // TypeName <- IDENTIFIER / TypeSign? (ID_CHAR / ID_INT) / TypeSign? (ID_SHORT / LongType) ID_INT? / ID_FLOAT / ID_DOUBLE / ID_ENUM IDENTIFIER / ID_STRUCT IDENTIFIER / ID_UNION IDENTIFIER / ID_VOID
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(83);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(62);
    // => IDENTIFIER / TypeSign? (ID_CHAR / ID_INT) / TypeSign? (ID_SHORT / LongType) ID_INT? / ID_FLOAT / ID_DOUBLE / ID_ENUM IDENTIFIER / ID_STRUCT IDENTIFIER / ID_UNION IDENTIFIER / ID_VOID # Choice
    switch (_getState(_transitions7)) {
      // [A-Z] [_]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => IDENTIFIER
        $$ = _parse_IDENTIFIER();
        // <= IDENTIFIER
        if (success) {
          // IDENTIFIER
          final $1 = $$;
          $$ = new TypedefTypeSpecification(name: $1);
        }
        _startPos = startPos0;
        break;
      // [a-z]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (success) {
            // IDENTIFIER
            final $1 = $$;
            $$ = new TypedefTypeSpecification(name: $1);
          }
          _startPos = startPos1;
          if (success) break;
          // => TypeSign? (ID_CHAR / ID_INT) # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => TypeSign?
            var testing0 = _testing;
            _testing = _cursor;
            // => TypeSign
            $$ = _parse_TypeSign();
            // <= TypeSign
            success = true;
            _testing = testing0;
            // <= TypeSign?
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => (ID_CHAR / ID_INT) # Choice
            switch (_getState(_transitions18)) {
              // [c]
              case 0:
                var startPos3 = _startPos;
                // => ID_CHAR
                $$ = _parse_ID_CHAR();
                // <= ID_CHAR
                _startPos = startPos3;
                break;
              // [i]
              case 1:
                var startPos4 = _startPos;
                // => ID_INT
                $$ = _parse_ID_INT();
                // <= ID_INT
                _startPos = startPos4;
                break;
              // No matches
              // EOF
              case 2:
              case 3:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'char', 'int'
              _failure(_expect80);
            }
            // <= (ID_CHAR / ID_INT) # Choice
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // TypeSign?
              final $1 = seq[0];
              // (ID_CHAR / ID_INT)
              final $2 = seq[1];
              $$ = new IntegerTypeSpecification(name: _createInt([$1, $2]));
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos2;
          // <= TypeSign? (ID_CHAR / ID_INT) # Sequence
          if (success) break;
          // => TypeSign? (ID_SHORT / LongType) ID_INT? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => TypeSign?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeSign
            $$ = _parse_TypeSign();
            // <= TypeSign
            success = true;
            _testing = testing1;
            // <= TypeSign?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => (ID_SHORT / LongType) # Choice
            switch (_getState(_transitions19)) {
              // [l]
              case 0:
                var startPos6 = _startPos;
                // => LongType
                $$ = _parse_LongType();
                // <= LongType
                _startPos = startPos6;
                break;
              // [s]
              case 1:
                var startPos7 = _startPos;
                // => ID_SHORT
                $$ = _parse_ID_SHORT();
                // <= ID_SHORT
                _startPos = startPos7;
                break;
              // No matches
              // EOF
              case 2:
              case 3:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'short', 'long'
              _failure(_expect81);
            }
            // <= (ID_SHORT / LongType) # Choice
            if (!success) break;
            seq[1] = $$;
            // => ID_INT?
            var testing2 = _testing;
            _testing = _cursor;
            // => ID_INT
            $$ = _parse_ID_INT();
            // <= ID_INT
            success = true;
            _testing = testing2;
            // <= ID_INT?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {
              // TypeSign?
              final $1 = seq[0];
              // (ID_SHORT / LongType)
              final $2 = seq[1];
              // ID_INT?
              final $3 = seq[2];
              $$ = new IntegerTypeSpecification(name: _createInt([$1, $2, $3]));
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos5;
          // <= TypeSign? (ID_SHORT / LongType) ID_INT? # Sequence
          if (success) break;
          var startPos8 = _startPos;
          // => ID_FLOAT
          $$ = _parse_ID_FLOAT();
          // <= ID_FLOAT
          if (success) {
            // ID_FLOAT
            final $1 = $$;
            $$ = new FloatTypeSpecification(kind: "float");
          }
          _startPos = startPos8;
          if (success) break;
          var startPos9 = _startPos;
          // => ID_DOUBLE
          $$ = _parse_ID_DOUBLE();
          // <= ID_DOUBLE
          if (success) {
            // ID_DOUBLE
            final $1 = $$;
            $$ = new FloatTypeSpecification(kind: "double");
          }
          _startPos = startPos9;
          if (success) break;
          // => ID_ENUM IDENTIFIER # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos10 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => ID_ENUM
            $$ = _parse_ID_ENUM();
            // <= ID_ENUM
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => IDENTIFIER
            $$ = _parse_IDENTIFIER();
            // <= IDENTIFIER
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // ID_ENUM
              final $1 = seq[0];
              // IDENTIFIER
              final $2 = seq[1];
              $$ = new TaggedTypeSpecification(kind: "enum", tag: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos10;
          // <= ID_ENUM IDENTIFIER # Sequence
          if (success) break;
          // => ID_STRUCT IDENTIFIER # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos11 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => ID_STRUCT
            $$ = _parse_ID_STRUCT();
            // <= ID_STRUCT
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => IDENTIFIER
            $$ = _parse_IDENTIFIER();
            // <= IDENTIFIER
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // ID_STRUCT
              final $1 = seq[0];
              // IDENTIFIER
              final $2 = seq[1];
              $$ = new TaggedTypeSpecification(kind: "struct", tag: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos11;
          // <= ID_STRUCT IDENTIFIER # Sequence
          if (success) break;
          // => ID_UNION IDENTIFIER # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos12 = _startPos;
          _startPos = _cursor;
          while (true) {
            // => ID_UNION
            $$ = _parse_ID_UNION();
            // <= ID_UNION
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => IDENTIFIER
            $$ = _parse_IDENTIFIER();
            // <= IDENTIFIER
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {
              // ID_UNION
              final $1 = seq[0];
              // IDENTIFIER
              final $2 = seq[1];
              $$ = new TaggedTypeSpecification(kind: "union", tag: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos12;
          // <= ID_UNION IDENTIFIER # Sequence
          if (success) break;
          var startPos13 = _startPos;
          // => ID_VOID
          $$ = _parse_ID_VOID();
          // <= ID_VOID
          if (success) {
            // ID_VOID
            final $1 = $$;
            $$ = new VoidTypeSpecification();
          }
          _startPos = startPos13;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: TypeName
      _failure(_expect79);
    }
    // <= IDENTIFIER / TypeSign? (ID_CHAR / ID_INT) / TypeSign? (ID_SHORT / LongType) ID_INT? / ID_FLOAT / ID_DOUBLE / ID_ENUM IDENTIFIER / ID_STRUCT IDENTIFIER / ID_UNION IDENTIFIER / ID_VOID # Choice
    _addToCache($$, pos, 83);
    _endToken();
    return $$;
  }

  dynamic _parse_TypeSign() {
    // MORPHEME
    // TypeSign <- ID_SIGNED / ID_UNSIGNED
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(84);
    }
    if($$ != null) {
      return $$[0];
    }
    _beginToken(63);
    // => ID_SIGNED / ID_UNSIGNED # Choice
    switch (_getState(_transitions5)) {
      // [s]
      case 0:
        var startPos0 = _startPos;
        // => ID_SIGNED
        $$ = _parse_ID_SIGNED();
        // <= ID_SIGNED
        _startPos = startPos0;
        break;
      // [u]
      case 1:
        var startPos1 = _startPos;
        // => ID_UNSIGNED
        $$ = _parse_ID_UNSIGNED();
        // <= ID_UNSIGNED
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: TypeSign
      _failure(_expect82);
    }
    // <= ID_SIGNED / ID_UNSIGNED # Choice
    _addToCache($$, pos, 84);
    _endToken();
    return $$;
  }

  dynamic _parse_TypedefArrayTypeDeclaration() {
    // LEXEME
    // TypedefArrayTypeDeclaration <- Attributes? Type IDENTIFIER DIMENSIONS
    var $$;
    // => Attributes? Type IDENTIFIER DIMENSIONS # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Attributes? Type IDENTIFIER DIMENSIONS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => Attributes?
          var testing0 = _testing;
          _testing = _cursor;
          // => Attributes
          $$ = _parse_Attributes();
          // <= Attributes
          success = true;
          _testing = testing0;
          // <= Attributes?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          seq[1] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[2] = $$;
          // => DIMENSIONS
          $$ = _parse_DIMENSIONS();
          // <= DIMENSIONS
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {
            // Attributes?
            final $1 = seq[0];
            // Type
            final $2 = seq[1];
            // IDENTIFIER
            final $3 = seq[2];
            // DIMENSIONS
            final $4 = seq[3];
            $$ = new TypedefDeclaration(name: $3,type: _createArray($2, $4));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Attributes? Type IDENTIFIER DIMENSIONS # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: TypedefArrayTypeDeclaration
      _failure(_expect22);
    }
    // <= Attributes? Type IDENTIFIER DIMENSIONS # Choice
    return $$;
  }

  dynamic _parse_TypedefDeclaration() {
    // NONTERMINAL
    // TypedefDeclaration <- TYPEDEF TypedefTypeDeclaration
    var $$;
    // => TYPEDEF TypedefTypeDeclaration # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => TYPEDEF TypedefTypeDeclaration # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => TYPEDEF
          $$ = _parse_TYPEDEF();
          // <= TYPEDEF
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => TypedefTypeDeclaration
          $$ = _parse_TypedefTypeDeclaration();
          // <= TypedefTypeDeclaration
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // TYPEDEF
            final $1 = seq[0];
            // TypedefTypeDeclaration
            final $2 = seq[1];
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TYPEDEF TypedefTypeDeclaration # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'typedef'
      _failure(_expect3);
    }
    // <= TYPEDEF TypedefTypeDeclaration # Choice
    return $$;
  }

  dynamic _parse_TypedefSimpleTypeDeclaration() {
    // LEXEME
    // TypedefSimpleTypeDeclaration <- Attributes? Type IDENTIFIER
    var $$;
    // => Attributes? Type IDENTIFIER # Choice
    switch (_getState(_transitions6)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Attributes? Type IDENTIFIER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => Attributes?
          var testing0 = _testing;
          _testing = _cursor;
          // => Attributes
          $$ = _parse_Attributes();
          // <= Attributes
          success = true;
          _testing = testing0;
          // <= Attributes?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          seq[1] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // Attributes?
            final $1 = seq[0];
            // Type
            final $2 = seq[1];
            // IDENTIFIER
            final $3 = seq[2];
            $$ = new TypedefDeclaration(attributes: $1, name: $3, type: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Attributes? Type IDENTIFIER # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: TypedefSimpleTypeDeclaration
      _failure(_expect23);
    }
    // <= Attributes? Type IDENTIFIER # Choice
    return $$;
  }

  dynamic _parse_TypedefTaggedTypeDeclaration() {
    // NONTERMINAL
    // TypedefTaggedTypeDeclaration <- Attributes? TaggedTypeDeclaration IDENTIFIER
    var $$;
    // => Attributes? TaggedTypeDeclaration IDENTIFIER # Choice
    switch (_getState(_transitions2)) {
      // [_] [e] [s] [u]
      case 0:
        // => Attributes? TaggedTypeDeclaration IDENTIFIER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => Attributes?
          var testing0 = _testing;
          _testing = _cursor;
          // => Attributes
          $$ = _parse_Attributes();
          // <= Attributes
          success = true;
          _testing = testing0;
          // <= Attributes?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => TaggedTypeDeclaration
          $$ = _parse_TaggedTypeDeclaration();
          // <= TaggedTypeDeclaration
          if (!success) break;
          seq[1] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // Attributes?
            final $1 = seq[0];
            // TaggedTypeDeclaration
            final $2 = seq[1];
            // IDENTIFIER
            final $3 = seq[2];
            $$ = new TypedefDeclaration(name: $3, type: $2.type);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Attributes? TaggedTypeDeclaration IDENTIFIER # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union', 'enum'
      _failure(_expect5);
    }
    // <= Attributes? TaggedTypeDeclaration IDENTIFIER # Choice
    return $$;
  }

  dynamic _parse_TypedefTypeDeclaration() {
    // NONTERMINAL
    // TypedefTypeDeclaration <- TypedefArrayTypeDeclaration / TypedefTaggedTypeDeclaration / TypedefSimpleTypeDeclaration
    var $$;
    // => TypedefArrayTypeDeclaration / TypedefTaggedTypeDeclaration / TypedefSimpleTypeDeclaration # Choice
    switch (_getState(_transitions1)) {
      // [A-Z]
      // EOF
      case 0:
      case 3:
        while (true) {
          var startPos0 = _startPos;
          // => TypedefArrayTypeDeclaration
          $$ = _parse_TypedefArrayTypeDeclaration();
          // <= TypedefArrayTypeDeclaration
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => TypedefSimpleTypeDeclaration
          $$ = _parse_TypedefSimpleTypeDeclaration();
          // <= TypedefSimpleTypeDeclaration
          _startPos = startPos1;
          break;
        }
        break;
      // [_] [a-z]
      case 1:
        while (true) {
          var startPos2 = _startPos;
          // => TypedefArrayTypeDeclaration
          $$ = _parse_TypedefArrayTypeDeclaration();
          // <= TypedefArrayTypeDeclaration
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          // => TypedefTaggedTypeDeclaration
          $$ = _parse_TypedefTaggedTypeDeclaration();
          // <= TypedefTaggedTypeDeclaration
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          // => TypedefSimpleTypeDeclaration
          $$ = _parse_TypedefSimpleTypeDeclaration();
          // <= TypedefSimpleTypeDeclaration
          _startPos = startPos4;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: TypedefArrayTypeDeclaration, 'struct', 'union', 'enum', TypedefSimpleTypeDeclaration
      _failure(_expect4);
    }
    // <= TypedefArrayTypeDeclaration / TypedefTaggedTypeDeclaration / TypedefSimpleTypeDeclaration # Choice
    return $$;
  }

  dynamic _parse_VaListParameter() {
    // MORPHEME
    // VaListParameter <- ELLIPSIS
    var $$;
    _beginToken(64);
    // => ELLIPSIS # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        var startPos0 = _startPos;
        // => ELLIPSIS
        $$ = _parse_ELLIPSIS();
        // <= ELLIPSIS
        if (success) {
          // ELLIPSIS
          final $1 = $$;
          $$ = new ParameterDeclaration(type: new VaListTypeSpecification());
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '...'
      _failure(_expect43);
    }
    // <= ELLIPSIS # Choice
    _endToken();
    return $$;
  }

  dynamic _parse_VariableDeclaration() {
    // NONTERMINAL
    // VariableDeclaration <- ArrayVariableDeclaration / TaggedTypeVariableDeclaration / PointerVariableDeclaration / SimpleVariableDeclaration
    var $$;
    var pos = _cursor;
    if(pos <= _cachePos) {
      $$ = _getFromCache(10);
    }
    if($$ != null) {
      return $$[0];
    }
    // => ArrayVariableDeclaration / TaggedTypeVariableDeclaration / PointerVariableDeclaration / SimpleVariableDeclaration # Choice
    switch (_getState(_transitions7)) {
      // [A-Z] [_]
      // EOF
      case 0:
      case 3:
        while (true) {
          var startPos0 = _startPos;
          // => ArrayVariableDeclaration
          $$ = _parse_ArrayVariableDeclaration();
          // <= ArrayVariableDeclaration
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => PointerVariableDeclaration
          $$ = _parse_PointerVariableDeclaration();
          // <= PointerVariableDeclaration
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => SimpleVariableDeclaration
          $$ = _parse_SimpleVariableDeclaration();
          // <= SimpleVariableDeclaration
          _startPos = startPos2;
          break;
        }
        break;
      // [a-z]
      case 1:
        while (true) {
          var startPos3 = _startPos;
          // => ArrayVariableDeclaration
          $$ = _parse_ArrayVariableDeclaration();
          // <= ArrayVariableDeclaration
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          // => TaggedTypeVariableDeclaration
          $$ = _parse_TaggedTypeVariableDeclaration();
          // <= TaggedTypeVariableDeclaration
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          // => PointerVariableDeclaration
          $$ = _parse_PointerVariableDeclaration();
          // <= PointerVariableDeclaration
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          // => SimpleVariableDeclaration
          $$ = _parse_SimpleVariableDeclaration();
          // <= SimpleVariableDeclaration
          _startPos = startPos6;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ArrayVariableDeclaration, 'enum', PointerVariableDeclaration, SimpleVariableDeclaration, 'struct', 'union'
      _failure(_expect7);
    }
    // <= ArrayVariableDeclaration / TaggedTypeVariableDeclaration / PointerVariableDeclaration / SimpleVariableDeclaration # Choice
    _addToCache($$, pos, 10);
    return $$;
  }

  dynamic _parse_ZERO() {
    // MORPHEME
    // ZERO <- [0]+ ![0-9]+
    var $$;
    _beginToken(65);
    // => [0]+ ![0-9]+ # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => [0]+ ![0-9]+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => [0]+
          var testing0;
          for (var first = true, reps; ;) {
            // => [0]
            $$ = _matchChar(48, '0');
            // <= [0]
            if (success) {
             if (first) {
                first = false;
                reps = [$$];
                testing0 = _testing;
              } else {
                reps.add($$);
              }
              _testing = _cursor;
            } else {
              success = !first;
              if (success) {
                _testing = testing0;
                $$ = reps;
              } else $$ = null;
              break;
            }
          }
          // <= [0]+
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ![0-9]+
          var ch1 = _ch, pos1 = _cursor, testing1 = _testing;
          _testing = _inputLen + 1;
          // => [0-9]+
          var testing2;
          for (var first = true, reps; ;) {
            // => [0-9]
            $$ = _matchRange(48, 57);
            // <= [0-9]
            if (success) {
             if (first) {
                first = false;
                reps = [$$];
                testing2 = _testing;
              } else {
                reps.add($$);
              }
              _testing = _cursor;
            } else {
              success = !first;
              if (success) {
                _testing = testing2;
                $$ = reps;
              } else $$ = null;
              break;
            }
          }
          // <= [0-9]+
          _ch = ch1;
          _cursor = pos1;
          _testing = testing1;
          $$ = null;
          success = !success;
          // <= ![0-9]+
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {
            // [0]+
            final $1 = seq[0];
            // ![0-9]+
            final $2 = seq[1];
            $$ = 0;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= [0]+ ![0-9]+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ZERO
      _failure(_expect83);
    }
    // <= [0]+ ![0-9]+ # Choice
    _endToken();
    return $$;
  }

  String _text() {
    return new String.fromCharCodes(_input.sublist(_startPos, _cursor));
  }

  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }

    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }

    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }

    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }

    return start;
  }

  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }

    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }

    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }

    codePoints.length = pos;
    return codePoints;
  }

  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }

  List<CParserError> errors() {
    if (success) {
      return <CParserError>[];
    }

    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    }

    String getc(int position) {
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";
      }
      return "end of file";
    }

    var errors = <CParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<CParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new CParserError(CParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {
        var found = getc(_failurePos);
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new CParserError(CParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;
  }

  dynamic parse_Declarations() {
    // NONTERMINAL
    // Declarations <- SPACING? DeclarationList? EOF
    var $$;
    // => SPACING? DeclarationList? EOF # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        // => SPACING? DeclarationList? EOF # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {
          // => SPACING?
          var testing0 = _testing;
          _testing = _cursor;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          success = true;
          _testing = testing0;
          // <= SPACING?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => DeclarationList?
          var testing1 = _testing;
          _testing = _cursor;
          // => DeclarationList
          $$ = _parse_DeclarationList();
          // <= DeclarationList
          success = true;
          _testing = testing1;
          // <= DeclarationList?
          if (!success) break;
          seq[1] = $$;
          // => EOF
          $$ = _parse_EOF();
          // <= EOF
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {
            // SPACING?
            final $1 = seq[0];
            // DeclarationList?
            final $2 = seq[1];
            // EOF
            final $3 = seq[2];
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SPACING? DeclarationList? EOF # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= SPACING? DeclarationList? EOF # Choice
    return $$;
  }

  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }
    _cursor = pos;
    _cache = new List(_inputLen + 1);
    _cachePos = -1;
    _cacheRule = new List(_inputLen + 1);
    _cacheState = new List.filled(((_inputLen + 1) >> 5) + 1, 0);
    _ch = -1;
    _errors = <CParserError>[];
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;
    _testing = -1;
    _token = null;
    _tokenLevel = 0;
    _tokenStart = null;
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;
  }

}

class CParserError {
  static const int EXPECTED = 1;

  static const int MALFORMED = 2;

  static const int MISSING = 3;

  static const int UNEXPECTED = 4;

  static const int UNTERMINATED = 5;

  final int hashCode = 0;

  final String message;

  final int position;

  final int start;

  final int type;

  CParserError(this.type, this.position, this.start, this.message);

  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is CParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;
    }
    return false;
  }

}

