// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

import "package:binary_declarations/binary_declarations.dart";

ArrayTypeSpecification _createArray(TypeSpecification type, List dimensions) {  
  return new ArrayTypeSpecification(dimensions: dimensions, type: type);
}

String _createInt(List parts) {
  var list = [];
  for (var part in parts) {
    if (part != null) {
      list.add(part);
    }
  }

  return list.join(" ");
}

List _createParameters(List parameters, ParameterDeclaration vaList) {    
  var list = <ParameterDeclaration>[];
  list.addAll(parameters);
  if (vaList != null) {
    list.add(vaList);  
  }
  
  return list;
}

PointerTypeSpecification _createPointer(TypeSpecification type, List stars) {    
  for (var star in stars) {
    type = new PointerTypeSpecification(type: type);
  }
  
  return type;
}

int _parseInt(String sign, String digits, int radix) {
  if (sign == null) {
    sign = "";
  }
  return int.parse("$sign$digits", radix: radix);
}

class CParser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));
  
  static final List<String> _expect0 = <String>["EOF"];
  
  static final List<String> _expect1 = <String>[];
  
  static final List<String> _expect10 = <String>["IDENT", "NUMBER"];
  
  static final List<String> _expect11 = <String>["\'struct\'", "\'union\'"];
  
  static final List<String> _expect12 = <String>["\'enum\'"];
  
  static final List<String> _expect13 = <String>["\'[\'"];
  
  static final List<String> _expect14 = <String>["POSITIVE_NUMBER"];
  
  static final List<String> _expect15 = <String>["\'typedef\'"];
  
  static final List<String> _expect16 = <String>["\'enum\'", "\'struct\'", "\'union\'"];
  
  static final List<String> _expect17 = <String>["IDENTIFIER"];
  
  static final List<String> _expect18 = <String>["\'=\'"];
  
  static final List<String> _expect19 = <String>["\'*\'"];
  
  static final List<String> _expect2 = <String>["\';\'", "\'char\'", "\'double\'", "\'enum\'", "\'float\'", "\'int\'", "\'long\'", "\'short\'", "\'struct\'", "\'typedef\'", "\'union\'", "\'void\'", "IDENTIFIER", "SIGNEDNESS"];
  
  static final List<String> _expect20 = <String>["\'char\'"];
  
  static final List<String> _expect21 = <String>["\'}\'"];
  
  static final List<String> _expect22 = <String>["\']\'"];
  
  static final List<String> _expect23 = <String>["\')\'"];
  
  static final List<String> _expect24 = <String>["\':\'"];
  
  static final List<String> _expect25 = <String>["\'const\'"];
  
  static final List<String> _expect26 = <String>["\'double\'"];
  
  static final List<String> _expect27 = <String>["\'float\'"];
  
  static final List<String> _expect28 = <String>["\'int\'"];
  
  static final List<String> _expect29 = <String>["LEADING_SPACES"];
  
  static final List<String> _expect3 = <String>["\'char\'", "\'double\'", "\'enum\'", "\'float\'", "\'int\'", "\'long\'", "\'short\'", "\'struct\'", "\'union\'", "\'void\'", "IDENTIFIER", "SIGNEDNESS"];
  
  static final List<String> _expect30 = <String>["\'long\'"];
  
  static final List<String> _expect31 = <String>["NUMBER"];
  
  static final List<String> _expect32 = <String>["\'{\'"];
  
  static final List<String> _expect33 = <String>["\'(\'"];
  
  static final List<String> _expect34 = <String>["-"];
  
  static final List<String> _expect35 = <String>["\';\'"];
  
  static final List<String> _expect36 = <String>["\'short\'"];
  
  static final List<String> _expect37 = <String>["SIGNEDNESS"];
  
  static final List<String> _expect38 = <String>["\'struct\'"];
  
  static final List<String> _expect39 = <String>["\'union\'"];
  
  static final List<String> _expect4 = <String>["\'char\'", "\'int\'"];
  
  static final List<String> _expect40 = <String>["\'...\'"];
  
  static final List<String> _expect41 = <String>["\'void\'"];
  
  static final List<String> _expect42 = <String>["ZERO_NUMBER"];
  
  static final List<String> _expect43 = <String>["//"];
  
  static final List<String> _expect44 = <String>["..."];
  
  static final List<String> _expect45 = <String>["long"];
  
  static final List<String> _expect46 = <String>["+"];
  
  static final List<String> _expect47 = <String>["_Bool", "_Complex", "_Imaginary", "auto", "break", "case", "char", "const", "continue", "default", "do", "double", "else", "enum", "extern", "float", "for", "goto", "if", "inline", "int", "long", "register", "restrict", "return", "short", "signed", "sizeof", "static", "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"];
  
  static final List<String> _expect48 = <String>["+", "-"];
  
  static final List<String> _expect49 = <String>["signed"];
  
  static final List<String> _expect5 = <String>["\'long\'", "\'short\'"];
  
  static final List<String> _expect50 = <String>["unsigned"];
  
  static final List<String> _expect6 = <String>["\'double\'", "\'float\'"];
  
  static final List<String> _expect7 = <String>["\'__attribute__\'"];
  
  static final List<String> _expect8 = <String>["IDENT"];
  
  static final List<String> _expect9 = <String>["\',\'"];
  
  static final List<bool> _lookahead = _unmap([0x7fc07fe5, 0x7fa1ffff, 0x7f07ffff, 0x7e87ffff, 0x5fdfffff, 0x4ff04, 0x68002c0, 0x2800]);
  
  // '\n', '\r'
  static final List<bool> _mapping0 = _unmap([0x9]);
  
  // 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  static final List<bool> _mapping1 = _unmap([0x43ffffff, 0x7fffffe]);
  
  // '\t', '\n', '\r', ' '
  static final List<bool> _mapping2 = _unmap([0x800013]);
  
  // '__attribute__'
  static final List<int> _strings0 = <int>[95, 95, 97, 116, 116, 114, 105, 98, 117, 116, 101, 95, 95];
  
  // 'char'
  static final List<int> _strings1 = <int>[99, 104, 97, 114];
  
  // 'union'
  static final List<int> _strings10 = <int>[117, 110, 105, 111, 110];
  
  // 'void'
  static final List<int> _strings11 = <int>[118, 111, 105, 100];
  
  // '//'
  static final List<int> _strings12 = <int>[47, 47];
  
  // '...'
  static final List<int> _strings13 = <int>[46, 46, 46];
  
  // '\r\n'
  static final List<int> _strings14 = <int>[13, 10];
  
  // 'long'
  static final List<int> _strings15 = <int>[108, 111, 110, 103];
  
  // '_Bool'
  static final List<int> _strings16 = <int>[95, 66, 111, 111, 108];
  
  // '_Complex'
  static final List<int> _strings17 = <int>[95, 67, 111, 109, 112, 108, 101, 120];
  
  // '_Imaginary'
  static final List<int> _strings18 = <int>[95, 73, 109, 97, 103, 105, 110, 97, 114, 121];
  
  // 'auto'
  static final List<int> _strings19 = <int>[97, 117, 116, 111];
  
  // 'const'
  static final List<int> _strings2 = <int>[99, 111, 110, 115, 116];
  
  // 'break'
  static final List<int> _strings20 = <int>[98, 114, 101, 97, 107];
  
  // 'case'
  static final List<int> _strings21 = <int>[99, 97, 115, 101];
  
  // 'continue'
  static final List<int> _strings22 = <int>[99, 111, 110, 116, 105, 110, 117, 101];
  
  // 'default'
  static final List<int> _strings23 = <int>[100, 101, 102, 97, 117, 108, 116];
  
  // 'do'
  static final List<int> _strings24 = <int>[100, 111];
  
  // 'else'
  static final List<int> _strings25 = <int>[101, 108, 115, 101];
  
  // 'extern'
  static final List<int> _strings26 = <int>[101, 120, 116, 101, 114, 110];
  
  // 'for'
  static final List<int> _strings27 = <int>[102, 111, 114];
  
  // 'goto'
  static final List<int> _strings28 = <int>[103, 111, 116, 111];
  
  // 'if'
  static final List<int> _strings29 = <int>[105, 102];
  
  // 'double'
  static final List<int> _strings3 = <int>[100, 111, 117, 98, 108, 101];
  
  // 'inline'
  static final List<int> _strings30 = <int>[105, 110, 108, 105, 110, 101];
  
  // 'register'
  static final List<int> _strings31 = <int>[114, 101, 103, 105, 115, 116, 101, 114];
  
  // 'restrict'
  static final List<int> _strings32 = <int>[114, 101, 115, 116, 114, 105, 99, 116];
  
  // 'return'
  static final List<int> _strings33 = <int>[114, 101, 116, 117, 114, 110];
  
  // 'signed'
  static final List<int> _strings34 = <int>[115, 105, 103, 110, 101, 100];
  
  // 'sizeof'
  static final List<int> _strings35 = <int>[115, 105, 122, 101, 111, 102];
  
  // 'static'
  static final List<int> _strings36 = <int>[115, 116, 97, 116, 105, 99];
  
  // 'switch'
  static final List<int> _strings37 = <int>[115, 119, 105, 116, 99, 104];
  
  // 'unsigned'
  static final List<int> _strings38 = <int>[117, 110, 115, 105, 103, 110, 101, 100];
  
  // 'volatile'
  static final List<int> _strings39 = <int>[118, 111, 108, 97, 116, 105, 108, 101];
  
  // 'enum'
  static final List<int> _strings4 = <int>[101, 110, 117, 109];
  
  // 'while'
  static final List<int> _strings40 = <int>[119, 104, 105, 108, 101];
  
  // 'float'
  static final List<int> _strings5 = <int>[102, 108, 111, 97, 116];
  
  // 'int'
  static final List<int> _strings6 = <int>[105, 110, 116];
  
  // 'short'
  static final List<int> _strings7 = <int>[115, 104, 111, 114, 116];
  
  // 'struct'
  static final List<int> _strings8 = <int>[115, 116, 114, 117, 99, 116];
  
  // 'typedef'
  static final List<int> _strings9 = <int>[116, 121, 112, 101, 100, 101, 102];
  
  final List<String> _tokenAliases = ["\'=\'", "\'*\'", "\'__attribute__\'", "\'char\'", "\'}\'", "\']\'", "\')\'", "\':\'", "\',\'", "\'const\'", "\'double\'", "\'enum\'", "EOF", "\'float\'", "IDENT", "IDENTIFIER", "\'int\'", "LEADING_SPACES", "\'long\'", "NUMBER", "\'{\'", "\'[\'", "\'(\'", "POSITIVE_NUMBER", "\';\'", "\'short\'", "SIGNEDNESS", "\'struct\'", "\'typedef\'", "\'union\'", "\'...\'", "\'void\'", "ZERO_NUMBER"];
  
  final List<int> _tokenFlags = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
  
  final List<String> _tokenNames = ["ASSIGN", "ASTERISK", "ATTRIBUTE", "CHAR", "CLOSE_BRACE", "CLOSE_BRACKET", "CLOSE_PAREN", "COLON", "COMMA", "CONST", "DOUBLE", "ENUM", "EOF", "FLOAT", "IDENT", "IDENTIFIER", "INT", "LEADING_SPACES", "LONG_TYPE", "NUMBER", "OPEN_BRACE", "OPEN_BRACKET", "OPEN_PAREN", "POSITIVE_NUMBER", "SEMICOLON", "SHORT", "SIGNEDNESS", "STRUCT", "TYPEDEF", "UNION", "VA_LIST_PARAMETER", "VOID", "ZERO_NUMBER"];
  
  static final List<List<int>> _transitions0 = [[59, 59], [65, 90, 95, 95], [97, 122]];
  
  static final List<List<int>> _transitions1 = [[65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions10 = [[99, 99, 101, 101]];
  
  static final List<List<int>> _transitions11 = [[43, 43, 45, 45, 48, 57]];
  
  static final List<List<int>> _transitions12 = [[99, 99, 101, 101, 115, 115, 117, 117]];
  
  static final List<List<int>> _transitions13 = [[99, 99], [101, 101], [115, 115, 117, 117]];
  
  static final List<List<int>> _transitions14 = [[43, 43, 45, 45, 48, 48], [49, 57]];
  
  static final List<List<int>> _transitions15 = [[0, 9, 11, 12, 14, 1114111], [10, 10, 13, 13]];
  
  static final List<List<int>> _transitions16 = [[10, 10], [13, 13]];
  
  static final List<List<int>> _transitions17 = [[48, 57], [65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions18 = [[43, 43, 45, 45, 48, 48]];
  
  static final List<List<int>> _transitions19 = [[95, 95, 97, 103, 105, 105, 108, 108, 114, 119]];
  
  static final List<List<int>> _transitions2 = [[65, 90, 95, 95], [97, 122]];
  
  static final List<List<int>> _transitions20 = [[95, 95], [97, 97], [98, 98], [99, 99], [100, 100], [101, 101], [102, 102], [103, 103], [105, 105], [108, 108], [114, 114], [115, 115], [116, 116], [117, 117], [118, 118], [119, 119]];
  
  static final List<List<int>> _transitions21 = [[43, 43], [45, 45]];
  
  static final List<List<int>> _transitions22 = [[9, 10, 13, 13, 32, 32]];
  
  static final List<List<int>> _transitions23 = [[9, 10, 13, 13, 32, 32], [47, 47]];
  
  static final List<List<int>> _transitions3 = [[99, 99], [105, 105]];
  
  static final List<List<int>> _transitions4 = [[108, 108], [115, 115]];
  
  static final List<List<int>> _transitions5 = [[100, 100], [102, 102]];
  
  static final List<List<int>> _transitions6 = [[43, 43, 45, 45, 48, 57, 65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions7 = [[43, 43, 45, 45, 48, 57], [65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions8 = [[99, 99, 115, 115, 117, 117]];
  
  static final List<List<int>> _transitions9 = [[115, 115], [117, 117]];
  
  List<Map<int, List>> _cache;
  
  List<int> _cachePos;
  
  List<bool> _cacheable;
  
  int _ch;
  
  int _cursor;
  
  List<CParserError> _errors;
  
  List<String> _expected;
  
  int _failurePos;
  
  List<int> _input;
  
  int _inputLen;
  
  int _startPos;
  
  int _testing;
  
  int _token;
  
  int _tokenStart;
  
  bool success;
  
  final String text;
  
  CParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }    
    _input = _toCodePoints(text);
    _inputLen = _input.length;    
    reset(0);    
  }
  
  void _addToCache(dynamic result, int start, int id) {   
    var map = _cache[id];
    if (map == null) {
      map = <int, List>{};
      _cache[id] = map;
    }
    map[start] = [result, _cursor, success];      
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {    
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var alias = _tokenAliases[_token];
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos > _tokenStart && _failurePos == _inputLen && (flag & 1) != 0) {             
        var message = "Unterminated '$name'";
        _errors.add(new CParserError(CParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {             
        var message = "Malformed '$name'";
        _errors.add(new CParserError(CParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else {
        _expected.add(alias);
      }            
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }   
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    if (!_cacheable[id]) {  
      _cacheable[id] = true;  
      return null;
    }
    var map = _cache[id];
    if (map == null) {
      return null;
    }
    var data = map[_cursor];
    if (data == null) {
      return null;
    }
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }
    return data;  
  }
  
  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];    
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;          
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state; 
      }   
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;  
  }
  
  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }
  
  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }    
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }    
    return null;  
  }
  
  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;  
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];  
        } else {
          result = new String.fromCharCode(_ch);
        }     
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      }
      success = false;
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }        
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }  
      return result;
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {    
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];  
          } else {
            result = new String.fromCharCode(_ch);
          }          
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    success = false;  
    return null;  
  }
  
  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;  
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }  
    if (success) {
      _cursor += length;      
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return string;      
    }  
    return null; 
  }
  
  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }  
  }
  
  dynamic _parse_ASSIGN() {
    // LEXEME (TOKEN)
    // ASSIGN <- '=' SPACING
    var $$;
    _token = 0;  
    _tokenStart = _cursor;  
    // => '=' SPACING # Choice
    switch (_ch == 61 ? 0 : _ch == -1 ? 2 : 1) {
      // [=]
      case 0:
        // => '=' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '='
          $$ = '=';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '='
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '=' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '='
      _failure(_expect18);
    }
    // <= '=' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ASTERISK() {
    // LEXEME (TOKEN)
    // ASTERISK <- '*' SPACING
    var $$;
    _token = 1;  
    _tokenStart = _cursor;  
    // => '*' SPACING # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => '*' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '*'
          $$ = '*';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '*'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '*'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '*' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '*'
      _failure(_expect19);
    }
    // <= '*' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ATTRIBUTE() {
    // LEXEME (TOKEN)
    // ATTRIBUTE <- '__attribute__' SPACING
    var $$;
    _token = 2;  
    _tokenStart = _cursor;  
    // => '__attribute__' SPACING # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => '__attribute__' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '__attribute__'
          $$ = _matchString(_strings0, '__attribute__');
          // <= '__attribute__'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '__attribute__'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '__attribute__' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '__attribute__'
      _failure(_expect7);
    }
    // <= '__attribute__' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ArrayDimension() {
    // SENTENCE (NONTERMINAL)
    // ArrayDimension <- Dimension+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[16] >= pos) {
      $$ = _getFromCache(16);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[16] = pos;
    }  
    // => Dimension+ # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => Dimension+
        var testing0;
        for (var first = true, reps; ;) {  
          // => Dimension  
          $$ = _parse_Dimension();  
          // <= Dimension  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= Dimension+
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect13);
    }
    // <= Dimension+ # Choice
    if (_cacheable[16]) {
      _addToCache($$, pos, 16);
    }    
    return $$;
  }
  
  dynamic _parse_ArrayParameter() {
    // SENTENCE (NONTERMINAL)
    // ArrayParameter <- Type IDENTIFIER? ArrayDimension AttributeSpecifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[22] >= pos) {
      $$ = _getFromCache(22);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[22] = pos;
    }  
    // => Type IDENTIFIER? ArrayDimension AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER? ArrayDimension AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true; 
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          // => ArrayDimension
          $$ = _parse_ArrayDimension();
          // <= ArrayDimension
          if (!success) break;
          seq[2] = $$;
          // => AttributeSpecifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing1;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Type
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            // ArrayDimension
            final $3 = seq[2];
            // AttributeSpecifiers?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new ParameterDeclaration(attributes: $4, name: $2, type: _createArray($1, $3));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER? ArrayDimension AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Type IDENTIFIER? ArrayDimension AttributeSpecifiers? # Choice
    if (_cacheable[22]) {
      _addToCache($$, pos, 22);
    }    
    return $$;
  }
  
  dynamic _parse_ArraySize() {
    // SENTENCE (NONTERMINAL)
    // ArraySize <- !ZERO_NUMBER POSITIVE_NUMBER
    var $$;
    // => !ZERO_NUMBER POSITIVE_NUMBER # Choice
    switch (_getState(_transitions11)) {
      // [+] [-] [0-9]
      // EOF
      case 0:
      case 2:
        // => !ZERO_NUMBER POSITIVE_NUMBER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !ZERO_NUMBER
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => ZERO_NUMBER
          $$ = _parse_ZERO_NUMBER();
          // <= ZERO_NUMBER
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !ZERO_NUMBER
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => POSITIVE_NUMBER
          $$ = _parse_POSITIVE_NUMBER();
          // <= POSITIVE_NUMBER
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // !ZERO_NUMBER
            final $1 = seq[0];
            // POSITIVE_NUMBER
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !ZERO_NUMBER POSITIVE_NUMBER # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: POSITIVE_NUMBER
      _failure(_expect14);
    }
    // <= !ZERO_NUMBER POSITIVE_NUMBER # Choice
    return $$;
  }
  
  dynamic _parse_ArrayType() {
    // SENTENCE (NONTERMINAL)
    // ArrayType <- TypeName ArrayDimension
    var $$;
    // => TypeName ArrayDimension # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => TypeName ArrayDimension # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => TypeName
          $$ = _parse_TypeName();
          // <= TypeName
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ArrayDimension
          $$ = _parse_ArrayDimension();
          // <= ArrayDimension
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // TypeName
            final $1 = seq[0];
            // ArrayDimension
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _createArray($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TypeName ArrayDimension # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= TypeName ArrayDimension # Choice
    return $$;
  }
  
  dynamic _parse_ArrayVariableDeclaration() {
    // SENTENCE (NONTERMINAL)
    // ArrayVariableDeclaration <- Type IDENTIFIER ArrayDimension AttributeSpecifiers?
    var $$;
    // => Type IDENTIFIER ArrayDimension AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER ArrayDimension AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => ArrayDimension
          $$ = _parse_ArrayDimension();
          // <= ArrayDimension
          if (!success) break;
          seq[2] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Type
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // ArrayDimension
            final $3 = seq[2];
            // AttributeSpecifiers?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new VariableDeclaration(attributes: $4, name: $2, type: _createArray($1, $3));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER ArrayDimension AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Type IDENTIFIER ArrayDimension AttributeSpecifiers? # Choice
    return $$;
  }
  
  dynamic _parse_Attribute() {
    // SENTENCE (NONTERMINAL)
    // Attribute <- IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN / IDENT
    var $$;          
    var pos = _cursor;             
    if(_cachePos[10] >= pos) {
      $$ = _getFromCache(10);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[10] = pos;
    }  
    // => IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN / IDENT # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      case 0:
        while (true) {
          // => IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => IDENT
            $$ = _parse_IDENT();
            // <= IDENT
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => OPEN_PAREN
            $$ = _parse_OPEN_PAREN();
            // <= OPEN_PAREN
            if (!success) break;
            seq[1] = $$;
            // => AttributeParameterList?
            var testing0 = _testing;
            _testing = _cursor;
            // => AttributeParameterList
            $$ = _parse_AttributeParameterList();
            // <= AttributeParameterList
            success = true; 
            _testing = testing0;
            // <= AttributeParameterList?
            if (!success) break;
            seq[2] = $$;
            // => CLOSE_PAREN
            $$ = _parse_CLOSE_PAREN();
            // <= CLOSE_PAREN
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // IDENT
              final $1 = seq[0];
              // OPEN_PAREN
              final $2 = seq[1];
              // AttributeParameterList?
              final $3 = seq[2];
              // CLOSE_PAREN
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new BinaryAttribute($1, $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => IDENT
          $$ = _parse_IDENT();
          // <= IDENT
          if (success) {    
            // IDENT
            final $1 = $$;
            final $start = startPos1;
            $$ = new BinaryAttribute($1);
          }
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT
      _failure(_expect8);
    }
    // <= IDENT OPEN_PAREN AttributeParameterList? CLOSE_PAREN / IDENT # Choice
    if (_cacheable[10]) {
      _addToCache($$, pos, 10);
    }    
    return $$;
  }
  
  dynamic _parse_AttributeList() {
    // SENTENCE (NONTERMINAL)
    // AttributeList <- Attribute (COMMA Attribute)*
    var $$;
    // => Attribute (COMMA Attribute)* # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      case 0:
        // => Attribute (COMMA Attribute)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Attribute
          $$ = _parse_Attribute();
          // <= Attribute
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA Attribute)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA Attribute) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA Attribute # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => Attribute
                  $$ = _parse_Attribute();
                  // <= Attribute
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA Attribute # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect9);
            }
            // <= (COMMA Attribute) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA Attribute)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // Attribute
            final $1 = seq[0];
            // (COMMA Attribute)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Attribute (COMMA Attribute)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT
      _failure(_expect8);
    }
    // <= Attribute (COMMA Attribute)* # Choice
    return $$;
  }
  
  dynamic _parse_AttributeParameter() {
    // SENTENCE (NONTERMINAL)
    // AttributeParameter <- IDENT / NUMBER
    var $$;          
    var pos = _cursor;             
    if(_cachePos[12] >= pos) {
      $$ = _getFromCache(12);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[12] = pos;
    }  
    // => IDENT / NUMBER # Choice
    switch (_getState(_transitions7)) {
      // [+] [-] [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => NUMBER
        $$ = _parse_NUMBER();
        // <= NUMBER
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => IDENT
        $$ = _parse_IDENT();
        // <= IDENT
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT, NUMBER
      _failure(_expect10);
    }
    // <= IDENT / NUMBER # Choice
    if (_cacheable[12]) {
      _addToCache($$, pos, 12);
    }    
    return $$;
  }
  
  dynamic _parse_AttributeParameterList() {
    // SENTENCE (NONTERMINAL)
    // AttributeParameterList <- AttributeParameter (COMMA AttributeParameter)*
    var $$;
    // => AttributeParameter (COMMA AttributeParameter)* # Choice
    switch (_getState(_transitions6)) {
      // [+] [-] [0-9] [A-Z] [_] [a-z]
      case 0:
        // => AttributeParameter (COMMA AttributeParameter)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => AttributeParameter
          $$ = _parse_AttributeParameter();
          // <= AttributeParameter
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA AttributeParameter)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA AttributeParameter) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA AttributeParameter # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => AttributeParameter
                  $$ = _parse_AttributeParameter();
                  // <= AttributeParameter
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA AttributeParameter # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect9);
            }
            // <= (COMMA AttributeParameter) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA AttributeParameter)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // AttributeParameter
            final $1 = seq[0];
            // (COMMA AttributeParameter)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= AttributeParameter (COMMA AttributeParameter)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT, NUMBER
      _failure(_expect10);
    }
    // <= AttributeParameter (COMMA AttributeParameter)* # Choice
    return $$;
  }
  
  dynamic _parse_AttributeSpecifier() {
    // SENTENCE (NONTERMINAL)
    // AttributeSpecifier <- ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN
    var $$;
    // => ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ATTRIBUTE
          $$ = _parse_ATTRIBUTE();
          // <= ATTRIBUTE
          if (!success) break;
          var seq = new List(6)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[2] = $$;
          // => AttributeList?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeList
          $$ = _parse_AttributeList();
          // <= AttributeList
          success = true; 
          _testing = testing0;
          // <= AttributeList?
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[4] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[5] = $$;
          $$ = seq;
          if (success) {    
            // ATTRIBUTE
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // OPEN_PAREN
            final $3 = seq[2];
            // AttributeList?
            final $4 = seq[3];
            // CLOSE_PAREN
            final $5 = seq[4];
            // CLOSE_PAREN
            final $6 = seq[5];
            final $start = startPos0;
            $$ = new AttributeSpecification($4);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '__attribute__'
      _failure(_expect7);
    }
    // <= ATTRIBUTE OPEN_PAREN OPEN_PAREN AttributeList? CLOSE_PAREN CLOSE_PAREN # Choice
    return $$;
  }
  
  dynamic _parse_AttributeSpecifiers() {
    // SENTENCE (NONTERMINAL)
    // AttributeSpecifiers <- AttributeSpecifier+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[7] >= pos) {
      $$ = _getFromCache(7);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[7] = pos;
    }  
    // => AttributeSpecifier+ # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => AttributeSpecifier+
        var testing0;
        for (var first = true, reps; ;) {  
          // => AttributeSpecifier  
          $$ = _parse_AttributeSpecifier();  
          // <= AttributeSpecifier  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= AttributeSpecifier+
        if (success) {    
          // AttributeSpecifier+
          final $1 = $$;
          final $start = startPos0;
          $$ = new AttributeSpecifications($1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '__attribute__'
      _failure(_expect7);
    }
    // <= AttributeSpecifier+ # Choice
    if (_cacheable[7]) {
      _addToCache($$, pos, 7);
    }    
    return $$;
  }
  
  dynamic _parse_BitFieldParameter() {
    // SENTENCE (NONTERMINAL)
    // BitFieldParameter <- Type IDENTIFIER? COLON POSITIVE_NUMBER
    var $$;
    // => Type IDENTIFIER? COLON POSITIVE_NUMBER # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER? COLON POSITIVE_NUMBER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true; 
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          // => COLON
          $$ = _parse_COLON();
          // <= COLON
          if (!success) break;
          seq[2] = $$;
          // => POSITIVE_NUMBER
          $$ = _parse_POSITIVE_NUMBER();
          // <= POSITIVE_NUMBER
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Type
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            // COLON
            final $3 = seq[2];
            // POSITIVE_NUMBER
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new ParameterDeclaration(name: $2, type: $1, width: $4);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER? COLON POSITIVE_NUMBER # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Type IDENTIFIER? COLON POSITIVE_NUMBER # Choice
    return $$;
  }
  
  dynamic _parse_CHAR() {
    // LEXEME (TOKEN)
    // CHAR <- 'char' !IDENT_PART SPACING
    var $$;
    _token = 3;  
    _tokenStart = _cursor;  
    // => 'char' !IDENT_PART SPACING # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        // => 'char' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'char'
          $$ = _matchString(_strings1, 'char');
          // <= 'char'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'char'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'char' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'char'
      _failure(_expect20);
    }
    // <= 'char' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_CLOSE_BRACE() {
    // LEXEME (TOKEN)
    // CLOSE_BRACE <- '}' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[48] >= pos) {
      $$ = _getFromCache(48);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[48] = pos;
    }  
    _token = 4;    
    _tokenStart = _cursor;    
    // => '}' SPACING # Choice
    switch (_ch == 125 ? 0 : _ch == -1 ? 2 : 1) {
      // [}]
      case 0:
        // => '}' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '}'
          $$ = '}';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '}'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '}'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '}' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '}'
      _failure(_expect21);
    }
    // <= '}' SPACING # Choice
    if (_cacheable[48]) {
      _addToCache($$, pos, 48);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_CLOSE_BRACKET() {
    // LEXEME (TOKEN)
    // CLOSE_BRACKET <- ']' SPACING
    var $$;
    _token = 5;  
    _tokenStart = _cursor;  
    // => ']' SPACING # Choice
    switch (_ch == 93 ? 0 : _ch == -1 ? 2 : 1) {
      // []]
      case 0:
        // => ']' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ']'
          $$ = ']';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ']'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ']'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ']' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ']'
      _failure(_expect22);
    }
    // <= ']' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_CLOSE_PAREN() {
    // LEXEME (TOKEN)
    // CLOSE_PAREN <- ')' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[50] >= pos) {
      $$ = _getFromCache(50);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[50] = pos;
    }  
    _token = 6;    
    _tokenStart = _cursor;    
    // => ')' SPACING # Choice
    switch (_ch == 41 ? 0 : _ch == -1 ? 2 : 1) {
      // [)]
      case 0:
        // => ')' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ')'
          $$ = ')';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ')'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ')'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ')' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ')'
      _failure(_expect23);
    }
    // <= ')' SPACING # Choice
    if (_cacheable[50]) {
      _addToCache($$, pos, 50);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_COLON() {
    // LEXEME (TOKEN)
    // COLON <- ':' SPACING
    var $$;
    _token = 7;  
    _tokenStart = _cursor;  
    // => ':' SPACING # Choice
    switch (_ch == 58 ? 0 : _ch == -1 ? 2 : 1) {
      // [:]
      case 0:
        // => ':' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ':'
          $$ = ':';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ':'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ':'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ':' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ':'
      _failure(_expect24);
    }
    // <= ':' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_COMMA() {
    // LEXEME (TOKEN)
    // COMMA <- ',' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[52] >= pos) {
      $$ = _getFromCache(52);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[52] = pos;
    }  
    _token = 8;    
    _tokenStart = _cursor;    
    // => ',' SPACING # Choice
    switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
      // [,]
      case 0:
        // => ',' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ','
          $$ = ',';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ','
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ','
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ',' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ','
      _failure(_expect9);
    }
    // <= ',' SPACING # Choice
    if (_cacheable[52]) {
      _addToCache($$, pos, 52);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_COMMENT() {
    // MORHEME
    // COMMENT <- '//' (!EOL .)* (EOL / !.)
    var $$;
    // => '//' (!EOL .)* (EOL / !.) # Choice
    switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
      // [/]
      case 0:
        // => '//' (!EOL .)* (EOL / !.) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '//'
          $$ = _matchString(_strings12, '//');
          // <= '//'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (!EOL .)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (!EOL .) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              // EOF
              case 0:
              case 2:
                // => !EOL . # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => !EOL
                  var ch2 = _ch, pos2 = _cursor, testing1 = _testing; 
                  _testing = _inputLen + 1;
                  // => EOL
                  $$ = _parse_EOL();
                  // <= EOL
                  _ch = ch2;
                  _cursor = pos2; 
                  _testing = testing1;
                  $$ = null;
                  success = !success;
                  // <= !EOL
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => .
                  $$ = _matchAny();
                  // <= .
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= !EOL . # Sequence
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(const [null]);
            }
            // <= (!EOL .) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (!EOL .)*
          if (!success) break;
          seq[1] = $$;
          // => (EOL / !.) # Choice
          switch (_getState(_transitions15)) {
            // [\u0000-\t] [\u000b-\u000c] [\u000e-\u0010ffff]
            // EOF
            case 0:
            case 3:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => !.
              var ch3 = _ch, pos3 = _cursor, testing2 = _testing; 
              _testing = _inputLen + 1;
              // => .
              $$ = _matchAny();
              // <= .
              _ch = ch3;
              _cursor = pos3; 
              _testing = testing2;
              $$ = null;
              success = !success;
              // <= !.
              _startPos = startPos2;
              break;
            // [\n] [\r]
            case 1:
              while (true) {
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => EOL
                $$ = _parse_EOL();
                // <= EOL
                _startPos = startPos3;
                if (success) break;
                var startPos4 = _startPos;
                _startPos = _cursor;
                // => !.
                var ch4 = _ch, pos4 = _cursor, testing3 = _testing; 
                _testing = _inputLen + 1;
                // => .
                $$ = _matchAny();
                // <= .
                _ch = ch4;
                _cursor = pos4; 
                _testing = testing3;
                $$ = null;
                success = !success;
                // <= !.
                _startPos = startPos4;
                break;
              }
              break;
            // No matches
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (EOL / !.) # Choice
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '//' (!EOL .)* (EOL / !.) # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: //
      _failure(_expect43);
    }
    // <= '//' (!EOL .)* (EOL / !.) # Choice
    return $$;
  }
  
  dynamic _parse_CONST() {
    // LEXEME (TOKEN)
    // CONST <- 'const' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[53] >= pos) {
      $$ = _getFromCache(53);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[53] = pos;
    }  
    _token = 9;    
    _tokenStart = _cursor;    
    // => 'const' SPACING # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        // => 'const' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'const'
          $$ = _matchString(_strings2, 'const');
          // <= 'const'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'const'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = true;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'const' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'const'
      _failure(_expect25);
    }
    // <= 'const' SPACING # Choice
    if (_cacheable[53]) {
      _addToCache($$, pos, 53);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_DOUBLE() {
    // LEXEME (TOKEN)
    // DOUBLE <- 'double' !IDENT_PART SPACING
    var $$;
    _token = 10;  
    _tokenStart = _cursor;  
    // => 'double' !IDENT_PART SPACING # Choice
    switch (_ch == 100 ? 0 : _ch == -1 ? 2 : 1) {
      // [d]
      case 0:
        // => 'double' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'double'
          $$ = _matchString(_strings3, 'double');
          // <= 'double'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'double'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'double' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'double'
      _failure(_expect26);
    }
    // <= 'double' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_Declaration() {
    // SENTENCE (NONTERMINAL)
    // Declaration <- FunctionDeclartion SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / StructDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / SEMICOLON+
    var $$;
    // => FunctionDeclartion SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / StructDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / SEMICOLON+ # Choice
    switch (_getState(_transitions0)) {
      // [;]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => SEMICOLON+
        var testing0;
        for (var first = true, reps; ;) {  
          // => SEMICOLON  
          $$ = _parse_SEMICOLON();  
          // <= SEMICOLON  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= SEMICOLON+
        if (success) {    
          // SEMICOLON+
          final $1 = $$;
          final $start = startPos0;
          $$ = new EmptyDeclaration();
        }
        _startPos = startPos0;
        break;
      // [A-Z] [_]
      // EOF
      case 1:
      case 4:
        while (true) {
          // => FunctionDeclartion SEMICOLON+ # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FunctionDeclartion
            $$ = _parse_FunctionDeclartion();
            // <= FunctionDeclartion
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing1;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing1 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing1;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // FunctionDeclartion
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos1;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= FunctionDeclartion SEMICOLON+ # Sequence
          if (success) break;
          // => VariableDeclaration SEMICOLON+ # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => VariableDeclaration
            $$ = _parse_VariableDeclaration();
            // <= VariableDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing2;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing2 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing2;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // VariableDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos2;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos2;
          // <= VariableDeclaration SEMICOLON+ # Sequence
          break;
        }
        break;
      // [a-z]
      case 2:
        while (true) {
          // => FunctionDeclartion SEMICOLON+ # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FunctionDeclartion
            $$ = _parse_FunctionDeclartion();
            // <= FunctionDeclartion
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing3;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing3 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing3;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // FunctionDeclartion
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos3;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos3;
          // <= FunctionDeclartion SEMICOLON+ # Sequence
          if (success) break;
          // => TypedefDeclaration SEMICOLON+ # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => TypedefDeclaration
            $$ = _parse_TypedefDeclaration();
            // <= TypedefDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing4;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing4 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing4;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // TypedefDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos4;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos4;
          // <= TypedefDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => VariableDeclaration SEMICOLON+ # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => VariableDeclaration
            $$ = _parse_VariableDeclaration();
            // <= VariableDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing5;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing5 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing5;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // VariableDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos5;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos5;
          // <= VariableDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => StructDeclaration SEMICOLON+ # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => StructDeclaration
            $$ = _parse_StructDeclaration();
            // <= StructDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing6;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing6 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing6;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // StructDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos6;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos6;
          // <= StructDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => EnumDeclaration SEMICOLON+ # Sequence
          var ch6 = _ch, pos6 = _cursor, startPos7 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => EnumDeclaration
            $$ = _parse_EnumDeclaration();
            // <= EnumDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing7;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing7 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing7;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // EnumDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos7;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos7;
          // <= EnumDeclaration SEMICOLON+ # Sequence
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum', 'typedef', ';'
      _failure(_expect2);
    }
    // <= FunctionDeclartion SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / StructDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / SEMICOLON+ # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationList() {
    // SENTENCE (NONTERMINAL)
    // DeclarationList <- Declaration*
    var $$;
    // => Declaration* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => Declaration*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => Declaration
          $$ = _parse_Declaration();
          // <= Declaration
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= Declaration*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
      // EOF
      case 2:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => Declaration*
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => Declaration
            $$ = _parse_Declaration();
            // <= Declaration
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          // <= Declaration*
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => Declaration*
          var testing2 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => Declaration
            $$ = _parse_Declaration();
            // <= Declaration
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing2;
              $$ = reps;
              break; 
            }
          }
          // <= Declaration*
          _startPos = startPos2;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= Declaration* # Choice
    return $$;
  }
  
  dynamic _parse_Dimension() {
    // SENTENCE (NONTERMINAL)
    // Dimension <- OPEN_BRACKET ArraySize? CLOSE_BRACKET
    var $$;
    // => OPEN_BRACKET ArraySize? CLOSE_BRACKET # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => OPEN_BRACKET ArraySize? CLOSE_BRACKET # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => OPEN_BRACKET
          $$ = _parse_OPEN_BRACKET();
          // <= OPEN_BRACKET
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => ArraySize?
          var testing0 = _testing;
          _testing = _cursor;
          // => ArraySize
          $$ = _parse_ArraySize();
          // <= ArraySize
          success = true; 
          _testing = testing0;
          // <= ArraySize?
          if (!success) break;
          seq[1] = $$;
          // => CLOSE_BRACKET
          $$ = _parse_CLOSE_BRACKET();
          // <= CLOSE_BRACKET
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // OPEN_BRACKET
            final $1 = seq[0];
            // ArraySize?
            final $2 = seq[1];
            // CLOSE_BRACKET
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= OPEN_BRACKET ArraySize? CLOSE_BRACKET # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect13);
    }
    // <= OPEN_BRACKET ArraySize? CLOSE_BRACKET # Choice
    return $$;
  }
  
  dynamic _parse_ELLIPSIS() {
    // MORHEME
    // ELLIPSIS <- '...' SPACING
    var $$;
    // => '...' SPACING # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        // => '...' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '...'
          $$ = _matchString(_strings13, '...');
          // <= '...'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '...'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '...' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ...
      _failure(_expect44);
    }
    // <= '...' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_ENUM() {
    // LEXEME (TOKEN)
    // ENUM <- 'enum' !IDENT_PART SPACING
    var $$;
    _token = 11;  
    _tokenStart = _cursor;  
    // => 'enum' !IDENT_PART SPACING # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => 'enum' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'enum'
          $$ = _matchString(_strings4, 'enum');
          // <= 'enum'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'enum'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'enum' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect12);
    }
    // <= 'enum' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_EOF() {
    // LEXEME (TOKEN)
    // EOF <- !.
    var $$;
    _token = 12;  
    _tokenStart = _cursor;  
    // => !. # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => !.
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
        _testing = _inputLen + 1;
        // => .
        $$ = _matchAny();
        // <= .
        _ch = ch0;
        _cursor = pos0; 
        _testing = testing0;
        $$ = null;
        success = !success;
        // <= !.
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= !. # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_EOL() {
    // MORHEME
    // EOL <- '\r\n' / [\n\r]
    var $$;
    // => '\r\n' / [\n\r] # Choice
    switch (_getState(_transitions16)) {
      // [\n]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\n\r]
        $$ = _matchMapping(10, 13, _mapping0);
        // <= [\n\r]
        _startPos = startPos0;
        break;
      // [\r]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => '\r\n'
          $$ = _matchString(_strings14, '\r\n');
          // <= '\r\n'
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => [\n\r]
          $$ = _matchMapping(10, 13, _mapping0);
          // <= [\n\r]
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= '\r\n' / [\n\r] # Choice
    return $$;
  }
  
  dynamic _parse_EnumDeclaration() {
    // SENTENCE (NONTERMINAL)
    // EnumDeclaration <- EnumTypeName OPEN_BRACE EnumValueList CLOSE_BRACE AttributeSpecifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[35] >= pos) {
      $$ = _getFromCache(35);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[35] = pos;
    }  
    // => EnumTypeName OPEN_BRACE EnumValueList CLOSE_BRACE AttributeSpecifiers? # Choice
    switch (_getState(_transitions10)) {
      // [c] [e]
      case 0:
        // => EnumTypeName OPEN_BRACE EnumValueList CLOSE_BRACE AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => EnumTypeName
          $$ = _parse_EnumTypeName();
          // <= EnumTypeName
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          // => OPEN_BRACE
          $$ = _parse_OPEN_BRACE();
          // <= OPEN_BRACE
          if (!success) break;
          seq[1] = $$;
          // => EnumValueList
          $$ = _parse_EnumValueList();
          // <= EnumValueList
          if (!success) break;
          seq[2] = $$;
          // => CLOSE_BRACE
          $$ = _parse_CLOSE_BRACE();
          // <= CLOSE_BRACE
          if (!success) break;
          seq[3] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          if (success) {    
            // EnumTypeName
            final $1 = seq[0];
            // OPEN_BRACE
            final $2 = seq[1];
            // EnumValueList
            final $3 = seq[2];
            // CLOSE_BRACE
            final $4 = seq[3];
            // AttributeSpecifiers?
            final $5 = seq[4];
            final $start = startPos0;
            $$ = new EnumDeclaration(attributes: $5, taggedType: $1, values: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= EnumTypeName OPEN_BRACE EnumValueList CLOSE_BRACE AttributeSpecifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect12);
    }
    // <= EnumTypeName OPEN_BRACE EnumValueList CLOSE_BRACE AttributeSpecifiers? # Choice
    if (_cacheable[35]) {
      _addToCache($$, pos, 35);
    }    
    return $$;
  }
  
  dynamic _parse_EnumTypeName() {
    // SENTENCE (NONTERMINAL)
    // EnumTypeName <- CONST? ENUM AttributeSpecifiers? IDENTIFIER?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[14] >= pos) {
      $$ = _getFromCache(14);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[14] = pos;
    }  
    // => CONST? ENUM AttributeSpecifiers? IDENTIFIER? # Choice
    switch (_getState(_transitions10)) {
      // [c] [e]
      case 0:
        // => CONST? ENUM AttributeSpecifiers? IDENTIFIER? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => CONST?
          var testing0 = _testing;
          _testing = _cursor;
          // => CONST
          $$ = _parse_CONST();
          // <= CONST
          success = true; 
          _testing = testing0;
          // <= CONST?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => ENUM
          $$ = _parse_ENUM();
          // <= ENUM
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing1;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          // => IDENTIFIER?
          var testing2 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true; 
          _testing = testing2;
          // <= IDENTIFIER?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // CONST?
            final $1 = seq[0];
            // ENUM
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            // IDENTIFIER?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new TaggedTypeSpecification(attributes: $3, isConst: $1, kind: $2, tag: $4);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= CONST? ENUM AttributeSpecifiers? IDENTIFIER? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum'
      _failure(_expect12);
    }
    // <= CONST? ENUM AttributeSpecifiers? IDENTIFIER? # Choice
    if (_cacheable[14]) {
      _addToCache($$, pos, 14);
    }    
    return $$;
  }
  
  dynamic _parse_EnumValue() {
    // SENTENCE (NONTERMINAL)
    // EnumValue <- IDENTIFIER ASSIGN NUMBER / IDENTIFIER
    var $$;          
    var pos = _cursor;             
    if(_cachePos[37] >= pos) {
      $$ = _getFromCache(37);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[37] = pos;
    }  
    // => IDENTIFIER ASSIGN NUMBER / IDENTIFIER # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => IDENTIFIER ASSIGN NUMBER # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => IDENTIFIER
            $$ = _parse_IDENTIFIER();
            // <= IDENTIFIER
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ASSIGN
            $$ = _parse_ASSIGN();
            // <= ASSIGN
            if (!success) break;
            seq[1] = $$;
            // => NUMBER
            $$ = _parse_NUMBER();
            // <= NUMBER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // IDENTIFIER
              final $1 = seq[0];
              // ASSIGN
              final $2 = seq[1];
              // NUMBER
              final $3 = seq[2];
              final $start = startPos0;
              $$ = new EnumValueDeclaration(name: $1, value: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= IDENTIFIER ASSIGN NUMBER # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (success) {    
            // IDENTIFIER
            final $1 = $$;
            final $start = startPos1;
            $$ = new EnumValueDeclaration(name: $1);
          }
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER
      _failure(_expect17);
    }
    // <= IDENTIFIER ASSIGN NUMBER / IDENTIFIER # Choice
    if (_cacheable[37]) {
      _addToCache($$, pos, 37);
    }    
    return $$;
  }
  
  dynamic _parse_EnumValueList() {
    // SENTENCE (NONTERMINAL)
    // EnumValueList <- EnumValue (COMMA EnumValue)* COMMA?
    var $$;
    // => EnumValue (COMMA EnumValue)* COMMA? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => EnumValue (COMMA EnumValue)* COMMA? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => EnumValue
          $$ = _parse_EnumValue();
          // <= EnumValue
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (COMMA EnumValue)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA EnumValue) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA EnumValue # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => EnumValue
                  $$ = _parse_EnumValue();
                  // <= EnumValue
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA EnumValue # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect9);
            }
            // <= (COMMA EnumValue) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA EnumValue)*
          if (!success) break;
          seq[1] = $$;
          // => COMMA?
          var testing1 = _testing;
          _testing = _cursor;
          // => COMMA
          $$ = _parse_COMMA();
          // <= COMMA
          success = true; 
          _testing = testing1;
          // <= COMMA?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // EnumValue
            final $1 = seq[0];
            // (COMMA EnumValue)*
            final $2 = seq[1];
            // COMMA?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= EnumValue (COMMA EnumValue)* COMMA? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER
      _failure(_expect17);
    }
    // <= EnumValue (COMMA EnumValue)* COMMA? # Choice
    return $$;
  }
  
  dynamic _parse_FLOAT() {
    // LEXEME (TOKEN)
    // FLOAT <- 'float' !IDENT_PART SPACING
    var $$;
    _token = 13;  
    _tokenStart = _cursor;  
    // => 'float' !IDENT_PART SPACING # Choice
    switch (_ch == 102 ? 0 : _ch == -1 ? 2 : 1) {
      // [f]
      case 0:
        // => 'float' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'float'
          $$ = _matchString(_strings5, 'float');
          // <= 'float'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'float'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'float' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'float'
      _failure(_expect27);
    }
    // <= 'float' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_FunctionDeclartion() {
    // SENTENCE (NONTERMINAL)
    // FunctionDeclartion <- Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN AttributeSpecifiers?
    var $$;
    // => Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(6)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[2] = $$;
          // => FunctionParameters?
          var testing0 = _testing;
          _testing = _cursor;
          // => FunctionParameters
          $$ = _parse_FunctionParameters();
          // <= FunctionParameters
          success = true; 
          _testing = testing0;
          // <= FunctionParameters?
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[4] = $$;
          // => AttributeSpecifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing1;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[5] = $$;
          $$ = seq;
          if (success) {    
            // Type
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // OPEN_PAREN
            final $3 = seq[2];
            // FunctionParameters?
            final $4 = seq[3];
            // CLOSE_PAREN
            final $5 = seq[4];
            // AttributeSpecifiers?
            final $6 = seq[5];
            final $start = startPos0;
            $$ = new FunctionDeclaration(attributes: $6, name: $2, parameters: $4, returnType: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Type IDENTIFIER OPEN_PAREN FunctionParameters? CLOSE_PAREN AttributeSpecifiers? # Choice
    return $$;
  }
  
  dynamic _parse_FunctionParameter() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameter <- ArrayParameter / PointerParameter / SimpleParameter
    var $$;          
    var pos = _cursor;             
    if(_cachePos[21] >= pos) {
      $$ = _getFromCache(21);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[21] = pos;
    }  
    // => ArrayParameter / PointerParameter / SimpleParameter # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => ArrayParameter
          $$ = _parse_ArrayParameter();
          // <= ArrayParameter
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => PointerParameter
          $$ = _parse_PointerParameter();
          // <= PointerParameter
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => SimpleParameter
          $$ = _parse_SimpleParameter();
          // <= SimpleParameter
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= ArrayParameter / PointerParameter / SimpleParameter # Choice
    if (_cacheable[21]) {
      _addToCache($$, pos, 21);
    }    
    return $$;
  }
  
  dynamic _parse_FunctionParameterList() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameterList <- FunctionParameter (COMMA FunctionParameter)*
    var $$;
    // => FunctionParameter (COMMA FunctionParameter)* # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => FunctionParameter (COMMA FunctionParameter)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FunctionParameter
          $$ = _parse_FunctionParameter();
          // <= FunctionParameter
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA FunctionParameter)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA FunctionParameter) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA FunctionParameter # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => FunctionParameter
                  $$ = _parse_FunctionParameter();
                  // <= FunctionParameter
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA FunctionParameter # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect9);
            }
            // <= (COMMA FunctionParameter) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA FunctionParameter)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // FunctionParameter
            final $1 = seq[0];
            // (COMMA FunctionParameter)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionParameter (COMMA FunctionParameter)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= FunctionParameter (COMMA FunctionParameter)* # Choice
    return $$;
  }
  
  dynamic _parse_FunctionParameters() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameters <- FunctionParameterList (COMMA VA_LIST_PARAMETER)?
    var $$;
    // => FunctionParameterList (COMMA VA_LIST_PARAMETER)? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => FunctionParameterList (COMMA VA_LIST_PARAMETER)? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FunctionParameterList
          $$ = _parse_FunctionParameterList();
          // <= FunctionParameterList
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA VA_LIST_PARAMETER)?
          var testing0 = _testing;
          _testing = _cursor;
          // => (COMMA VA_LIST_PARAMETER) # Choice
          switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
            // [,]
            case 0:
              // => COMMA VA_LIST_PARAMETER # Sequence
              var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                // => COMMA
                $$ = _parse_COMMA();
                // <= COMMA
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                // => VA_LIST_PARAMETER
                $$ = _parse_VA_LIST_PARAMETER();
                // <= VA_LIST_PARAMETER
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                if (success) {    
                  // COMMA
                  final $1 = seq[0];
                  // VA_LIST_PARAMETER
                  final $2 = seq[1];
                  final $start = startPos1;
                  $$ = $2;
                }
                break;
              }
              if (!success) {
                _ch = ch1;
                _cursor = pos1;
              }
              _startPos = startPos1;
              // <= COMMA VA_LIST_PARAMETER # Sequence
              break;
            // No matches
            // EOF
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: ','
            _failure(_expect9);
          }
          // <= (COMMA VA_LIST_PARAMETER) # Choice
          success = true; 
          _testing = testing0;
          // <= (COMMA VA_LIST_PARAMETER)?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // FunctionParameterList
            final $1 = seq[0];
            // (COMMA VA_LIST_PARAMETER)?
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _createParameters($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionParameterList (COMMA VA_LIST_PARAMETER)? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= FunctionParameterList (COMMA VA_LIST_PARAMETER)? # Choice
    return $$;
  }
  
  dynamic _parse_IDENT() {
    // LEXEME (TOKEN)
    // IDENT <- IDENT_START IDENT_CONT* SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[58] >= pos) {
      $$ = _getFromCache(58);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[58] = pos;
    }  
    _token = 14;    
    _tokenStart = _cursor;    
    // => IDENT_START IDENT_CONT* SPACING # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      case 0:
        // => IDENT_START IDENT_CONT* SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENT_CONT*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => IDENT_CONT
            $$ = _parse_IDENT_CONT();
            // <= IDENT_CONT
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= IDENT_CONT*
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // IDENT_START
            final $1 = seq[0];
            // IDENT_CONT*
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _flatten([$1, $2]).join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= IDENT_START IDENT_CONT* SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT
      _failure(_expect8);
    }
    // <= IDENT_START IDENT_CONT* SPACING # Choice
    if (_cacheable[58]) {
      _addToCache($$, pos, 58);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_IDENTIFIER() {
    // LEXEME (TOKEN)
    // IDENTIFIER <- !RESERVED_WORD IDENT_START IDENT_CONT* SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[59] >= pos) {
      $$ = _getFromCache(59);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[59] = pos;
    }  
    _token = 15;    
    _tokenStart = _cursor;    
    // => !RESERVED_WORD IDENT_START IDENT_CONT* SPACING # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => !RESERVED_WORD IDENT_START IDENT_CONT* SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !RESERVED_WORD
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => RESERVED_WORD
          $$ = _parse_RESERVED_WORD();
          // <= RESERVED_WORD
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !RESERVED_WORD
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          if (!success) break;
          seq[1] = $$;
          // => IDENT_CONT*
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => IDENT_CONT
            $$ = _parse_IDENT_CONT();
            // <= IDENT_CONT
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          // <= IDENT_CONT*
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // !RESERVED_WORD
            final $1 = seq[0];
            // IDENT_START
            final $2 = seq[1];
            // IDENT_CONT*
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            final $start = startPos0;
            $$ = _flatten([$2, $3]).join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !RESERVED_WORD IDENT_START IDENT_CONT* SPACING # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER
      _failure(_expect17);
    }
    // <= !RESERVED_WORD IDENT_START IDENT_CONT* SPACING # Choice
    if (_cacheable[59]) {
      _addToCache($$, pos, 59);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_IDENT_CONT() {
    // MORHEME
    // IDENT_CONT <- IDENT_START / [0-9]
    var $$;
    // => IDENT_START / [0-9] # Choice
    switch (_getState(_transitions17)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-9]
        $$ = _matchRange(48, 57);
        // <= [0-9]
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => IDENT_START
        $$ = _parse_IDENT_START();
        // <= IDENT_START
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= IDENT_START / [0-9] # Choice
    return $$;
  }
  
  dynamic _parse_IDENT_PART() {
    // MORHEME
    // IDENT_PART <- IDENT_START / IDENT_CONT
    var $$;
    // => IDENT_START / IDENT_CONT # Choice
    switch (_getState(_transitions17)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => IDENT_CONT
        $$ = _parse_IDENT_CONT();
        // <= IDENT_CONT
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => IDENT_CONT
          $$ = _parse_IDENT_CONT();
          // <= IDENT_CONT
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= IDENT_START / IDENT_CONT # Choice
    return $$;
  }
  
  dynamic _parse_IDENT_START() {
    // MORHEME
    // IDENT_START <- [A-Z_a-z]
    var $$;
    // => [A-Z_a-z] # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [A-Z_a-z]
        $$ = _matchMapping(65, 122, _mapping1);
        // <= [A-Z_a-z]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [A-Z_a-z] # Choice
    return $$;
  }
  
  dynamic _parse_INT() {
    // LEXEME (TOKEN)
    // INT <- 'int' !IDENT_PART SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[60] >= pos) {
      $$ = _getFromCache(60);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[60] = pos;
    }  
    _token = 16;    
    _tokenStart = _cursor;    
    // => 'int' !IDENT_PART SPACING # Choice
    switch (_ch == 105 ? 0 : _ch == -1 ? 2 : 1) {
      // [i]
      case 0:
        // => 'int' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'int'
          $$ = _matchString(_strings6, 'int');
          // <= 'int'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'int'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'int' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'int'
      _failure(_expect28);
    }
    // <= 'int' !IDENT_PART SPACING # Choice
    if (_cacheable[60]) {
      _addToCache($$, pos, 60);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_INTEGER() {
    // MORHEME
    // INTEGER <- SIGN? [0-9]+ SPACING
    var $$;
    // => SIGN? [0-9]+ SPACING # Choice
    switch (_getState(_transitions11)) {
      // [+] [-] [0-9]
      case 0:
        // => SIGN? [0-9]+ SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => SIGN?
          var testing0 = _testing;
          _testing = _cursor;
          // => SIGN
          $$ = _parse_SIGN();
          // <= SIGN
          success = true; 
          _testing = testing0;
          // <= SIGN?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => [0-9]+
          var testing1;
          for (var first = true, reps; ;) {  
            // => [0-9]  
            $$ = _matchRange(48, 57);  
            // <= [0-9]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing1 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing1;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0-9]+
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // SIGN?
            final $1 = seq[0];
            // [0-9]+
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _parseInt($1, $2.join(), 10);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SIGN? [0-9]+ SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= SIGN? [0-9]+ SPACING # Choice
    return $$;
  }
  
  dynamic _parse_LEADING_SPACES() {
    // LEXEME (TOKEN)
    // LEADING_SPACES <- SPACING
    var $$;
    _token = 17;  
    _tokenStart = _cursor;  
    // => SPACING # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => SPACING
        $$ = _parse_SPACING();
        // <= SPACING
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: LEADING_SPACES
      _failure(_expect29);
    }
    // <= SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_LONG() {
    // MORHEME
    // LONG <- 'long' !IDENT_PART SPACING
    var $$;
    // => 'long' !IDENT_PART SPACING # Choice
    switch (_ch == 108 ? 0 : _ch == -1 ? 2 : 1) {
      // [l]
      case 0:
        // => 'long' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'long'
          $$ = _matchString(_strings15, 'long');
          // <= 'long'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'long'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'long' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: long
      _failure(_expect45);
    }
    // <= 'long' !IDENT_PART SPACING # Choice
    return $$;
  }
  
  dynamic _parse_LONG_TYPE() {
    // LEXEME (TOKEN)
    // LONG_TYPE <- LONG LONG / LONG
    var $$;
    _token = 18;  
    _tokenStart = _cursor;  
    // => LONG LONG / LONG # Choice
    switch (_ch == 108 ? 0 : _ch == -1 ? 2 : 1) {
      // [l]
      case 0:
        while (true) {
          // => LONG LONG # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => LONG
            $$ = _parse_LONG();
            // <= LONG
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => LONG
            $$ = _parse_LONG();
            // <= LONG
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // LONG
              final $1 = seq[0];
              // LONG
              final $2 = seq[1];
              final $start = startPos0;
              $$ = _createInt([$1, $2]);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= LONG LONG # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => LONG
          $$ = _parse_LONG();
          // <= LONG
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'long'
      _failure(_expect30);
    }
    // <= LONG LONG / LONG # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_MINUS() {
    // MORHEME
    // MINUS <- '-' SPACING
    var $$;
    // => '-' SPACING # Choice
    switch (_ch == 45 ? 0 : _ch == -1 ? 2 : 1) {
      // [-]
      case 0:
        // => '-' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '-'
          $$ = '-';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '-'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '-'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '-' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: -
      _failure(_expect34);
    }
    // <= '-' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_NUMBER() {
    // LEXEME (TOKEN)
    // NUMBER <- OCTAL_NUMBER / INTEGER
    var $$;          
    var pos = _cursor;             
    if(_cachePos[63] >= pos) {
      $$ = _getFromCache(63);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[63] = pos;
    }  
    _token = 19;    
    _tokenStart = _cursor;    
    // => OCTAL_NUMBER / INTEGER # Choice
    switch (_getState(_transitions14)) {
      // [+] [-] [0]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => OCTAL_NUMBER
          $$ = _parse_OCTAL_NUMBER();
          // <= OCTAL_NUMBER
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => INTEGER
          $$ = _parse_INTEGER();
          // <= INTEGER
          _startPos = startPos1;
          break;
        }
        break;
      // [1-9]
      case 1:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => INTEGER
        $$ = _parse_INTEGER();
        // <= INTEGER
        _startPos = startPos2;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NUMBER
      _failure(_expect31);
    }
    // <= OCTAL_NUMBER / INTEGER # Choice
    if (_cacheable[63]) {
      _addToCache($$, pos, 63);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OCTAL_NUMBER() {
    // MORHEME
    // OCTAL_NUMBER <- SIGN? [0] [0-9]+
    var $$;
    // => SIGN? [0] [0-9]+ # Choice
    switch (_getState(_transitions18)) {
      // [+] [-] [0]
      case 0:
        // => SIGN? [0] [0-9]+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => SIGN?
          var testing0 = _testing;
          _testing = _cursor;
          // => SIGN
          $$ = _parse_SIGN();
          // <= SIGN
          success = true; 
          _testing = testing0;
          // <= SIGN?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => [0]
          $$ = _matchChar(48, '0');
          // <= [0]
          if (!success) break;
          seq[1] = $$;
          // => [0-9]+
          var testing1;
          for (var first = true, reps; ;) {  
            // => [0-9]  
            $$ = _matchRange(48, 57);  
            // <= [0-9]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing1 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing1;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0-9]+
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // SIGN?
            final $1 = seq[0];
            // [0]
            final $2 = seq[1];
            // [0-9]+
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _parseInt($1, _flatten([$2, $3]).join(), 8);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SIGN? [0] [0-9]+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= SIGN? [0] [0-9]+ # Choice
    return $$;
  }
  
  dynamic _parse_OPEN_BRACE() {
    // LEXEME (TOKEN)
    // OPEN_BRACE <- '{' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[64] >= pos) {
      $$ = _getFromCache(64);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[64] = pos;
    }  
    _token = 20;    
    _tokenStart = _cursor;    
    // => '{' SPACING # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => '{' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '{'
          $$ = '{';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '{'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '{'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '{' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '{'
      _failure(_expect32);
    }
    // <= '{' SPACING # Choice
    if (_cacheable[64]) {
      _addToCache($$, pos, 64);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OPEN_BRACKET() {
    // LEXEME (TOKEN)
    // OPEN_BRACKET <- '[' SPACING
    var $$;
    _token = 21;  
    _tokenStart = _cursor;  
    // => '[' SPACING # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => '[' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '['
          $$ = '[';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '['
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '['
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '[' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect13);
    }
    // <= '[' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OPEN_PAREN() {
    // LEXEME (TOKEN)
    // OPEN_PAREN <- '(' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[66] >= pos) {
      $$ = _getFromCache(66);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[66] = pos;
    }  
    _token = 22;    
    _tokenStart = _cursor;    
    // => '(' SPACING # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => '(' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '('
          $$ = '(';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '('
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '('
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '(' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect33);
    }
    // <= '(' SPACING # Choice
    if (_cacheable[66]) {
      _addToCache($$, pos, 66);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_PLUS() {
    // MORHEME
    // PLUS <- '+' SPACING
    var $$;
    // => '+' SPACING # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        // => '+' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '+'
          $$ = '+';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '+'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '+'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '+' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: +
      _failure(_expect46);
    }
    // <= '+' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_POSITIVE_NUMBER() {
    // LEXEME (TOKEN)
    // POSITIVE_NUMBER <- !('-' SPACING) (OCTAL_NUMBER / INTEGER)
    var $$;          
    var pos = _cursor;             
    if(_cachePos[67] >= pos) {
      $$ = _getFromCache(67);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[67] = pos;
    }  
    _token = 23;    
    _tokenStart = _cursor;    
    // => !('-' SPACING) (OCTAL_NUMBER / INTEGER) # Choice
    switch (_getState(_transitions11)) {
      // [+] [-] [0-9]
      // EOF
      case 0:
      case 2:
        // => !('-' SPACING) (OCTAL_NUMBER / INTEGER) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !('-' SPACING)
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => ('-' SPACING) # Choice
          switch (_ch == 45 ? 0 : _ch == -1 ? 2 : 1) {
            // [-]
            case 0:
              // => '-' SPACING # Sequence
              var ch2 = _ch, pos2 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                // => '-'
                $$ = '-';
                success = true;
                if (++_cursor < _inputLen) {
                  _ch = _input[_cursor];
                } else {
                  _ch = -1;
                }
                // <= '-'
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                // => SPACING
                $$ = _parse_SPACING();
                // <= SPACING
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                break;
              }
              if (!success) {
                _ch = ch2;
                _cursor = pos2;
              }
              _startPos = startPos1;
              // <= '-' SPACING # Sequence
              break;
            // No matches
            // EOF
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: -
            _failure(_expect34);
          }
          // <= ('-' SPACING) # Choice
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !('-' SPACING)
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (OCTAL_NUMBER / INTEGER) # Choice
          switch (_getState(_transitions14)) {
            // [+] [-] [0]
            case 0:
              while (true) {
                var startPos2 = _startPos;
                _startPos = _cursor;
                // => OCTAL_NUMBER
                $$ = _parse_OCTAL_NUMBER();
                // <= OCTAL_NUMBER
                _startPos = startPos2;
                if (success) break;
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => INTEGER
                $$ = _parse_INTEGER();
                // <= INTEGER
                _startPos = startPos3;
                break;
              }
              break;
            // [1-9]
            case 1:
              var startPos4 = _startPos;
              _startPos = _cursor;
              // => INTEGER
              $$ = _parse_INTEGER();
              // <= INTEGER
              _startPos = startPos4;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (OCTAL_NUMBER / INTEGER) # Choice
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // !('-' SPACING)
            final $1 = seq[0];
            // (OCTAL_NUMBER / INTEGER)
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !('-' SPACING) (OCTAL_NUMBER / INTEGER) # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: POSITIVE_NUMBER
      _failure(_expect14);
    }
    // <= !('-' SPACING) (OCTAL_NUMBER / INTEGER) # Choice
    if (_cacheable[67]) {
      _addToCache($$, pos, 67);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_PointerParameter() {
    // SENTENCE (NONTERMINAL)
    // PointerParameter <- PointerType IDENTIFIER? AttributeSpecifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[23] >= pos) {
      $$ = _getFromCache(23);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[23] = pos;
    }  
    // => PointerType IDENTIFIER? AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => PointerType IDENTIFIER? AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerType
          $$ = _parse_PointerType();
          // <= PointerType
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true; 
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing1;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // PointerType
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ParameterDeclaration(attributes: $3, name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerType IDENTIFIER? AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= PointerType IDENTIFIER? AttributeSpecifiers? # Choice
    if (_cacheable[23]) {
      _addToCache($$, pos, 23);
    }    
    return $$;
  }
  
  dynamic _parse_PointerType() {
    // SENTENCE (NONTERMINAL)
    // PointerType <- TypeName ASTERISK+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[5] >= pos) {
      $$ = _getFromCache(5);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[5] = pos;
    }  
    // => TypeName ASTERISK+ # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => TypeName ASTERISK+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => TypeName
          $$ = _parse_TypeName();
          // <= TypeName
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ASTERISK+
          var testing0;
          for (var first = true, reps; ;) {  
            // => ASTERISK  
            $$ = _parse_ASTERISK();  
            // <= ASTERISK  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= ASTERISK+
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // TypeName
            final $1 = seq[0];
            // ASTERISK+
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _createPointer($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TypeName ASTERISK+ # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= TypeName ASTERISK+ # Choice
    if (_cacheable[5]) {
      _addToCache($$, pos, 5);
    }    
    return $$;
  }
  
  dynamic _parse_PointerVariableDeclaration() {
    // SENTENCE (NONTERMINAL)
    // PointerVariableDeclaration <- PointerType IDENTIFIER AttributeSpecifiers?
    var $$;
    // => PointerType IDENTIFIER AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => PointerType IDENTIFIER AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerType
          $$ = _parse_PointerType();
          // <= PointerType
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // PointerType
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new VariableDeclaration(attributes: $3, name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerType IDENTIFIER AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= PointerType IDENTIFIER AttributeSpecifiers? # Choice
    return $$;
  }
  
  dynamic _parse_RESERVED_WORD() {
    // MORHEME
    // RESERVED_WORD <- ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT)
    var $$;
    // => ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT) # Choice
    switch (_getState(_transitions19)) {
      // [_] [a-g] [i] [l] [r-w]
      case 0:
        // => ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') # Choice
          switch (_getState(_transitions20)) {
            // [_]
            case 0:
              while (true) {
                var startPos1 = _startPos;
                _startPos = _cursor;
                // => '_Bool'
                $$ = _matchString(_strings16, '_Bool');
                // <= '_Bool'
                _startPos = startPos1;
                if (success) break;
                var startPos2 = _startPos;
                _startPos = _cursor;
                // => '_Complex'
                $$ = _matchString(_strings17, '_Complex');
                // <= '_Complex'
                _startPos = startPos2;
                if (success) break;
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => '_Imaginary'
                $$ = _matchString(_strings18, '_Imaginary');
                // <= '_Imaginary'
                _startPos = startPos3;
                break;
              }
              break;
            // [a]
            case 1:
              var startPos4 = _startPos;
              _startPos = _cursor;
              // => 'auto'
              $$ = _matchString(_strings19, 'auto');
              // <= 'auto'
              _startPos = startPos4;
              break;
            // [b]
            case 2:
              var startPos5 = _startPos;
              _startPos = _cursor;
              // => 'break'
              $$ = _matchString(_strings20, 'break');
              // <= 'break'
              _startPos = startPos5;
              break;
            // [c]
            case 3:
              while (true) {
                var startPos6 = _startPos;
                _startPos = _cursor;
                // => 'case'
                $$ = _matchString(_strings21, 'case');
                // <= 'case'
                _startPos = startPos6;
                if (success) break;
                var startPos7 = _startPos;
                _startPos = _cursor;
                // => 'char'
                $$ = _matchString(_strings1, 'char');
                // <= 'char'
                _startPos = startPos7;
                if (success) break;
                var startPos8 = _startPos;
                _startPos = _cursor;
                // => 'const'
                $$ = _matchString(_strings2, 'const');
                // <= 'const'
                _startPos = startPos8;
                if (success) break;
                var startPos9 = _startPos;
                _startPos = _cursor;
                // => 'continue'
                $$ = _matchString(_strings22, 'continue');
                // <= 'continue'
                _startPos = startPos9;
                break;
              }
              break;
            // [d]
            case 4:
              while (true) {
                var startPos10 = _startPos;
                _startPos = _cursor;
                // => 'default'
                $$ = _matchString(_strings23, 'default');
                // <= 'default'
                _startPos = startPos10;
                if (success) break;
                var startPos11 = _startPos;
                _startPos = _cursor;
                // => 'do'
                $$ = _matchString(_strings24, 'do');
                // <= 'do'
                _startPos = startPos11;
                if (success) break;
                var startPos12 = _startPos;
                _startPos = _cursor;
                // => 'double'
                $$ = _matchString(_strings3, 'double');
                // <= 'double'
                _startPos = startPos12;
                break;
              }
              break;
            // [e]
            case 5:
              while (true) {
                var startPos13 = _startPos;
                _startPos = _cursor;
                // => 'else'
                $$ = _matchString(_strings25, 'else');
                // <= 'else'
                _startPos = startPos13;
                if (success) break;
                var startPos14 = _startPos;
                _startPos = _cursor;
                // => 'enum'
                $$ = _matchString(_strings4, 'enum');
                // <= 'enum'
                _startPos = startPos14;
                if (success) break;
                var startPos15 = _startPos;
                _startPos = _cursor;
                // => 'extern'
                $$ = _matchString(_strings26, 'extern');
                // <= 'extern'
                _startPos = startPos15;
                break;
              }
              break;
            // [f]
            case 6:
              while (true) {
                var startPos16 = _startPos;
                _startPos = _cursor;
                // => 'float'
                $$ = _matchString(_strings5, 'float');
                // <= 'float'
                _startPos = startPos16;
                if (success) break;
                var startPos17 = _startPos;
                _startPos = _cursor;
                // => 'for'
                $$ = _matchString(_strings27, 'for');
                // <= 'for'
                _startPos = startPos17;
                break;
              }
              break;
            // [g]
            case 7:
              var startPos18 = _startPos;
              _startPos = _cursor;
              // => 'goto'
              $$ = _matchString(_strings28, 'goto');
              // <= 'goto'
              _startPos = startPos18;
              break;
            // [i]
            case 8:
              while (true) {
                var startPos19 = _startPos;
                _startPos = _cursor;
                // => 'if'
                $$ = _matchString(_strings29, 'if');
                // <= 'if'
                _startPos = startPos19;
                if (success) break;
                var startPos20 = _startPos;
                _startPos = _cursor;
                // => 'inline'
                $$ = _matchString(_strings30, 'inline');
                // <= 'inline'
                _startPos = startPos20;
                if (success) break;
                var startPos21 = _startPos;
                _startPos = _cursor;
                // => 'int'
                $$ = _matchString(_strings6, 'int');
                // <= 'int'
                _startPos = startPos21;
                break;
              }
              break;
            // [l]
            case 9:
              var startPos22 = _startPos;
              _startPos = _cursor;
              // => 'long'
              $$ = _matchString(_strings15, 'long');
              // <= 'long'
              _startPos = startPos22;
              break;
            // [r]
            case 10:
              while (true) {
                var startPos23 = _startPos;
                _startPos = _cursor;
                // => 'register'
                $$ = _matchString(_strings31, 'register');
                // <= 'register'
                _startPos = startPos23;
                if (success) break;
                var startPos24 = _startPos;
                _startPos = _cursor;
                // => 'restrict'
                $$ = _matchString(_strings32, 'restrict');
                // <= 'restrict'
                _startPos = startPos24;
                if (success) break;
                var startPos25 = _startPos;
                _startPos = _cursor;
                // => 'return'
                $$ = _matchString(_strings33, 'return');
                // <= 'return'
                _startPos = startPos25;
                break;
              }
              break;
            // [s]
            case 11:
              while (true) {
                var startPos26 = _startPos;
                _startPos = _cursor;
                // => 'short'
                $$ = _matchString(_strings7, 'short');
                // <= 'short'
                _startPos = startPos26;
                if (success) break;
                var startPos27 = _startPos;
                _startPos = _cursor;
                // => 'signed'
                $$ = _matchString(_strings34, 'signed');
                // <= 'signed'
                _startPos = startPos27;
                if (success) break;
                var startPos28 = _startPos;
                _startPos = _cursor;
                // => 'sizeof'
                $$ = _matchString(_strings35, 'sizeof');
                // <= 'sizeof'
                _startPos = startPos28;
                if (success) break;
                var startPos29 = _startPos;
                _startPos = _cursor;
                // => 'static'
                $$ = _matchString(_strings36, 'static');
                // <= 'static'
                _startPos = startPos29;
                if (success) break;
                var startPos30 = _startPos;
                _startPos = _cursor;
                // => 'struct'
                $$ = _matchString(_strings8, 'struct');
                // <= 'struct'
                _startPos = startPos30;
                if (success) break;
                var startPos31 = _startPos;
                _startPos = _cursor;
                // => 'switch'
                $$ = _matchString(_strings37, 'switch');
                // <= 'switch'
                _startPos = startPos31;
                break;
              }
              break;
            // [t]
            case 12:
              var startPos32 = _startPos;
              _startPos = _cursor;
              // => 'typedef'
              $$ = _matchString(_strings9, 'typedef');
              // <= 'typedef'
              _startPos = startPos32;
              break;
            // [u]
            case 13:
              while (true) {
                var startPos33 = _startPos;
                _startPos = _cursor;
                // => 'union'
                $$ = _matchString(_strings10, 'union');
                // <= 'union'
                _startPos = startPos33;
                if (success) break;
                var startPos34 = _startPos;
                _startPos = _cursor;
                // => 'unsigned'
                $$ = _matchString(_strings38, 'unsigned');
                // <= 'unsigned'
                _startPos = startPos34;
                break;
              }
              break;
            // [v]
            case 14:
              while (true) {
                var startPos35 = _startPos;
                _startPos = _cursor;
                // => 'void'
                $$ = _matchString(_strings11, 'void');
                // <= 'void'
                _startPos = startPos35;
                if (success) break;
                var startPos36 = _startPos;
                _startPos = _cursor;
                // => 'volatile'
                $$ = _matchString(_strings39, 'volatile');
                // <= 'volatile'
                _startPos = startPos36;
                break;
              }
              break;
            // [w]
            case 15:
              var startPos37 = _startPos;
              _startPos = _cursor;
              // => 'while'
              $$ = _matchString(_strings40, 'while');
              // <= 'while'
              _startPos = startPos37;
              break;
            // No matches
            // EOF
            case 16:
            case 17:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while, _Bool, _Complex, _Imaginary
            _failure(_expect47);
          }
          // <= ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') # Choice
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => !(IDENT_START / IDENT_CONT)
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => (IDENT_START / IDENT_CONT) # Choice
          switch (_getState(_transitions17)) {
            // [0-9]
            case 0:
              var startPos38 = _startPos;
              _startPos = _cursor;
              // => IDENT_CONT
              $$ = _parse_IDENT_CONT();
              // <= IDENT_CONT
              _startPos = startPos38;
              break;
            // [A-Z] [_] [a-z]
            case 1:
              while (true) {
                var startPos39 = _startPos;
                _startPos = _cursor;
                // => IDENT_START
                $$ = _parse_IDENT_START();
                // <= IDENT_START
                _startPos = startPos39;
                if (success) break;
                var startPos40 = _startPos;
                _startPos = _cursor;
                // => IDENT_CONT
                $$ = _parse_IDENT_CONT();
                // <= IDENT_CONT
                _startPos = startPos40;
                break;
              }
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (IDENT_START / IDENT_CONT) # Choice
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !(IDENT_START / IDENT_CONT)
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary')
            final $1 = seq[0];
            // !(IDENT_START / IDENT_CONT)
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT) # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while, _Bool, _Complex, _Imaginary
      _failure(_expect47);
    }
    // <= ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !(IDENT_START / IDENT_CONT) # Choice
    return $$;
  }
  
  dynamic _parse_SEMICOLON() {
    // LEXEME (TOKEN)
    // SEMICOLON <- ';' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[68] >= pos) {
      $$ = _getFromCache(68);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[68] = pos;
    }  
    _token = 24;    
    _tokenStart = _cursor;    
    // => ';' SPACING # Choice
    switch (_ch == 59 ? 0 : _ch == -1 ? 2 : 1) {
      // [;]
      case 0:
        // => ';' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ';'
          $$ = ';';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ';'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ';'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ';' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ';'
      _failure(_expect35);
    }
    // <= ';' SPACING # Choice
    if (_cacheable[68]) {
      _addToCache($$, pos, 68);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SHORT() {
    // LEXEME (TOKEN)
    // SHORT <- 'short' !IDENT_PART SPACING
    var $$;
    _token = 25;  
    _tokenStart = _cursor;  
    // => 'short' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'short' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'short'
          $$ = _matchString(_strings7, 'short');
          // <= 'short'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'short'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'short' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'short'
      _failure(_expect36);
    }
    // <= 'short' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SIGN() {
    // MORHEME
    // SIGN <- PLUS / MINUS
    var $$;
    // => PLUS / MINUS # Choice
    switch (_getState(_transitions21)) {
      // [+]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => PLUS
        $$ = _parse_PLUS();
        // <= PLUS
        _startPos = startPos0;
        break;
      // [-]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => MINUS
        $$ = _parse_MINUS();
        // <= MINUS
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: +, -
      _failure(_expect48);
    }
    // <= PLUS / MINUS # Choice
    return $$;
  }
  
  dynamic _parse_SIGNED() {
    // MORHEME
    // SIGNED <- 'signed' !IDENT_PART SPACING
    var $$;
    // => 'signed' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'signed' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'signed'
          $$ = _matchString(_strings34, 'signed');
          // <= 'signed'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'signed'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'signed' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: signed
      _failure(_expect49);
    }
    // <= 'signed' !IDENT_PART SPACING # Choice
    return $$;
  }
  
  dynamic _parse_SIGNEDNESS() {
    // LEXEME (TOKEN)
    // SIGNEDNESS <- SIGNED / UNSIGNED
    var $$;          
    var pos = _cursor;             
    if(_cachePos[70] >= pos) {
      $$ = _getFromCache(70);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[70] = pos;
    }  
    _token = 26;    
    _tokenStart = _cursor;    
    // => SIGNED / UNSIGNED # Choice
    switch (_getState(_transitions9)) {
      // [s]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => SIGNED
        $$ = _parse_SIGNED();
        // <= SIGNED
        _startPos = startPos0;
        break;
      // [u]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => UNSIGNED
        $$ = _parse_UNSIGNED();
        // <= UNSIGNED
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SIGNEDNESS
      _failure(_expect37);
    }
    // <= SIGNED / UNSIGNED # Choice
    if (_cacheable[70]) {
      _addToCache($$, pos, 70);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SPACE() {
    // MORHEME
    // SPACE <- [\t-\n\r ]
    var $$;
    // => [\t-\n\r ] # Choice
    switch (_getState(_transitions22)) {
      // [\t-\n] [\r] [ ]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\t-\n\r ]
        $$ = _matchMapping(9, 32, _mapping2);
        // <= [\t-\n\r ]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [\t-\n\r ] # Choice
    return $$;
  }
  
  dynamic _parse_SPACING() {
    // MORHEME
    // SPACING <- (SPACE / COMMENT)*
    var $$;
    // => (SPACE / COMMENT)* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (SPACE / COMMENT)*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => (SPACE / COMMENT) # Choice
          switch (_getState(_transitions23)) {
            // [\t-\n] [\r] [ ]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => SPACE
              $$ = _parse_SPACE();
              // <= SPACE
              _startPos = startPos1;
              break;
            // [/]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => COMMENT
              $$ = _parse_COMMENT();
              // <= COMMENT
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (SPACE / COMMENT) # Choice
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= (SPACE / COMMENT)*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= (SPACE / COMMENT)* # Choice
    return $$;
  }
  
  dynamic _parse_STRUCT() {
    // LEXEME (TOKEN)
    // STRUCT <- 'struct' !IDENT_PART SPACING
    var $$;
    _token = 27;  
    _tokenStart = _cursor;  
    // => 'struct' !IDENT_PART SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'struct' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'struct'
          $$ = _matchString(_strings8, 'struct');
          // <= 'struct'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'struct'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'struct' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct'
      _failure(_expect38);
    }
    // <= 'struct' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SimpleParameter() {
    // SENTENCE (NONTERMINAL)
    // SimpleParameter <- Type IDENTIFIER? AttributeSpecifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[24] >= pos) {
      $$ = _getFromCache(24);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[24] = pos;
    }  
    // => Type IDENTIFIER? AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER? AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER?
          var testing0 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true; 
          _testing = testing0;
          // <= IDENTIFIER?
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing1;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Type
            final $1 = seq[0];
            // IDENTIFIER?
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ParameterDeclaration(attributes: $3, name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER? AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Type IDENTIFIER? AttributeSpecifiers? # Choice
    if (_cacheable[24]) {
      _addToCache($$, pos, 24);
    }    
    return $$;
  }
  
  dynamic _parse_SimpleVariableDeclaration() {
    // SENTENCE (NONTERMINAL)
    // SimpleVariableDeclaration <- Type IDENTIFIER AttributeSpecifiers?
    var $$;
    // => Type IDENTIFIER AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Type
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new VariableDeclaration(attributes: $3, name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Type IDENTIFIER AttributeSpecifiers? # Choice
    return $$;
  }
  
  dynamic _parse_StructDeclaration() {
    // SENTENCE (NONTERMINAL)
    // StructDeclaration <- StructTypeName OPEN_BRACE StructMemberList? CLOSE_BRACE AttributeSpecifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[30] >= pos) {
      $$ = _getFromCache(30);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[30] = pos;
    }  
    // => StructTypeName OPEN_BRACE StructMemberList? CLOSE_BRACE AttributeSpecifiers? # Choice
    switch (_getState(_transitions8)) {
      // [c] [s] [u]
      case 0:
        // => StructTypeName OPEN_BRACE StructMemberList? CLOSE_BRACE AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => StructTypeName
          $$ = _parse_StructTypeName();
          // <= StructTypeName
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          // => OPEN_BRACE
          $$ = _parse_OPEN_BRACE();
          // <= OPEN_BRACE
          if (!success) break;
          seq[1] = $$;
          // => StructMemberList?
          var testing0 = _testing;
          _testing = _cursor;
          // => StructMemberList
          $$ = _parse_StructMemberList();
          // <= StructMemberList
          success = true; 
          _testing = testing0;
          // <= StructMemberList?
          if (!success) break;
          seq[2] = $$;
          // => CLOSE_BRACE
          $$ = _parse_CLOSE_BRACE();
          // <= CLOSE_BRACE
          if (!success) break;
          seq[3] = $$;
          // => AttributeSpecifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing1;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          if (success) {    
            // StructTypeName
            final $1 = seq[0];
            // OPEN_BRACE
            final $2 = seq[1];
            // StructMemberList?
            final $3 = seq[2];
            // CLOSE_BRACE
            final $4 = seq[3];
            // AttributeSpecifiers?
            final $5 = seq[4];
            final $start = startPos0;
            $$ = new StructureDeclaration(attributes: $5, taggedType: $1, members: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= StructTypeName OPEN_BRACE StructMemberList? CLOSE_BRACE AttributeSpecifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union'
      _failure(_expect11);
    }
    // <= StructTypeName OPEN_BRACE StructMemberList? CLOSE_BRACE AttributeSpecifiers? # Choice
    if (_cacheable[30]) {
      _addToCache($$, pos, 30);
    }    
    return $$;
  }
  
  dynamic _parse_StructMember() {
    // SENTENCE (NONTERMINAL)
    // StructMember <- BitFieldParameter SEMICOLON / ArrayParameter SEMICOLON / TaggedTypeParameter SEMICOLON / PointerParameter SEMICOLON / SimpleParameter SEMICOLON
    var $$;
    // => BitFieldParameter SEMICOLON / ArrayParameter SEMICOLON / TaggedTypeParameter SEMICOLON / PointerParameter SEMICOLON / SimpleParameter SEMICOLON # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_]
      // EOF
      case 0:
      case 3:
        while (true) {
          // => BitFieldParameter SEMICOLON # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => BitFieldParameter
            $$ = _parse_BitFieldParameter();
            // <= BitFieldParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // BitFieldParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos0;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= BitFieldParameter SEMICOLON # Sequence
          if (success) break;
          // => ArrayParameter SEMICOLON # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ArrayParameter
            $$ = _parse_ArrayParameter();
            // <= ArrayParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ArrayParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos1;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= ArrayParameter SEMICOLON # Sequence
          if (success) break;
          // => PointerParameter SEMICOLON # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => PointerParameter
            $$ = _parse_PointerParameter();
            // <= PointerParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // PointerParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos2;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= PointerParameter SEMICOLON # Sequence
          if (success) break;
          // => SimpleParameter SEMICOLON # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SimpleParameter
            $$ = _parse_SimpleParameter();
            // <= SimpleParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // SimpleParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos3;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos3;
          // <= SimpleParameter SEMICOLON # Sequence
          break;
        }
        break;
      // [a-z]
      case 1:
        while (true) {
          // => BitFieldParameter SEMICOLON # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => BitFieldParameter
            $$ = _parse_BitFieldParameter();
            // <= BitFieldParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // BitFieldParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos4;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos4;
          // <= BitFieldParameter SEMICOLON # Sequence
          if (success) break;
          // => ArrayParameter SEMICOLON # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ArrayParameter
            $$ = _parse_ArrayParameter();
            // <= ArrayParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ArrayParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos5;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos5;
          // <= ArrayParameter SEMICOLON # Sequence
          if (success) break;
          // => TaggedTypeParameter SEMICOLON # Sequence
          var ch6 = _ch, pos6 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => TaggedTypeParameter
            $$ = _parse_TaggedTypeParameter();
            // <= TaggedTypeParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // TaggedTypeParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos6;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos6;
          // <= TaggedTypeParameter SEMICOLON # Sequence
          if (success) break;
          // => PointerParameter SEMICOLON # Sequence
          var ch7 = _ch, pos7 = _cursor, startPos7 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => PointerParameter
            $$ = _parse_PointerParameter();
            // <= PointerParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // PointerParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos7;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch7;
            _cursor = pos7;
          }
          _startPos = startPos7;
          // <= PointerParameter SEMICOLON # Sequence
          if (success) break;
          // => SimpleParameter SEMICOLON # Sequence
          var ch8 = _ch, pos8 = _cursor, startPos8 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SimpleParameter
            $$ = _parse_SimpleParameter();
            // <= SimpleParameter
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // SimpleParameter
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos8;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch8;
            _cursor = pos8;
          }
          _startPos = startPos8;
          // <= SimpleParameter SEMICOLON # Sequence
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= BitFieldParameter SEMICOLON / ArrayParameter SEMICOLON / TaggedTypeParameter SEMICOLON / PointerParameter SEMICOLON / SimpleParameter SEMICOLON # Choice
    return $$;
  }
  
  dynamic _parse_StructMemberList() {
    // SENTENCE (NONTERMINAL)
    // StructMemberList <- (StructMember)*
    var $$;
    // => (StructMember)* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (StructMember)*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => (StructMember) # Choice
          switch (_getState(_transitions1)) {
            // [A-Z] [_] [a-z]
            // EOF
            case 0:
            case 2:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => StructMember
              $$ = _parse_StructMember();
              // <= StructMember
              _startPos = startPos1;
              break;
            // No matches
            case 1:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
            _failure(_expect3);
          }
          // <= (StructMember) # Choice
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= (StructMember)*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
      // EOF
      case 2:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => (StructMember)*
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (StructMember) # Choice
            switch (_getState(_transitions1)) {
              // [A-Z] [_] [a-z]
              // EOF
              case 0:
              case 2:
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => StructMember
                $$ = _parse_StructMember();
                // <= StructMember
                _startPos = startPos3;
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
              _failure(_expect3);
            }
            // <= (StructMember) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          // <= (StructMember)*
          _startPos = startPos2;
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => (StructMember)*
          var testing2 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (StructMember) # Choice
            switch (_getState(_transitions1)) {
              // [A-Z] [_] [a-z]
              // EOF
              case 0:
              case 2:
                var startPos5 = _startPos;
                _startPos = _cursor;
                // => StructMember
                $$ = _parse_StructMember();
                // <= StructMember
                _startPos = startPos5;
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
              _failure(_expect3);
            }
            // <= (StructMember) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing2;
              $$ = reps;
              break; 
            }
          }
          // <= (StructMember)*
          _startPos = startPos4;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= (StructMember)* # Choice
    return $$;
  }
  
  dynamic _parse_StructTypeName() {
    // SENTENCE (NONTERMINAL)
    // StructTypeName <- CONST? (STRUCT / UNION) AttributeSpecifiers? IDENTIFIER?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[13] >= pos) {
      $$ = _getFromCache(13);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[13] = pos;
    }  
    // => CONST? (STRUCT / UNION) AttributeSpecifiers? IDENTIFIER? # Choice
    switch (_getState(_transitions8)) {
      // [c] [s] [u]
      case 0:
        // => CONST? (STRUCT / UNION) AttributeSpecifiers? IDENTIFIER? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => CONST?
          var testing0 = _testing;
          _testing = _cursor;
          // => CONST
          $$ = _parse_CONST();
          // <= CONST
          success = true; 
          _testing = testing0;
          // <= CONST?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => (STRUCT / UNION) # Choice
          switch (_getState(_transitions9)) {
            // [s]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => STRUCT
              $$ = _parse_STRUCT();
              // <= STRUCT
              _startPos = startPos1;
              break;
            // [u]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => UNION
              $$ = _parse_UNION();
              // <= UNION
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'struct', 'union'
            _failure(_expect11);
          }
          // <= (STRUCT / UNION) # Choice
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing1;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          // => IDENTIFIER?
          var testing2 = _testing;
          _testing = _cursor;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          success = true; 
          _testing = testing2;
          // <= IDENTIFIER?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // CONST?
            final $1 = seq[0];
            // (STRUCT / UNION)
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            // IDENTIFIER?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new TaggedTypeSpecification(attributes: $3, isConst: $1, kind: $2, tag: $4);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= CONST? (STRUCT / UNION) AttributeSpecifiers? IDENTIFIER? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union'
      _failure(_expect11);
    }
    // <= CONST? (STRUCT / UNION) AttributeSpecifiers? IDENTIFIER? # Choice
    if (_cacheable[13]) {
      _addToCache($$, pos, 13);
    }    
    return $$;
  }
  
  dynamic _parse_TYPEDEF() {
    // LEXEME (TOKEN)
    // TYPEDEF <- 'typedef' SPACING
    var $$;
    _token = 28;  
    _tokenStart = _cursor;  
    // => 'typedef' SPACING # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => 'typedef' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'typedef'
          $$ = _matchString(_strings9, 'typedef');
          // <= 'typedef'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'typedef'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'typedef' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'typedef'
      _failure(_expect15);
    }
    // <= 'typedef' SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_TaggedTypeDeclaration() {
    // SENTENCE (NONTERMINAL)
    // TaggedTypeDeclaration <- StructDeclaration / EnumDeclaration
    var $$;
    // => StructDeclaration / EnumDeclaration # Choice
    switch (_getState(_transitions13)) {
      // [c]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => StructDeclaration
          $$ = _parse_StructDeclaration();
          // <= StructDeclaration
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => EnumDeclaration
          $$ = _parse_EnumDeclaration();
          // <= EnumDeclaration
          _startPos = startPos1;
          break;
        }
        break;
      // [e]
      case 1:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => EnumDeclaration
        $$ = _parse_EnumDeclaration();
        // <= EnumDeclaration
        _startPos = startPos2;
        break;
      // [s] [u]
      case 2:
        var startPos3 = _startPos;
        _startPos = _cursor;
        // => StructDeclaration
        $$ = _parse_StructDeclaration();
        // <= StructDeclaration
        _startPos = startPos3;
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union', 'enum'
      _failure(_expect16);
    }
    // <= StructDeclaration / EnumDeclaration # Choice
    return $$;
  }
  
  dynamic _parse_TaggedTypeParameter() {
    // SENTENCE (NONTERMINAL)
    // TaggedTypeParameter <- (StructDeclaration / EnumDeclaration) IDENTIFIER
    var $$;
    // => (StructDeclaration / EnumDeclaration) IDENTIFIER # Choice
    switch (_getState(_transitions12)) {
      // [c] [e] [s] [u]
      case 0:
        // => (StructDeclaration / EnumDeclaration) IDENTIFIER # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (StructDeclaration / EnumDeclaration) # Choice
          switch (_getState(_transitions13)) {
            // [c]
            case 0:
              while (true) {
                var startPos1 = _startPos;
                _startPos = _cursor;
                // => StructDeclaration
                $$ = _parse_StructDeclaration();
                // <= StructDeclaration
                _startPos = startPos1;
                if (success) break;
                var startPos2 = _startPos;
                _startPos = _cursor;
                // => EnumDeclaration
                $$ = _parse_EnumDeclaration();
                // <= EnumDeclaration
                _startPos = startPos2;
                break;
              }
              break;
            // [e]
            case 1:
              var startPos3 = _startPos;
              _startPos = _cursor;
              // => EnumDeclaration
              $$ = _parse_EnumDeclaration();
              // <= EnumDeclaration
              _startPos = startPos3;
              break;
            // [s] [u]
            case 2:
              var startPos4 = _startPos;
              _startPos = _cursor;
              // => StructDeclaration
              $$ = _parse_StructDeclaration();
              // <= StructDeclaration
              _startPos = startPos4;
              break;
            // No matches
            // EOF
            case 3:
            case 4:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'enum', 'struct', 'union'
            _failure(_expect16);
          }
          // <= (StructDeclaration / EnumDeclaration) # Choice
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // (StructDeclaration / EnumDeclaration)
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new ParameterDeclaration(name: $2, type: $1.type);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (StructDeclaration / EnumDeclaration) IDENTIFIER # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'enum', 'struct', 'union'
      _failure(_expect16);
    }
    // <= (StructDeclaration / EnumDeclaration) IDENTIFIER # Choice
    return $$;
  }
  
  dynamic _parse_TaggedTypeVariableDeclaration() {
    // SENTENCE (NONTERMINAL)
    // TaggedTypeVariableDeclaration <- (StructDeclaration / EnumDeclaration) IDENTIFIER AttributeSpecifiers?
    var $$;
    // => (StructDeclaration / EnumDeclaration) IDENTIFIER AttributeSpecifiers? # Choice
    switch (_getState(_transitions12)) {
      // [c] [e] [s] [u]
      case 0:
        // => (StructDeclaration / EnumDeclaration) IDENTIFIER AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (StructDeclaration / EnumDeclaration) # Choice
          switch (_getState(_transitions13)) {
            // [c]
            case 0:
              while (true) {
                var startPos1 = _startPos;
                _startPos = _cursor;
                // => StructDeclaration
                $$ = _parse_StructDeclaration();
                // <= StructDeclaration
                _startPos = startPos1;
                if (success) break;
                var startPos2 = _startPos;
                _startPos = _cursor;
                // => EnumDeclaration
                $$ = _parse_EnumDeclaration();
                // <= EnumDeclaration
                _startPos = startPos2;
                break;
              }
              break;
            // [e]
            case 1:
              var startPos3 = _startPos;
              _startPos = _cursor;
              // => EnumDeclaration
              $$ = _parse_EnumDeclaration();
              // <= EnumDeclaration
              _startPos = startPos3;
              break;
            // [s] [u]
            case 2:
              var startPos4 = _startPos;
              _startPos = _cursor;
              // => StructDeclaration
              $$ = _parse_StructDeclaration();
              // <= StructDeclaration
              _startPos = startPos4;
              break;
            // No matches
            // EOF
            case 3:
            case 4:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 'struct', 'union', 'enum'
            _failure(_expect16);
          }
          // <= (StructDeclaration / EnumDeclaration) # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // (StructDeclaration / EnumDeclaration)
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new VariableDeclaration(attributes: $3, name: $2, type: $1.type);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (StructDeclaration / EnumDeclaration) IDENTIFIER AttributeSpecifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union', 'enum'
      _failure(_expect16);
    }
    // <= (StructDeclaration / EnumDeclaration) IDENTIFIER AttributeSpecifiers? # Choice
    return $$;
  }
  
  dynamic _parse_Type() {
    // SENTENCE (NONTERMINAL)
    // Type <- PointerType / ArrayType / TypeName
    var $$;          
    var pos = _cursor;             
    if(_cachePos[4] >= pos) {
      $$ = _getFromCache(4);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[4] = pos;
    }  
    // => PointerType / ArrayType / TypeName # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => PointerType
          $$ = _parse_PointerType();
          // <= PointerType
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => ArrayType
          $$ = _parse_ArrayType();
          // <= ArrayType
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => TypeName
          $$ = _parse_TypeName();
          // <= TypeName
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= PointerType / ArrayType / TypeName # Choice
    if (_cacheable[4]) {
      _addToCache($$, pos, 4);
    }    
    return $$;
  }
  
  dynamic _parse_TypeName() {
    // SENTENCE (NONTERMINAL)
    // TypeName <- CONST? IDENTIFIER AttributeSpecifiers? / CONST? SIGNEDNESS? (CHAR / INT) AttributeSpecifiers? / CONST? SIGNEDNESS? (SHORT / LONG_TYPE) INT? AttributeSpecifiers? / CONST? SIGNEDNESS AttributeSpecifiers? / CONST? (FLOAT / DOUBLE) AttributeSpecifiers? / CONST? VOID AttributeSpecifiers? / StructTypeName / EnumTypeName
    var $$;          
    var pos = _cursor;             
    if(_cachePos[6] >= pos) {
      $$ = _getFromCache(6);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[6] = pos;
    }  
    // => CONST? IDENTIFIER AttributeSpecifiers? / CONST? SIGNEDNESS? (CHAR / INT) AttributeSpecifiers? / CONST? SIGNEDNESS? (SHORT / LONG_TYPE) INT? AttributeSpecifiers? / CONST? SIGNEDNESS AttributeSpecifiers? / CONST? (FLOAT / DOUBLE) AttributeSpecifiers? / CONST? VOID AttributeSpecifiers? / StructTypeName / EnumTypeName # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_]
      // EOF
      case 0:
      case 3:
        // => CONST? IDENTIFIER AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => CONST?
          var testing0 = _testing;
          _testing = _cursor;
          // => CONST
          $$ = _parse_CONST();
          // <= CONST
          success = true; 
          _testing = testing0;
          // <= CONST?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing1;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // CONST?
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new SynonymTypeSpecification(attributes: $3, isConst: $1, name: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= CONST? IDENTIFIER AttributeSpecifiers? # Sequence
        break;
      // [a-z]
      case 1:
        while (true) {
          // => CONST? IDENTIFIER AttributeSpecifiers? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => CONST?
            var testing2 = _testing;
            _testing = _cursor;
            // => CONST
            $$ = _parse_CONST();
            // <= CONST
            success = true; 
            _testing = testing2;
            // <= CONST?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => IDENTIFIER
            $$ = _parse_IDENTIFIER();
            // <= IDENTIFIER
            if (!success) break;
            seq[1] = $$;
            // => AttributeSpecifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => AttributeSpecifiers
            $$ = _parse_AttributeSpecifiers();
            // <= AttributeSpecifiers
            success = true; 
            _testing = testing3;
            // <= AttributeSpecifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // CONST?
              final $1 = seq[0];
              // IDENTIFIER
              final $2 = seq[1];
              // AttributeSpecifiers?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new SynonymTypeSpecification(attributes: $3, isConst: $1, name: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= CONST? IDENTIFIER AttributeSpecifiers? # Sequence
          if (success) break;
          // => CONST? SIGNEDNESS? (CHAR / INT) AttributeSpecifiers? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => CONST?
            var testing4 = _testing;
            _testing = _cursor;
            // => CONST
            $$ = _parse_CONST();
            // <= CONST
            success = true; 
            _testing = testing4;
            // <= CONST?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => SIGNEDNESS?
            var testing5 = _testing;
            _testing = _cursor;
            // => SIGNEDNESS
            $$ = _parse_SIGNEDNESS();
            // <= SIGNEDNESS
            success = true; 
            _testing = testing5;
            // <= SIGNEDNESS?
            if (!success) break;
            seq[1] = $$;
            // => (CHAR / INT) # Choice
            switch (_getState(_transitions3)) {
              // [c]
              case 0:
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => CHAR
                $$ = _parse_CHAR();
                // <= CHAR
                _startPos = startPos3;
                break;
              // [i]
              case 1:
                var startPos4 = _startPos;
                _startPos = _cursor;
                // => INT
                $$ = _parse_INT();
                // <= INT
                _startPos = startPos4;
                break;
              // No matches
              // EOF
              case 2:
              case 3:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'char', 'int'
              _failure(_expect4);
            }
            // <= (CHAR / INT) # Choice
            if (!success) break;
            seq[2] = $$;
            // => AttributeSpecifiers?
            var testing6 = _testing;
            _testing = _cursor;
            // => AttributeSpecifiers
            $$ = _parse_AttributeSpecifiers();
            // <= AttributeSpecifiers
            success = true; 
            _testing = testing6;
            // <= AttributeSpecifiers?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // CONST?
              final $1 = seq[0];
              // SIGNEDNESS?
              final $2 = seq[1];
              // (CHAR / INT)
              final $3 = seq[2];
              // AttributeSpecifiers?
              final $4 = seq[3];
              final $start = startPos2;
              $$ = new IntegerTypeSpecification(attributes: $4, isConst: $1, name: _createInt([$2, $3]));
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= CONST? SIGNEDNESS? (CHAR / INT) AttributeSpecifiers? # Sequence
          if (success) break;
          // => CONST? SIGNEDNESS? (SHORT / LONG_TYPE) INT? AttributeSpecifiers? # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => CONST?
            var testing7 = _testing;
            _testing = _cursor;
            // => CONST
            $$ = _parse_CONST();
            // <= CONST
            success = true; 
            _testing = testing7;
            // <= CONST?
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => SIGNEDNESS?
            var testing8 = _testing;
            _testing = _cursor;
            // => SIGNEDNESS
            $$ = _parse_SIGNEDNESS();
            // <= SIGNEDNESS
            success = true; 
            _testing = testing8;
            // <= SIGNEDNESS?
            if (!success) break;
            seq[1] = $$;
            // => (SHORT / LONG_TYPE) # Choice
            switch (_getState(_transitions4)) {
              // [l]
              case 0:
                var startPos6 = _startPos;
                _startPos = _cursor;
                // => LONG_TYPE
                $$ = _parse_LONG_TYPE();
                // <= LONG_TYPE
                _startPos = startPos6;
                break;
              // [s]
              case 1:
                var startPos7 = _startPos;
                _startPos = _cursor;
                // => SHORT
                $$ = _parse_SHORT();
                // <= SHORT
                _startPos = startPos7;
                break;
              // No matches
              // EOF
              case 2:
              case 3:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'short', 'long'
              _failure(_expect5);
            }
            // <= (SHORT / LONG_TYPE) # Choice
            if (!success) break;
            seq[2] = $$;
            // => INT?
            var testing9 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing9;
            // <= INT?
            if (!success) break;
            seq[3] = $$;
            // => AttributeSpecifiers?
            var testing10 = _testing;
            _testing = _cursor;
            // => AttributeSpecifiers
            $$ = _parse_AttributeSpecifiers();
            // <= AttributeSpecifiers
            success = true; 
            _testing = testing10;
            // <= AttributeSpecifiers?
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              // CONST?
              final $1 = seq[0];
              // SIGNEDNESS?
              final $2 = seq[1];
              // (SHORT / LONG_TYPE)
              final $3 = seq[2];
              // INT?
              final $4 = seq[3];
              // AttributeSpecifiers?
              final $5 = seq[4];
              final $start = startPos5;
              $$ = new IntegerTypeSpecification(attributes: $5, isConst: $1, name: _createInt([$2, $3, $4]));
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos5;
          // <= CONST? SIGNEDNESS? (SHORT / LONG_TYPE) INT? AttributeSpecifiers? # Sequence
          if (success) break;
          // => CONST? SIGNEDNESS AttributeSpecifiers? # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos8 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => CONST?
            var testing11 = _testing;
            _testing = _cursor;
            // => CONST
            $$ = _parse_CONST();
            // <= CONST
            success = true; 
            _testing = testing11;
            // <= CONST?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIGNEDNESS
            $$ = _parse_SIGNEDNESS();
            // <= SIGNEDNESS
            if (!success) break;
            seq[1] = $$;
            // => AttributeSpecifiers?
            var testing12 = _testing;
            _testing = _cursor;
            // => AttributeSpecifiers
            $$ = _parse_AttributeSpecifiers();
            // <= AttributeSpecifiers
            success = true; 
            _testing = testing12;
            // <= AttributeSpecifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // CONST?
              final $1 = seq[0];
              // SIGNEDNESS
              final $2 = seq[1];
              // AttributeSpecifiers?
              final $3 = seq[2];
              final $start = startPos8;
              $$ = new IntegerTypeSpecification(attributes: $3, isConst: $1, name: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos8;
          // <= CONST? SIGNEDNESS AttributeSpecifiers? # Sequence
          if (success) break;
          // => CONST? (FLOAT / DOUBLE) AttributeSpecifiers? # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos9 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => CONST?
            var testing13 = _testing;
            _testing = _cursor;
            // => CONST
            $$ = _parse_CONST();
            // <= CONST
            success = true; 
            _testing = testing13;
            // <= CONST?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => (FLOAT / DOUBLE) # Choice
            switch (_getState(_transitions5)) {
              // [d]
              case 0:
                var startPos10 = _startPos;
                _startPos = _cursor;
                // => DOUBLE
                $$ = _parse_DOUBLE();
                // <= DOUBLE
                _startPos = startPos10;
                break;
              // [f]
              case 1:
                var startPos11 = _startPos;
                _startPos = _cursor;
                // => FLOAT
                $$ = _parse_FLOAT();
                // <= FLOAT
                _startPos = startPos11;
                break;
              // No matches
              // EOF
              case 2:
              case 3:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 'float', 'double'
              _failure(_expect6);
            }
            // <= (FLOAT / DOUBLE) # Choice
            if (!success) break;
            seq[1] = $$;
            // => AttributeSpecifiers?
            var testing14 = _testing;
            _testing = _cursor;
            // => AttributeSpecifiers
            $$ = _parse_AttributeSpecifiers();
            // <= AttributeSpecifiers
            success = true; 
            _testing = testing14;
            // <= AttributeSpecifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // CONST?
              final $1 = seq[0];
              // (FLOAT / DOUBLE)
              final $2 = seq[1];
              // AttributeSpecifiers?
              final $3 = seq[2];
              final $start = startPos9;
              $$ = new FloatTypeSpecification(attributes: $3, isConst: $1, name: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos9;
          // <= CONST? (FLOAT / DOUBLE) AttributeSpecifiers? # Sequence
          if (success) break;
          // => CONST? VOID AttributeSpecifiers? # Sequence
          var ch6 = _ch, pos6 = _cursor, startPos12 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => CONST?
            var testing15 = _testing;
            _testing = _cursor;
            // => CONST
            $$ = _parse_CONST();
            // <= CONST
            success = true; 
            _testing = testing15;
            // <= CONST?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => VOID
            $$ = _parse_VOID();
            // <= VOID
            if (!success) break;
            seq[1] = $$;
            // => AttributeSpecifiers?
            var testing16 = _testing;
            _testing = _cursor;
            // => AttributeSpecifiers
            $$ = _parse_AttributeSpecifiers();
            // <= AttributeSpecifiers
            success = true; 
            _testing = testing16;
            // <= AttributeSpecifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // CONST?
              final $1 = seq[0];
              // VOID
              final $2 = seq[1];
              // AttributeSpecifiers?
              final $3 = seq[2];
              final $start = startPos12;
              $$ = new VoidTypeSpecification(attributes: $3, isConst: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos12;
          // <= CONST? VOID AttributeSpecifiers? # Sequence
          if (success) break;
          var startPos13 = _startPos;
          _startPos = _cursor;
          // => StructTypeName
          $$ = _parse_StructTypeName();
          // <= StructTypeName
          _startPos = startPos13;
          if (success) break;
          var startPos14 = _startPos;
          _startPos = _cursor;
          // => EnumTypeName
          $$ = _parse_EnumTypeName();
          // <= EnumTypeName
          _startPos = startPos14;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= CONST? IDENTIFIER AttributeSpecifiers? / CONST? SIGNEDNESS? (CHAR / INT) AttributeSpecifiers? / CONST? SIGNEDNESS? (SHORT / LONG_TYPE) INT? AttributeSpecifiers? / CONST? SIGNEDNESS AttributeSpecifiers? / CONST? (FLOAT / DOUBLE) AttributeSpecifiers? / CONST? VOID AttributeSpecifiers? / StructTypeName / EnumTypeName # Choice
    if (_cacheable[6]) {
      _addToCache($$, pos, 6);
    }    
    return $$;
  }
  
  dynamic _parse_TypedefArrayTypeSpecification() {
    // SENTENCE (NONTERMINAL)
    // TypedefArrayTypeSpecification <- Type IDENTIFIER ArrayDimension AttributeSpecifiers?
    var $$;
    // => Type IDENTIFIER ArrayDimension AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER ArrayDimension AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => ArrayDimension
          $$ = _parse_ArrayDimension();
          // <= ArrayDimension
          if (!success) break;
          seq[2] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Type
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // ArrayDimension
            final $3 = seq[2];
            // AttributeSpecifiers?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new TypedefTypeSpecification(attributes: $4, name: $2, type: _createArray($1, $3));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER ArrayDimension AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Type IDENTIFIER ArrayDimension AttributeSpecifiers? # Choice
    return $$;
  }
  
  dynamic _parse_TypedefDeclaration() {
    // SENTENCE (NONTERMINAL)
    // TypedefDeclaration <- TYPEDEF AttributeSpecifiers? TypedefTypeSpecification
    var $$;
    // => TYPEDEF AttributeSpecifiers? TypedefTypeSpecification # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => TYPEDEF AttributeSpecifiers? TypedefTypeSpecification # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => TYPEDEF
          $$ = _parse_TYPEDEF();
          // <= TYPEDEF
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[1] = $$;
          // => TypedefTypeSpecification
          $$ = _parse_TypedefTypeSpecification();
          // <= TypedefTypeSpecification
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // TYPEDEF
            final $1 = seq[0];
            // AttributeSpecifiers?
            final $2 = seq[1];
            // TypedefTypeSpecification
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new TypedefDeclaration(attributes: $2, type: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TYPEDEF AttributeSpecifiers? TypedefTypeSpecification # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'typedef'
      _failure(_expect15);
    }
    // <= TYPEDEF AttributeSpecifiers? TypedefTypeSpecification # Choice
    return $$;
  }
  
  dynamic _parse_TypedefSynonymTypeSpecification() {
    // SENTENCE (NONTERMINAL)
    // TypedefSynonymTypeSpecification <- Type IDENTIFIER AttributeSpecifiers?
    var $$;
    // => Type IDENTIFIER AttributeSpecifiers? # Choice
    switch (_getState(_transitions1)) {
      // [A-Z] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Type IDENTIFIER AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Type
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new TypedefTypeSpecification(attributes: $3, name: $2, type: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Type IDENTIFIER AttributeSpecifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= Type IDENTIFIER AttributeSpecifiers? # Choice
    return $$;
  }
  
  dynamic _parse_TypedefTaggedTypeSpecification() {
    // SENTENCE (NONTERMINAL)
    // TypedefTaggedTypeSpecification <- TaggedTypeDeclaration IDENTIFIER AttributeSpecifiers?
    var $$;
    // => TaggedTypeDeclaration IDENTIFIER AttributeSpecifiers? # Choice
    switch (_getState(_transitions12)) {
      // [c] [e] [s] [u]
      case 0:
        // => TaggedTypeDeclaration IDENTIFIER AttributeSpecifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => TaggedTypeDeclaration
          $$ = _parse_TaggedTypeDeclaration();
          // <= TaggedTypeDeclaration
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          seq[1] = $$;
          // => AttributeSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => AttributeSpecifiers
          $$ = _parse_AttributeSpecifiers();
          // <= AttributeSpecifiers
          success = true; 
          _testing = testing0;
          // <= AttributeSpecifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // TaggedTypeDeclaration
            final $1 = seq[0];
            // IDENTIFIER
            final $2 = seq[1];
            // AttributeSpecifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new TypedefTypeSpecification(attributes: $3, name: $2, type: $1.type);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TaggedTypeDeclaration IDENTIFIER AttributeSpecifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'struct', 'union', 'enum'
      _failure(_expect16);
    }
    // <= TaggedTypeDeclaration IDENTIFIER AttributeSpecifiers? # Choice
    return $$;
  }
  
  dynamic _parse_TypedefTypeSpecification() {
    // SENTENCE (NONTERMINAL)
    // TypedefTypeSpecification <- TypedefArrayTypeSpecification / TypedefTaggedTypeSpecification / TypedefSynonymTypeSpecification
    var $$;
    // => TypedefArrayTypeSpecification / TypedefTaggedTypeSpecification / TypedefSynonymTypeSpecification # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_]
      // EOF
      case 0:
      case 3:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => TypedefArrayTypeSpecification
          $$ = _parse_TypedefArrayTypeSpecification();
          // <= TypedefArrayTypeSpecification
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => TypedefSynonymTypeSpecification
          $$ = _parse_TypedefSynonymTypeSpecification();
          // <= TypedefSynonymTypeSpecification
          _startPos = startPos1;
          break;
        }
        break;
      // [a-z]
      case 1:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => TypedefArrayTypeSpecification
          $$ = _parse_TypedefArrayTypeSpecification();
          // <= TypedefArrayTypeSpecification
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => TypedefTaggedTypeSpecification
          $$ = _parse_TypedefTaggedTypeSpecification();
          // <= TypedefTaggedTypeSpecification
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => TypedefSynonymTypeSpecification
          $$ = _parse_TypedefSynonymTypeSpecification();
          // <= TypedefSynonymTypeSpecification
          _startPos = startPos4;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= TypedefArrayTypeSpecification / TypedefTaggedTypeSpecification / TypedefSynonymTypeSpecification # Choice
    return $$;
  }
  
  dynamic _parse_UNION() {
    // LEXEME (TOKEN)
    // UNION <- 'union' !IDENT_PART SPACING
    var $$;
    _token = 29;  
    _tokenStart = _cursor;  
    // => 'union' !IDENT_PART SPACING # Choice
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      // [u]
      case 0:
        // => 'union' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'union'
          $$ = _matchString(_strings10, 'union');
          // <= 'union'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'union'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'union' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'union'
      _failure(_expect39);
    }
    // <= 'union' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_UNSIGNED() {
    // MORHEME
    // UNSIGNED <- 'unsigned' !IDENT_PART SPACING
    var $$;
    // => 'unsigned' !IDENT_PART SPACING # Choice
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      // [u]
      case 0:
        // => 'unsigned' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'unsigned'
          $$ = _matchString(_strings38, 'unsigned');
          // <= 'unsigned'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'unsigned'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'unsigned' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: unsigned
      _failure(_expect50);
    }
    // <= 'unsigned' !IDENT_PART SPACING # Choice
    return $$;
  }
  
  dynamic _parse_VA_LIST_PARAMETER() {
    // LEXEME (TOKEN)
    // VA_LIST_PARAMETER <- ELLIPSIS
    var $$;
    _token = 30;  
    _tokenStart = _cursor;  
    // => ELLIPSIS # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => ELLIPSIS
        $$ = _parse_ELLIPSIS();
        // <= ELLIPSIS
        if (success) {    
          // ELLIPSIS
          final $1 = $$;
          final $start = startPos0;
          $$ = new ParameterDeclaration(type: new VaListTypeSpecification());
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '...'
      _failure(_expect40);
    }
    // <= ELLIPSIS # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_VOID() {
    // LEXEME (TOKEN)
    // VOID <- 'void' !IDENT_PART SPACING
    var $$;
    _token = 31;  
    _tokenStart = _cursor;  
    // => 'void' !IDENT_PART SPACING # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        // => 'void' !IDENT_PART SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'void'
          $$ = _matchString(_strings11, 'void');
          // <= 'void'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENT_PART
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENT_PART
          $$ = _parse_IDENT_PART();
          // <= IDENT_PART
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENT_PART
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'void'
            final $1 = seq[0];
            // !IDENT_PART
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'void' !IDENT_PART SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'void'
      _failure(_expect41);
    }
    // <= 'void' !IDENT_PART SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_VariableDeclaration() {
    // SENTENCE (NONTERMINAL)
    // VariableDeclaration <- ArrayVariableDeclaration / TaggedTypeVariableDeclaration / PointerVariableDeclaration / SimpleVariableDeclaration
    var $$;
    // => ArrayVariableDeclaration / TaggedTypeVariableDeclaration / PointerVariableDeclaration / SimpleVariableDeclaration # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [_]
      // EOF
      case 0:
      case 3:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => ArrayVariableDeclaration
          $$ = _parse_ArrayVariableDeclaration();
          // <= ArrayVariableDeclaration
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => PointerVariableDeclaration
          $$ = _parse_PointerVariableDeclaration();
          // <= PointerVariableDeclaration
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => SimpleVariableDeclaration
          $$ = _parse_SimpleVariableDeclaration();
          // <= SimpleVariableDeclaration
          _startPos = startPos2;
          break;
        }
        break;
      // [a-z]
      case 1:
        while (true) {
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => ArrayVariableDeclaration
          $$ = _parse_ArrayVariableDeclaration();
          // <= ArrayVariableDeclaration
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => TaggedTypeVariableDeclaration
          $$ = _parse_TaggedTypeVariableDeclaration();
          // <= TaggedTypeVariableDeclaration
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          // => PointerVariableDeclaration
          $$ = _parse_PointerVariableDeclaration();
          // <= PointerVariableDeclaration
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          _startPos = _cursor;
          // => SimpleVariableDeclaration
          $$ = _parse_SimpleVariableDeclaration();
          // <= SimpleVariableDeclaration
          _startPos = startPos6;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, 'char', 'int', 'short', 'long', SIGNEDNESS, 'float', 'double', 'void', 'struct', 'union', 'enum'
      _failure(_expect3);
    }
    // <= ArrayVariableDeclaration / TaggedTypeVariableDeclaration / PointerVariableDeclaration / SimpleVariableDeclaration # Choice
    return $$;
  }
  
  dynamic _parse_ZERO() {
    // MORHEME
    // ZERO <- [0]+ ![0-9]+
    var $$;
    // => [0]+ ![0-9]+ # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => [0]+ ![0-9]+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => [0]+
          var testing0;
          for (var first = true, reps; ;) {  
            // => [0]  
            $$ = _matchChar(48, '0');  
            // <= [0]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0]+
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ![0-9]+
          var ch1 = _ch, pos1 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          // => [0-9]+
          var testing2;
          for (var first = true, reps; ;) {  
            // => [0-9]  
            $$ = _matchRange(48, 57);  
            // <= [0-9]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing2 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing2;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0-9]+
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing1;
          $$ = null;
          success = !success;
          // <= ![0-9]+
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // [0]+
            final $1 = seq[0];
            // ![0-9]+
            final $2 = seq[1];
            final $start = startPos0;
            $$ = 0;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= [0]+ ![0-9]+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [0]+ ![0-9]+ # Choice
    return $$;
  }
  
  dynamic _parse_ZERO_NUMBER() {
    // LEXEME (TOKEN)
    // ZERO_NUMBER <- ZERO SPACING
    var $$;
    _token = 32;  
    _tokenStart = _cursor;  
    // => ZERO SPACING # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => ZERO SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ZERO
          $$ = _parse_ZERO();
          // <= ZERO
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ZERO
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ZERO SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ZERO_NUMBER
      _failure(_expect42);
    }
    // <= ZERO SPACING # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  String _text([int offset = 0]) {
    return new String.fromCharCodes(_input.sublist(_startPos + offset, _cursor));
  }
  
  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }
  
    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }
  
    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }
  
    return start;
  }
  
  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }
  
    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }
  
    codePoints.length = pos;
    return codePoints;
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<CParserError> errors() {
    if (success) {
      return <CParserError>[];
    }
  
    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    } 
    
    String getc(int position) {  
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";      
      }       
      return "end of file";
    }
  
    var errors = <CParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<CParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();  
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new CParserError(CParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {      
        var found = getc(_failurePos);      
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new CParserError(CParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }        
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;  
  }
  
  dynamic parse_Declarations() {
    // SENTENCE (NONTERMINAL)
    // Declarations <- LEADING_SPACES? DeclarationList? EOF
    var $$;
    // => LEADING_SPACES? DeclarationList? EOF # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        // => LEADING_SPACES? DeclarationList? EOF # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => LEADING_SPACES?
          var testing0 = _testing;
          _testing = _cursor;
          // => LEADING_SPACES
          $$ = _parse_LEADING_SPACES();
          // <= LEADING_SPACES
          success = true; 
          _testing = testing0;
          // <= LEADING_SPACES?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => DeclarationList?
          var testing1 = _testing;
          _testing = _cursor;
          // => DeclarationList
          $$ = _parse_DeclarationList();
          // <= DeclarationList
          success = true; 
          _testing = testing1;
          // <= DeclarationList?
          if (!success) break;
          seq[1] = $$;
          // => EOF
          $$ = _parse_EOF();
          // <= EOF
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // LEADING_SPACES?
            final $1 = seq[0];
            // DeclarationList?
            final $2 = seq[1];
            // EOF
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= LEADING_SPACES? DeclarationList? EOF # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= LEADING_SPACES? DeclarationList? EOF # Choice
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }      
    _cursor = pos;
    _cache = new List<Map<int, List>>(96);
    _cachePos = new List<int>.filled(96, -1);  
    _cacheable = new List<bool>.filled(96, false);
    _ch = -1;
    _errors = <CParserError>[];   
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;        
    _testing = -1;
    _token = null;
    _tokenStart = null;  
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;    
  }
  
}

class CParserError {
  static const int EXPECTED = 1;    
      
  static const int MALFORMED = 2;    
      
  static const int MISSING = 3;    
      
  static const int UNEXPECTED = 4;    
      
  static const int UNTERMINATED = 5;    
      
  final int hashCode = 0;
  
  final String message;
  
  final int position;
  
  final int start;
  
  final int type;
  
  CParserError(this.type, this.position, this.start, this.message);
  
  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is CParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;  
    }
    return false;
  }
  
}

