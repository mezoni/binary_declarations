// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

library binary_declarations.internal.c_parser;

import "dart:math";
import "package:binary_declarations/binary_declarations.dart";

Expression _buildBinary(Expression first, List rest) {
  Expression builder(Expression result, List element) {
    return new BinaryExpression(left: result, operator: element[0], right: element[1]);
  };
  return _buildTree(first, rest, builder);        
}

Expression _buildTree(Expression first, List rest, builder(Expression result, List rest)) {
  var result = first;    
  for (var i = 0; i < rest.length; i++) {
    result = builder(result, rest[i]);
  }
  return result;
}

String _chars2str(List<int> chars) {
   if (chars == null) {
     return "";
   }
   return new String.fromCharCodes(chars);
 }

Expression _conditional(Expression condition, Expression left, Expression right) {  
  return new ConditionalExpression(condition: condition, left: left, right: right);
}

FloatingPointLiteral _floatLiteral(String source) {
  var value = _parserFloat(source);
  return new FloatingPointLiteral(text: source, value: value);
}

Identifier _ident(List parts) {
  var list = [];
  for (var part in parts) {
    if (part != null) {
      list.add(part);
    }
  }

  return new Identifier(name: list.join(" "));
}

int _escape(String ch) {
  switch(ch) {
    case "a":
      return 0x07;
    case "b":
      return 0x08;
    case "f":
      return 0x0c;
    case "n":
      return 0x0a;
    case "r":
      return 0x0d;
    case "t":
      return 0x09;
    case "v":
      return 0x0b;
    case "\'":
      return 0x27;
    case "\"":
      return 0x22;
    case "\?":
      return 0x3f;
    default:
      throw new StateError("Unknown escape sequence: \\$ch");  
  }
}

double _parserFloat(String source) {
  source = source.toLowerCase();
  var hex = false;
  if (source.startsWith("0x")) {
    source = source.substring(2);
    hex = true;
  }
  var length = source.length;
  var endsWith = source[length - 1];
  if (endsWith == "f" || endsWith == "l") {
    source = source.substring(0, length - 1);
  }
  if (!hex) {
    return double.parse(source);
  }
  var index = source.indexOf("p");
  var exponent = int.parse(source.substring(index + 1));
  source = source.substring(0, index);
  index = source.indexOf(".");
  int integer = 0;
  int fractional = 0;
  if (index == 0) {
    fractional = int.parse(source.substring(1), radix: 16);
  } else if (index > 0) {
    integer = int.parse(source.substring(0, index), radix: 16);
    fractional = int.parse(source.substring(index + 1), radix: 16);
  } else {
    integer = int.parse(source, radix: 16);
  }
  var d = double.parse(".$fractional") * .625;
  return (integer + d) * pow(2, exponent);
}

int _parseInt(String sign, String digits, int radix) {
  if (sign == null) {
    sign = "";
  }
  return int.parse("$sign$digits", radix: radix);   
}

List _removeNull(List list) {  
  var result = list.toList();
  result.retainWhere((e) => e != null);
  return result;
}

String _strValue(List<List<int>> list) {
  var chars = <int>[];
  for (var element in list) {
    chars.addAll(element);
  }
  return new String.fromCharCodes(chars);
}

Expression _unary(String operator, Expression operand) {  
  return new UnaryExpression(operand: operand, operator: operator);
}

class CParser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));
  
  static final List<String> _expect0 = <String>["EOF"];
  
  static final List<String> _expect1 = <String>[];
  
  static final List<String> _expect10 = <String>["<<", ">>"];
  
  static final List<String> _expect100 = <String>["SIMPLE_ESCAPE_SEQUENCE"];
  
  static final List<String> _expect101 = <String>["\\U", "\\u"];
  
  static final List<String> _expect11 = <String>["+", "-"];
  
  static final List<String> _expect12 = <String>["%", "*", "/"];
  
  static final List<String> _expect13 = <String>["\'", "\'0\'", "(", ".", "DIGIT", "HEXADECIMAL_PREFIX", "L\'", "NONDIGIT", "NONZERO_DIGIT", "\\U", "\\u", "sizeof"];
  
  static final List<String> _expect14 = <String>["sizeof"];
  
  static final List<String> _expect15 = <String>["\'", "\'0\'", ".", "DIGIT", "HEXADECIMAL_PREFIX", "L\'", "NONZERO_DIGIT"];
  
  static final List<String> _expect16 = <String>[".", "DIGIT", "HEXADECIMAL_PREFIX"];
  
  static final List<String> _expect17 = <String>[".", "DIGIT"];
  
  static final List<String> _expect18 = <String>["("];
  
  static final List<String> _expect19 = <String>[")"];
  
  static final List<String> _expect2 = <String>[";", "NONDIGIT", "\\U", "\\u", "_Bool", "char", "double", "enum", "float", "int", "long", "short", "signed", "struct", "typedef", "union", "unsigned", "void"];
  
  static final List<String> _expect20 = <String>["!", "+", "-", "~"];
  
  static final List<String> _expect21 = <String>["+"];
  
  static final List<String> _expect22 = <String>["-"];
  
  static final List<String> _expect23 = <String>["~"];
  
  static final List<String> _expect24 = <String>["!"];
  
  static final List<String> _expect25 = <String>["*"];
  
  static final List<String> _expect26 = <String>["/"];
  
  static final List<String> _expect27 = <String>["%"];
  
  static final List<String> _expect28 = <String>["<<"];
  
  static final List<String> _expect29 = <String>[">>"];
  
  static final List<String> _expect3 = <String>["NONDIGIT", "\\U", "\\u", "_Bool", "char", "double", "enum", "float", "int", "long", "short", "signed", "struct", "union", "unsigned", "void"];
  
  static final List<String> _expect30 = <String>["<"];
  
  static final List<String> _expect31 = <String>[">"];
  
  static final List<String> _expect32 = <String>["<="];
  
  static final List<String> _expect33 = <String>[">="];
  
  static final List<String> _expect34 = <String>["=="];
  
  static final List<String> _expect35 = <String>["!="];
  
  static final List<String> _expect36 = <String>["&"];
  
  static final List<String> _expect37 = <String>["^"];
  
  static final List<String> _expect38 = <String>["|"];
  
  static final List<String> _expect39 = <String>["&&"];
  
  static final List<String> _expect4 = <String>["__attribute__"];
  
  static final List<String> _expect40 = <String>["||"];
  
  static final List<String> _expect41 = <String>["?"];
  
  static final List<String> _expect42 = <String>[":"];
  
  static final List<String> _expect43 = <String>["const", "volatile"];
  
  static final List<String> _expect44 = <String>["char", "int", "long", "short", "signed", "unsigned"];
  
  static final List<String> _expect45 = <String>["double", "float"];
  
  static final List<String> _expect46 = <String>["void"];
  
  static final List<String> _expect47 = <String>["_Bool"];
  
  static final List<String> _expect48 = <String>["struct", "union"];
  
  static final List<String> _expect49 = <String>["{"];
  
  static final List<String> _expect5 = <String>["NONDIGIT", "\\U", "\\u"];
  
  static final List<String> _expect50 = <String>["\'0\'", "HEXADECIMAL_PREFIX", "NONZERO_DIGIT"];
  
  static final List<String> _expect51 = <String>["*", "["];
  
  static final List<String> _expect52 = <String>["["];
  
  static final List<String> _expect53 = <String>["enum"];
  
  static final List<String> _expect54 = <String>["typedef"];
  
  static final List<String> _expect55 = <String>["(", "NONDIGIT", "\\U", "\\u"];
  
  static final List<String> _expect56 = <String>["\"", "L\""];
  
  static final List<String> _expect57 = <String>["\"", "L\"", "spaces"];
  
  static final List<String> _expect58 = <String>["="];
  
  static final List<String> _expect59 = <String>["}"];
  
  static final List<String> _expect6 = <String>[","];
  
  static final List<String> _expect60 = <String>["]"];
  
  static final List<String> _expect61 = <String>["const"];
  
  static final List<String> _expect62 = <String>["char"];
  
  static final List<String> _expect63 = <String>["..."];
  
  static final List<String> _expect64 = <String>["int", "long", "short", "signed", "unsigned"];
  
  static final List<String> _expect65 = <String>["SPACING"];
  
  static final List<String> _expect66 = <String>["_Bool", "_Complex", "_Imaginary", "__attribute__", "auto", "break", "case", "char", "const", "continue", "default", "do", "double", "else", "enum", "extern", "float", "for", "goto", "if", "inline", "int", "long", "register", "restrict", "return", "short", "signed", "sizeof", "static", "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"];
  
  static final List<String> _expect67 = <String>[";"];
  
  static final List<String> _expect68 = <String>["struct"];
  
  static final List<String> _expect69 = <String>["union"];
  
  static final List<String> _expect7 = <String>["!", "\"", "\'", "\'0\'", "(", "+", "-", ".", "DIGIT", "HEXADECIMAL_PREFIX", "L\"", "L\'", "NONDIGIT", "NONZERO_DIGIT", "\\U", "\\u", "sizeof", "~"];
  
  static final List<String> _expect70 = <String>["volatile"];
  
  static final List<String> _expect71 = <String>["\'", "L\'"];
  
  static final List<String> _expect72 = <String>["HEXADECIMAL_PREFIX"];
  
  static final List<String> _expect73 = <String>["spaces"];
  
  static final List<String> _expect74 = <String>["//"];
  
  static final List<String> _expect75 = <String>["double"];
  
  static final List<String> _expect76 = <String>["float"];
  
  static final List<String> _expect77 = <String>["int"];
  
  static final List<String> _expect78 = <String>["DIGIT", "NONDIGIT", "\\U", "\\u"];
  
  static final List<String> _expect79 = <String>["long"];
  
  static final List<String> _expect8 = <String>["!", "\'", "\'0\'", "(", "+", "-", ".", "DIGIT", "HEXADECIMAL_PREFIX", "L\'", "NONDIGIT", "NONZERO_DIGIT", "\\U", "\\u", "sizeof", "~"];
  
  static final List<String> _expect80 = <String>["short"];
  
  static final List<String> _expect81 = <String>["signed"];
  
  static final List<String> _expect82 = <String>["signed", "unsigned"];
  
  static final List<String> _expect83 = <String>["long", "short"];
  
  static final List<String> _expect84 = <String>["unsigned"];
  
  static final List<String> _expect85 = <String>["P", "p"];
  
  static final List<String> _expect86 = <String>["NONZERO_DIGIT"];
  
  static final List<String> _expect87 = <String>["DIGIT"];
  
  static final List<String> _expect88 = <String>["\'\\\'", "SIMPLE_ESCAPE_SEQUENCE", "\\U", "\\u", "\\x"];
  
  static final List<String> _expect89 = <String>["E", "e"];
  
  static final List<String> _expect9 = <String>["<", "<=", ">", ">="];
  
  static final List<String> _expect90 = <String>["FLOATING_SUFFIX"];
  
  static final List<String> _expect91 = <String>["HEXADECIMAL_DIGIT"];
  
  static final List<String> _expect92 = <String>["\\x"];
  
  static final List<String> _expect93 = <String>[".", "HEXADECIMAL_DIGIT"];
  
  static final List<String> _expect94 = <String>["INTEGER_SUFFIX"];
  
  static final List<String> _expect95 = <String>["LL", "ll"];
  
  static final List<String> _expect96 = <String>["NONDIGIT"];
  
  static final List<String> _expect97 = <String>["\'0\'"];
  
  static final List<String> _expect98 = <String>["\'\\\'"];
  
  static final List<String> _expect99 = <String>["SIGN"];
  
  static final List<bool> _lookahead = _unmap([0x1ffb4c3, 0x17fffffe, 0xffffffd, 0x3ff6983, 0x2ffffffc, 0x1ffffffa, 0x5006, 0x0, 0x0, 0x603ff41c, 0x52ffffff, 0xbffffff, 0x7ff80000, 0x7ff4bfff, 0xffff, 0x7fffff82, 0x7fffff4b, 0x7ffffc0f, 0x7ffffa5f, 0x7fffffff, 0x7fffffa1, 0x7e03ff7, 0x1fc00000, 0x0, 0x18000, 0x18000000, 0x20000040, 0x4180, 0x7e818200, 0xc0000f, 0x60000000, 0x0, 0x47f04bfb, 0x8e8000, 0x51a00, 0x30000270, 0x8434090]);
  
  // '\t', ' '
  static final List<bool> _mapping0 = _unmap([0x800001]);
  
  // '\n', '\r'
  static final List<bool> _mapping1 = _unmap([0x9]);
  
  // '\"', '\'', '?', '\\', 'a', 'b', 'f', 'n', 'r', 't', 'v'
  static final List<bool> _mapping10 = _unmap([0x20000021, 0x8000000, 0x544046]);
  
  // 'U', 'u'
  static final List<bool> _mapping11 = _unmap([0x1, 0x2]);
  
  // '\t', '\n', '\r', ' '
  static final List<bool> _mapping2 = _unmap([0x800013]);
  
  // '\n', '\r', '\'', '\\'
  static final List<bool> _mapping3 = _unmap([0x20000009, 0x0, 0x100000]);
  
  // 'F', 'L', 'f', 'l'
  static final List<bool> _mapping4 = _unmap([0x41, 0x82]);
  
  // '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'
  static final List<bool> _mapping5 = _unmap([0x7e03ff, 0xfc0000]);
  
  // 'L', 'l'
  static final List<bool> _mapping6 = _unmap([0x1, 0x2]);
  
  // 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  static final List<bool> _mapping7 = _unmap([0x43ffffff, 0x7fffffe]);
  
  // '\n', '\r', '\"', '\\'
  static final List<bool> _mapping8 = _unmap([0x1000009, 0x0, 0x100000]);
  
  // '+', '-'
  static final List<bool> _mapping9 = _unmap([0x5]);
  
  // '<<'
  static final List<int> _strings0 = <int>[60, 60];
  
  // '>>'
  static final List<int> _strings1 = <int>[62, 62];
  
  // 'const'
  static final List<int> _strings10 = <int>[99, 111, 110, 115, 116];
  
  // '...'
  static final List<int> _strings11 = <int>[46, 46, 46];
  
  // 'enum'
  static final List<int> _strings12 = <int>[101, 110, 117, 109];
  
  // '_Complex'
  static final List<int> _strings13 = <int>[95, 67, 111, 109, 112, 108, 101, 120];
  
  // '_Imaginary'
  static final List<int> _strings14 = <int>[95, 73, 109, 97, 103, 105, 110, 97, 114, 121];
  
  // 'auto'
  static final List<int> _strings15 = <int>[97, 117, 116, 111];
  
  // 'break'
  static final List<int> _strings16 = <int>[98, 114, 101, 97, 107];
  
  // 'case'
  static final List<int> _strings17 = <int>[99, 97, 115, 101];
  
  // 'char'
  static final List<int> _strings18 = <int>[99, 104, 97, 114];
  
  // 'continue'
  static final List<int> _strings19 = <int>[99, 111, 110, 116, 105, 110, 117, 101];
  
  // '<='
  static final List<int> _strings2 = <int>[60, 61];
  
  // 'default'
  static final List<int> _strings20 = <int>[100, 101, 102, 97, 117, 108, 116];
  
  // 'do'
  static final List<int> _strings21 = <int>[100, 111];
  
  // 'double'
  static final List<int> _strings22 = <int>[100, 111, 117, 98, 108, 101];
  
  // 'else'
  static final List<int> _strings23 = <int>[101, 108, 115, 101];
  
  // 'extern'
  static final List<int> _strings24 = <int>[101, 120, 116, 101, 114, 110];
  
  // 'float'
  static final List<int> _strings25 = <int>[102, 108, 111, 97, 116];
  
  // 'for'
  static final List<int> _strings26 = <int>[102, 111, 114];
  
  // 'goto'
  static final List<int> _strings27 = <int>[103, 111, 116, 111];
  
  // 'if'
  static final List<int> _strings28 = <int>[105, 102];
  
  // 'inline'
  static final List<int> _strings29 = <int>[105, 110, 108, 105, 110, 101];
  
  // '>='
  static final List<int> _strings3 = <int>[62, 61];
  
  // 'int'
  static final List<int> _strings30 = <int>[105, 110, 116];
  
  // 'long'
  static final List<int> _strings31 = <int>[108, 111, 110, 103];
  
  // 'register'
  static final List<int> _strings32 = <int>[114, 101, 103, 105, 115, 116, 101, 114];
  
  // 'restrict'
  static final List<int> _strings33 = <int>[114, 101, 115, 116, 114, 105, 99, 116];
  
  // 'return'
  static final List<int> _strings34 = <int>[114, 101, 116, 117, 114, 110];
  
  // 'short'
  static final List<int> _strings35 = <int>[115, 104, 111, 114, 116];
  
  // 'signed'
  static final List<int> _strings36 = <int>[115, 105, 103, 110, 101, 100];
  
  // 'sizeof'
  static final List<int> _strings37 = <int>[115, 105, 122, 101, 111, 102];
  
  // 'static'
  static final List<int> _strings38 = <int>[115, 116, 97, 116, 105, 99];
  
  // 'struct'
  static final List<int> _strings39 = <int>[115, 116, 114, 117, 99, 116];
  
  // '=='
  static final List<int> _strings4 = <int>[61, 61];
  
  // 'switch'
  static final List<int> _strings40 = <int>[115, 119, 105, 116, 99, 104];
  
  // 'typedef'
  static final List<int> _strings41 = <int>[116, 121, 112, 101, 100, 101, 102];
  
  // 'union'
  static final List<int> _strings42 = <int>[117, 110, 105, 111, 110];
  
  // 'unsigned'
  static final List<int> _strings43 = <int>[117, 110, 115, 105, 103, 110, 101, 100];
  
  // 'void'
  static final List<int> _strings44 = <int>[118, 111, 105, 100];
  
  // 'volatile'
  static final List<int> _strings45 = <int>[118, 111, 108, 97, 116, 105, 108, 101];
  
  // 'while'
  static final List<int> _strings46 = <int>[119, 104, 105, 108, 101];
  
  // 'L''
  static final List<int> _strings47 = <int>[76, 39];
  
  // 'L"'
  static final List<int> _strings48 = <int>[76, 34];
  
  // '//'
  static final List<int> _strings49 = <int>[47, 47];
  
  // '!='
  static final List<int> _strings5 = <int>[33, 61];
  
  // '\r\n'
  static final List<int> _strings50 = <int>[13, 10];
  
  // '\x'
  static final List<int> _strings51 = <int>[92, 120];
  
  // '0x'
  static final List<int> _strings52 = <int>[48, 120];
  
  // '0X'
  static final List<int> _strings53 = <int>[48, 88];
  
  // 'LL'
  static final List<int> _strings54 = <int>[76, 76];
  
  // 'll'
  static final List<int> _strings55 = <int>[108, 108];
  
  // '\U'
  static final List<int> _strings56 = <int>[92, 85];
  
  // '\u'
  static final List<int> _strings57 = <int>[92, 117];
  
  // '&&'
  static final List<int> _strings6 = <int>[38, 38];
  
  // '||'
  static final List<int> _strings7 = <int>[124, 124];
  
  // '__attribute__'
  static final List<int> _strings8 = <int>[95, 95, 97, 116, 116, 114, 105, 98, 117, 116, 101, 95, 95];
  
  // '_Bool'
  static final List<int> _strings9 = <int>[95, 66, 111, 111, 108];
  
  final List<String> _tokenAliases = ["EOF", "spaces", "SPACING", "DIGIT", "FLOATING_SUFFIX", "HEXADECIMAL_DIGIT", "HEXADECIMAL_PREFIX", "INTEGER_SUFFIX", "NONDIGIT", "NONZERO_DIGIT", "\'0\'", "\'\\\'", "SIGN", "SIMPLE_ESCAPE_SEQUENCE"];
  
  final List<int> _tokenFlags = [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0];
  
  final List<String> _tokenNames = ["EOF", "spaces", "SPACING", "DIGIT", "FLOATING_SUFFIX", "HEXADECIMAL_DIGIT", "HEXADECIMAL_PREFIX", "INTEGER_SUFFIX", "NONDIGIT", "NONZERO_DIGIT", "OCTAL_CONSTANT", "OCTAL_ESCAPE_SEQUENCE", "SIGN", "SIMPLE_ESCAPE_SEQUENCE"];
  
  static final List<List<int>> _transitions0 = [[42, 42], [59, 59], [65, 90, 92, 92], [95, 95, 97, 122]];
  
  static final List<List<int>> _transitions1 = [[42, 42], [65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions10 = [[33, 33, 43, 43, 45, 45, 126, 126], [39, 40, 46, 46, 48, 57, 65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions11 = [[39, 39, 46, 46, 48, 57], [40, 40], [65, 90], [92, 92, 95, 95, 97, 114, 116, 122], [115, 115]];
  
  static final List<List<int>> _transitions12 = [[39, 39, 46, 46, 48, 57, 76, 76]];
  
  static final List<List<int>> _transitions13 = [[39, 39, 76, 76], [46, 46], [48, 57]];
  
  static final List<List<int>> _transitions14 = [[46, 46], [48, 57]];
  
  static final List<List<int>> _transitions15 = [[46, 46, 48, 57]];
  
  static final List<List<int>> _transitions16 = [[33, 33], [43, 43], [45, 45], [126, 126]];
  
  static final List<List<int>> _transitions17 = [[37, 37], [42, 42], [47, 47]];
  
  static final List<List<int>> _transitions18 = [[43, 43], [45, 45]];
  
  static final List<List<int>> _transitions19 = [[60, 60], [62, 62]];
  
  static final List<List<int>> _transitions2 = [[65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions20 = [[99, 99, 118, 118]];
  
  static final List<List<int>> _transitions21 = [[99, 99], [118, 118]];
  
  static final List<List<int>> _transitions22 = [[42, 42, 65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions23 = [[65, 90, 92, 92], [95, 95], [97, 122]];
  
  static final List<List<int>> _transitions24 = [[99, 99, 105, 105, 108, 108, 115, 115, 117, 117]];
  
  static final List<List<int>> _transitions25 = [[99, 99], [105, 105, 108, 108], [115, 115, 117, 117]];
  
  static final List<List<int>> _transitions26 = [[100, 100, 102, 102]];
  
  static final List<List<int>> _transitions27 = [[115, 115, 117, 117]];
  
  static final List<List<int>> _transitions28 = [[115, 115], [117, 117]];
  
  static final List<List<int>> _transitions29 = [[58, 58, 65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions3 = [[33, 34, 39, 40, 43, 43, 45, 46, 48, 57, 65, 90, 92, 92, 95, 95, 97, 122, 126, 126]];
  
  static final List<List<int>> _transitions30 = [[42, 42], [91, 91]];
  
  static final List<List<int>> _transitions31 = [[40, 40, 42, 42]];
  
  static final List<List<int>> _transitions32 = [[95, 95, 99, 99, 115, 115, 117, 118]];
  
  static final List<List<int>> _transitions33 = [[95, 95, 99, 99, 101, 101, 118, 118]];
  
  static final List<List<int>> _transitions34 = [[95, 95, 99, 99, 116, 116, 118, 118]];
  
  static final List<List<int>> _transitions35 = [[40, 40, 42, 42, 65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions36 = [[40, 40], [42, 42], [65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions37 = [[34, 34, 76, 76]];
  
  static final List<List<int>> _transitions38 = [[99, 99], [115, 115, 117, 117]];
  
  static final List<List<int>> _transitions39 = [[100, 100], [102, 102]];
  
  static final List<List<int>> _transitions4 = [[33, 33, 39, 40, 43, 43, 45, 46, 48, 57, 92, 92, 95, 95, 97, 122, 126, 126], [34, 34], [65, 90]];
  
  static final List<List<int>> _transitions40 = [[105, 105], [108, 108], [115, 115], [117, 117]];
  
  static final List<List<int>> _transitions41 = [[95, 95, 97, 103, 105, 105, 108, 108, 114, 119]];
  
  static final List<List<int>> _transitions42 = [[95, 95], [97, 97], [98, 98], [99, 99], [100, 100], [101, 101], [102, 102], [103, 103], [105, 105], [108, 108], [114, 114], [115, 115], [116, 116], [117, 117], [118, 118], [119, 119]];
  
  static final List<List<int>> _transitions43 = [[39, 39], [76, 76]];
  
  static final List<List<int>> _transitions44 = [[48, 48], [49, 57]];
  
  static final List<List<int>> _transitions45 = [[34, 34], [76, 76]];
  
  static final List<List<int>> _transitions46 = [[0, 9, 11, 12, 14, 1114111], [10, 10, 13, 13]];
  
  static final List<List<int>> _transitions47 = [[10, 10], [13, 13]];
  
  static final List<List<int>> _transitions48 = [[48, 57], [65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions49 = [[65, 90, 95, 95, 97, 122], [92, 92]];
  
  static final List<List<int>> _transitions5 = [[33, 33, 39, 40, 43, 43, 45, 46, 48, 57, 65, 90, 92, 92, 95, 95, 97, 122, 126, 126]];
  
  static final List<List<int>> _transitions50 = [[9, 10, 13, 13, 32, 32]];
  
  static final List<List<int>> _transitions51 = [[9, 10, 13, 13, 32, 32], [47, 47]];
  
  static final List<List<int>> _transitions52 = [[108, 108], [115, 115]];
  
  static final List<List<int>> _transitions53 = [[80, 80, 112, 112]];
  
  static final List<List<int>> _transitions54 = [[80, 80], [112, 112]];
  
  static final List<List<int>> _transitions55 = [[69, 69, 101, 101]];
  
  static final List<List<int>> _transitions56 = [[69, 69], [101, 101]];
  
  static final List<List<int>> _transitions57 = [[70, 70, 76, 76, 102, 102, 108, 108]];
  
  static final List<List<int>> _transitions58 = [[48, 57, 65, 70, 97, 102]];
  
  static final List<List<int>> _transitions59 = [[46, 46], [48, 57, 65, 70, 97, 102]];
  
  static final List<List<int>> _transitions6 = [];
  
  static final List<List<int>> _transitions60 = [[76, 76, 108, 108], [85, 85, 117, 117]];
  
  static final List<List<int>> _transitions61 = [[76, 76], [108, 108]];
  
  static final List<List<int>> _transitions62 = [[76, 76, 108, 108]];
  
  static final List<List<int>> _transitions63 = [[65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions64 = [[85, 85, 117, 117]];
  
  static final List<List<int>> _transitions7 = [[60, 60, 62, 62]];
  
  static final List<List<int>> _transitions8 = [[43, 43, 45, 45]];
  
  static final List<List<int>> _transitions9 = [[37, 37, 42, 42, 47, 47]];
  
  List<Map<int, List>> _cache;
  
  List<int> _cachePos;
  
  List<bool> _cacheable;
  
  int _ch;
  
  int _cursor;
  
  List<CParserError> _errors;
  
  List<String> _expected;
  
  int _failurePos;
  
  List<int> _input;
  
  int _inputLen;
  
  int _startPos;
  
  int _testing;
  
  int _token;
  
  int _tokenStart;
  
  bool success;
  
  final String text;
  
  CParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }    
    _input = _toCodePoints(text);
    _inputLen = _input.length;    
    reset(0);    
  }
  
  void _addToCache(dynamic result, int start, int id) {   
    var map = _cache[id];
    if (map == null) {
      map = <int, List>{};
      _cache[id] = map;
    }
    map[start] = [result, _cursor, success];      
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {    
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var alias = _tokenAliases[_token];
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos > _tokenStart && _failurePos == _inputLen && (flag & 1) != 0) {             
        var message = "Unterminated '$name'";
        _errors.add(new CParserError(CParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {             
        var message = "Malformed '$name'";
        _errors.add(new CParserError(CParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else {
        _expected.add(alias);
      }            
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }   
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    if (!_cacheable[id]) {  
      _cacheable[id] = true;  
      return null;
    }
    var map = _cache[id];
    if (map == null) {
      return null;
    }
    var data = map[_cursor];
    if (data == null) {
      return null;
    }
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }
    return data;  
  }
  
  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];    
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;          
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state; 
      }   
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;  
  }
  
  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }
  
  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }    
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }    
    return null;  
  }
  
  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;  
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];  
        } else {
          result = new String.fromCharCode(_ch);
        }     
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      }
      success = false;
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }        
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }  
      return result;
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {    
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];  
          } else {
            result = new String.fromCharCode(_ch);
          }          
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    success = false;  
    return null;  
  }
  
  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;  
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }  
    if (success) {
      _cursor += length;      
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return string;      
    }  
    return null; 
  }
  
  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }  
  }
  
  dynamic _parse_ASSIGN() {
    // SENTENCE (NONTERMINAL)
    // ASSIGN <- '=' SPACING
    var $$;
    // => '=' SPACING # Choice
    switch (_ch == 61 ? 0 : _ch == -1 ? 2 : 1) {
      // [=]
      case 0:
        // => '=' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '='
          $$ = '=';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '='
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '=' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: =
      _failure(_expect58);
    }
    // <= '=' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_ASTERISK() {
    // SENTENCE (NONTERMINAL)
    // ASTERISK <- '*' SPACING
    var $$;
    // => '*' SPACING # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => '*' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '*'
          $$ = '*';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '*'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '*'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '*' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: *
      _failure(_expect25);
    }
    // <= '*' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_ATTRIBUTE() {
    // SENTENCE (NONTERMINAL)
    // ATTRIBUTE <- '__attribute__' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => '__attribute__' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => '__attribute__' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '__attribute__'
          $$ = _matchString(_strings8, '__attribute__');
          // <= '__attribute__'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '__attribute__'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '__attribute__' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: __attribute__
      _failure(_expect4);
    }
    // <= '__attribute__' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_ArrayDimensions() {
    // SENTENCE (NONTERMINAL)
    // ArrayDimensions <- Dimension+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[85] >= pos) {
      $$ = _getFromCache(85);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[85] = pos;
    }  
    // => Dimension+ # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => Dimension+
        var testing0;
        for (var first = true, reps; ;) {  
          // => Dimension  
          $$ = _parse_Dimension();  
          // <= Dimension  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= Dimension+
        if (success) {    
          // Dimension+
          final $1 = $$;
          final $start = startPos0;
          $$ = new ArrayDimensions(elements: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: [
      _failure(_expect52);
    }
    // <= Dimension+ # Choice
    if (_cacheable[85]) {
      _addToCache($$, pos, 85);
    }    
    return $$;
  }
  
  dynamic _parse_BINARY_EXPONENT_PART() {
    // SENTENCE (NONTERMINAL)
    // BINARY_EXPONENT_PART <- ('p' / 'P') SIGN? DIGIT_SEQUENCE
    var $$;          
    var pos = _cursor;             
    if(_cachePos[159] >= pos) {
      $$ = _getFromCache(159);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[159] = pos;
    }  
    // => ('p' / 'P') SIGN? DIGIT_SEQUENCE # Choice
    switch (_getState(_transitions53)) {
      // [P] [p]
      case 0:
        // => ('p' / 'P') SIGN? DIGIT_SEQUENCE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ('p' / 'P') # Choice
          switch (_getState(_transitions54)) {
            // [P]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => 'P'
              $$ = _matchChar(80, 'P');
              // <= 'P'
              _startPos = startPos1;
              break;
            // [p]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => 'p'
              $$ = 'p';
              success = true;
              if (++_cursor < _inputLen) {
                _ch = _input[_cursor];
              } else {
                _ch = -1;
              }
              // <= 'p'
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: p, P
            _failure(_expect85);
          }
          // <= ('p' / 'P') # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => SIGN?
          var testing0 = _testing;
          _testing = _cursor;
          // => SIGN
          $$ = _parse_SIGN();
          // <= SIGN
          success = true; 
          _testing = testing0;
          // <= SIGN?
          if (!success) break;
          seq[1] = $$;
          // => DIGIT_SEQUENCE
          $$ = _parse_DIGIT_SEQUENCE();
          // <= DIGIT_SEQUENCE
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ('p' / 'P')
            final $1 = seq[0];
            // SIGN?
            final $2 = seq[1];
            // DIGIT_SEQUENCE
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('p' / 'P') SIGN? DIGIT_SEQUENCE # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: p, P
      _failure(_expect85);
    }
    // <= ('p' / 'P') SIGN? DIGIT_SEQUENCE # Choice
    if (_cacheable[159]) {
      _addToCache($$, pos, 159);
    }    
    return $$;
  }
  
  dynamic _parse_BOOL() {
    // SENTENCE (NONTERMINAL)
    // BOOL <- '_Bool' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => '_Bool' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => '_Bool' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '_Bool'
          $$ = _matchString(_strings9, '_Bool');
          // <= '_Bool'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '_Bool'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '_Bool' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: _Bool
      _failure(_expect47);
    }
    // <= '_Bool' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_BitFieldDeclaratorAbstract() {
    // SENTENCE (NONTERMINAL)
    // BitFieldDeclaratorAbstract <- Identifier? COLON integer_constant Metadata?
    var $$;
    // => Identifier? COLON integer_constant Metadata? # Choice
    switch (_getState(_transitions29)) {
      // [:] [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Identifier? COLON integer_constant Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Identifier?
          var testing0 = _testing;
          _testing = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          success = true; 
          _testing = testing0;
          // <= Identifier?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => COLON
          $$ = _parse_COLON();
          // <= COLON
          if (!success) break;
          seq[1] = $$;
          // => integer_constant
          $$ = _parse_integer_constant();
          // <= integer_constant
          if (!success) break;
          seq[2] = $$;
          // => Metadata?
          var testing1 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing1;
          // <= Metadata?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Identifier?
            final $1 = seq[0];
            // COLON
            final $2 = seq[1];
            // integer_constant
            final $3 = seq[2];
            // Metadata?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Declarator(identifier: $1, metadata: $4, width: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Identifier? COLON integer_constant Metadata? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: :
      _failure(_expect42);
    }
    // <= Identifier? COLON integer_constant Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_BitFieldDeclaratorNotAbstract() {
    // SENTENCE (NONTERMINAL)
    // BitFieldDeclaratorNotAbstract <- Identifier COLON integer_constant Metadata?
    var $$;
    // => Identifier COLON integer_constant Metadata? # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Identifier COLON integer_constant Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => COLON
          $$ = _parse_COLON();
          // <= COLON
          if (!success) break;
          seq[1] = $$;
          // => integer_constant
          $$ = _parse_integer_constant();
          // <= integer_constant
          if (!success) break;
          seq[2] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Identifier
            final $1 = seq[0];
            // COLON
            final $2 = seq[1];
            // integer_constant
            final $3 = seq[2];
            // Metadata?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Declarator(identifier: $1, metadata: $4, width: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Identifier COLON integer_constant Metadata? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= Identifier COLON integer_constant Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_BitFieldParameterDeclaration() {
    // SENTENCE (NONTERMINAL)
    // BitFieldParameterDeclaration <- Metadata? TypeQualifiers? Type BitFieldDeclaratorNotAbstract / Metadata? TypeQualifiers? Type BitFieldDeclaratorAbstract
    var $$;
    // => Metadata? TypeQualifiers? Type BitFieldDeclaratorNotAbstract / Metadata? TypeQualifiers? Type BitFieldDeclaratorAbstract # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => Metadata? TypeQualifiers? Type BitFieldDeclaratorNotAbstract # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => BitFieldDeclaratorNotAbstract
            $$ = _parse_BitFieldDeclaratorNotAbstract();
            // <= BitFieldDeclaratorNotAbstract
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // BitFieldDeclaratorNotAbstract
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Metadata? TypeQualifiers? Type BitFieldDeclaratorNotAbstract # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type BitFieldDeclaratorAbstract # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => BitFieldDeclaratorAbstract
            $$ = _parse_BitFieldDeclaratorAbstract();
            // <= BitFieldDeclaratorAbstract
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // BitFieldDeclaratorAbstract
              final $4 = seq[3];
              final $start = startPos1;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Metadata? TypeQualifiers? Type BitFieldDeclaratorAbstract # Sequence
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? Type BitFieldDeclaratorNotAbstract / Metadata? TypeQualifiers? Type BitFieldDeclaratorAbstract # Choice
    return $$;
  }
  
  dynamic _parse_BoolType() {
    // SENTENCE (NONTERMINAL)
    // BoolType <- BOOL Metadata? TypeQualifiers?
    var $$;
    // => BOOL Metadata? TypeQualifiers? # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => BOOL Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => BOOL
          $$ = _parse_BOOL();
          // <= BOOL
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // BOOL
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new BoolTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= BOOL Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: _Bool
      _failure(_expect47);
    }
    // <= BOOL Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_CHAR() {
    // SENTENCE (NONTERMINAL)
    // CHAR <- 'char' !IDENTIFIER_BASE1 SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[143] >= pos) {
      $$ = _getFromCache(143);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[143] = pos;
    }  
    // => 'char' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        // => 'char' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'char'
          $$ = _matchString(_strings18, 'char');
          // <= 'char'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'char'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'char' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char
      _failure(_expect62);
    }
    // <= 'char' !IDENTIFIER_BASE1 SPACING # Choice
    if (_cacheable[143]) {
      _addToCache($$, pos, 143);
    }    
    return $$;
  }
  
  dynamic _parse_CLOSE_BRACE() {
    // SENTENCE (NONTERMINAL)
    // CLOSE_BRACE <- '}' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[112] >= pos) {
      $$ = _getFromCache(112);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[112] = pos;
    }  
    // => '}' SPACING # Choice
    switch (_ch == 125 ? 0 : _ch == -1 ? 2 : 1) {
      // [}]
      case 0:
        // => '}' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '}'
          $$ = '}';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '}'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '}'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '}' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: }
      _failure(_expect59);
    }
    // <= '}' SPACING # Choice
    if (_cacheable[112]) {
      _addToCache($$, pos, 112);
    }    
    return $$;
  }
  
  dynamic _parse_CLOSE_BRACKET() {
    // SENTENCE (NONTERMINAL)
    // CLOSE_BRACKET <- ']' SPACING
    var $$;
    // => ']' SPACING # Choice
    switch (_ch == 93 ? 0 : _ch == -1 ? 2 : 1) {
      // []]
      case 0:
        // => ']' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ']'
          $$ = ']';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ']'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ']'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ']' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ]
      _failure(_expect60);
    }
    // <= ']' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_CLOSE_PAREN() {
    // SENTENCE (NONTERMINAL)
    // CLOSE_PAREN <- ')' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[114] >= pos) {
      $$ = _getFromCache(114);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[114] = pos;
    }  
    // => ')' SPACING # Choice
    switch (_ch == 41 ? 0 : _ch == -1 ? 2 : 1) {
      // [)]
      case 0:
        // => ')' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ')'
          $$ = ')';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ')'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ')'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ')' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: )
      _failure(_expect19);
    }
    // <= ')' SPACING # Choice
    if (_cacheable[114]) {
      _addToCache($$, pos, 114);
    }    
    return $$;
  }
  
  dynamic _parse_COLON() {
    // SENTENCE (NONTERMINAL)
    // COLON <- ':' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[115] >= pos) {
      $$ = _getFromCache(115);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[115] = pos;
    }  
    // => ':' SPACING # Choice
    switch (_ch == 58 ? 0 : _ch == -1 ? 2 : 1) {
      // [:]
      case 0:
        // => ':' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ':'
          $$ = ':';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ':'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ':'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ':' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: :
      _failure(_expect42);
    }
    // <= ':' SPACING # Choice
    if (_cacheable[115]) {
      _addToCache($$, pos, 115);
    }    
    return $$;
  }
  
  dynamic _parse_COMMA() {
    // SENTENCE (NONTERMINAL)
    // COMMA <- ',' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[116] >= pos) {
      $$ = _getFromCache(116);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[116] = pos;
    }  
    // => ',' SPACING # Choice
    switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
      // [,]
      case 0:
        // => ',' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ','
          $$ = ',';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ','
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ','
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ',' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ,
      _failure(_expect6);
    }
    // <= ',' SPACING # Choice
    if (_cacheable[116]) {
      _addToCache($$, pos, 116);
    }    
    return $$;
  }
  
  dynamic _parse_COMMENT() {
    // MORHEME
    // COMMENT <- '//' (!EOL .)* (EOL / !.)
    var $$;
    // => '//' (!EOL .)* (EOL / !.) # Choice
    switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
      // [/]
      case 0:
        // => '//' (!EOL .)* (EOL / !.) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '//'
          $$ = _matchString(_strings49, '//');
          // <= '//'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (!EOL .)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (!EOL .) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              // EOF
              case 0:
              case 2:
                // => !EOL . # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => !EOL
                  var ch2 = _ch, pos2 = _cursor, testing1 = _testing; 
                  _testing = _inputLen + 1;
                  // => EOL
                  $$ = _parse_EOL();
                  // <= EOL
                  _ch = ch2;
                  _cursor = pos2; 
                  _testing = testing1;
                  $$ = null;
                  success = !success;
                  // <= !EOL
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => .
                  $$ = _matchAny();
                  // <= .
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= !EOL . # Sequence
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(const [null]);
            }
            // <= (!EOL .) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (!EOL .)*
          if (!success) break;
          seq[1] = $$;
          // => (EOL / !.) # Choice
          switch (_getState(_transitions46)) {
            // [\u0000-\t] [\u000b-\u000c] [\u000e-\u0010ffff]
            // EOF
            case 0:
            case 3:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => !.
              var ch3 = _ch, pos3 = _cursor, testing2 = _testing; 
              _testing = _inputLen + 1;
              // => .
              $$ = _matchAny();
              // <= .
              _ch = ch3;
              _cursor = pos3; 
              _testing = testing2;
              $$ = null;
              success = !success;
              // <= !.
              _startPos = startPos2;
              break;
            // [\n] [\r]
            case 1:
              while (true) {
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => EOL
                $$ = _parse_EOL();
                // <= EOL
                _startPos = startPos3;
                if (success) break;
                var startPos4 = _startPos;
                _startPos = _cursor;
                // => !.
                var ch4 = _ch, pos4 = _cursor, testing3 = _testing; 
                _testing = _inputLen + 1;
                // => .
                $$ = _matchAny();
                // <= .
                _ch = ch4;
                _cursor = pos4; 
                _testing = testing3;
                $$ = null;
                success = !success;
                // <= !.
                _startPos = startPos4;
                break;
              }
              break;
            // No matches
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (EOL / !.) # Choice
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '//' (!EOL .)* (EOL / !.) # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: //
      _failure(_expect74);
    }
    // <= '//' (!EOL .)* (EOL / !.) # Choice
    return $$;
  }
  
  dynamic _parse_CONST() {
    // SENTENCE (NONTERMINAL)
    // CONST <- 'const' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'const' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 99 ? 0 : _ch == -1 ? 2 : 1) {
      // [c]
      case 0:
        // => 'const' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'const'
          $$ = _matchString(_strings10, 'const');
          // <= 'const'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'const'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'const' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: const
      _failure(_expect61);
    }
    // <= 'const' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_C_CHAR() {
    // SENTENCE (NONTERMINAL)
    // C_CHAR <- ![\n\r'\\] . / ESCAPE_SEQUENCE
    var $$;          
    var pos = _cursor;             
    if(_cachePos[160] >= pos) {
      $$ = _getFromCache(160);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[160] = pos;
    }  
    // => ![\n\r'\\] . / ESCAPE_SEQUENCE # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        while (true) {
          // => ![\n\r'\\] . # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ![\n\r'\\]
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            // => [\n\r'\\]
            $$ = _matchMapping(10, 92, _mapping3);
            // <= [\n\r'\\]
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            // <= ![\n\r'\\]
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => .
            $$ = _matchAny();
            // <= .
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ![\n\r'\\]
              final $1 = seq[0];
              // .
              final $2 = seq[1];
              final $start = startPos0;
              $$ = $2.codeUnitAt(0);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= ![\n\r'\\] . # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => ESCAPE_SEQUENCE
          $$ = _parse_ESCAPE_SEQUENCE();
          // <= ESCAPE_SEQUENCE
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
      // EOF
      case 2:
        // => ![\n\r'\\] . # Sequence
        var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ![\n\r'\\]
          var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          // => [\n\r'\\]
          $$ = _matchMapping(10, 92, _mapping3);
          // <= [\n\r'\\]
          _ch = ch3;
          _cursor = pos3; 
          _testing = testing1;
          $$ = null;
          success = !success;
          // <= ![\n\r'\\]
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => .
          $$ = _matchAny();
          // <= .
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ![\n\r'\\]
            final $1 = seq[0];
            // .
            final $2 = seq[1];
            final $start = startPos2;
            $$ = $2.codeUnitAt(0);
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos2;
        // <= ![\n\r'\\] . # Sequence
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= ![\n\r'\\] . / ESCAPE_SEQUENCE # Choice
    if (_cacheable[160]) {
      _addToCache($$, pos, 160);
    }    
    return $$;
  }
  
  dynamic _parse_CharTypeSpecifiers() {
    // SENTENCE (NONTERMINAL)
    // CharTypeSpecifiers <- SIGNMODIFIER? CHAR / CHAR SIGNMODIFIER
    var $$;
    // => SIGNMODIFIER? CHAR / CHAR SIGNMODIFIER # Choice
    switch (_getState(_transitions38)) {
      // [c]
      case 0:
        while (true) {
          // => SIGNMODIFIER? CHAR # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNMODIFIER?
            var testing0 = _testing;
            _testing = _cursor;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            success = true; 
            _testing = testing0;
            // <= SIGNMODIFIER?
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => CHAR
            $$ = _parse_CHAR();
            // <= CHAR
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // SIGNMODIFIER?
              final $1 = seq[0];
              // CHAR
              final $2 = seq[1];
              final $start = startPos0;
              $$ = new TypeSpecifiers(elements: _removeNull([$1, $2]));
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= SIGNMODIFIER? CHAR # Sequence
          if (success) break;
          // => CHAR SIGNMODIFIER # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => CHAR
            $$ = _parse_CHAR();
            // <= CHAR
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // CHAR
              final $1 = seq[0];
              // SIGNMODIFIER
              final $2 = seq[1];
              final $start = startPos1;
              $$ = new TypeSpecifiers(elements: [$1, $2]);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= CHAR SIGNMODIFIER # Sequence
          break;
        }
        break;
      // [s] [u]
      case 1:
        // => SIGNMODIFIER? CHAR # Sequence
        var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => SIGNMODIFIER?
          var testing1 = _testing;
          _testing = _cursor;
          // => SIGNMODIFIER
          $$ = _parse_SIGNMODIFIER();
          // <= SIGNMODIFIER
          success = true; 
          _testing = testing1;
          // <= SIGNMODIFIER?
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => CHAR
          $$ = _parse_CHAR();
          // <= CHAR
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // SIGNMODIFIER?
            final $1 = seq[0];
            // CHAR
            final $2 = seq[1];
            final $start = startPos2;
            $$ = new TypeSpecifiers(elements: _removeNull([$1, $2]));
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos2;
        // <= SIGNMODIFIER? CHAR # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char
      _failure(_expect62);
    }
    // <= SIGNMODIFIER? CHAR / CHAR SIGNMODIFIER # Choice
    return $$;
  }
  
  dynamic _parse_DECIMAL_CONSTANT() {
    // SENTENCE (NONTERMINAL)
    // DECIMAL_CONSTANT <- NONZERO_DIGIT DIGIT*
    var $$;
    // => NONZERO_DIGIT DIGIT* # Choice
    switch (_ch >= 49 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [1-9]
      case 0:
        // => NONZERO_DIGIT DIGIT* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => NONZERO_DIGIT
          $$ = _parse_NONZERO_DIGIT();
          // <= NONZERO_DIGIT
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => DIGIT*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => DIGIT
            $$ = _parse_DIGIT();
            // <= DIGIT
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= DIGIT*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // NONZERO_DIGIT
            final $1 = seq[0];
            // DIGIT*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = int.parse(_text());
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= NONZERO_DIGIT DIGIT* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONZERO_DIGIT
      _failure(_expect86);
    }
    // <= NONZERO_DIGIT DIGIT* # Choice
    return $$;
  }
  
  dynamic _parse_DIGIT() {
    // LEXEME (TOKEN)
    // DIGIT <- [0-9]
    var $$;          
    var pos = _cursor;             
    if(_cachePos[162] >= pos) {
      $$ = _getFromCache(162);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[162] = pos;
    }  
    _token = 3;    
    _tokenStart = _cursor;    
    // => [0-9] # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-9]
        $$ = _matchRange(48, 57);
        // <= [0-9]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: DIGIT
      _failure(_expect87);
    }
    // <= [0-9] # Choice
    if (_cacheable[162]) {
      _addToCache($$, pos, 162);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_DIGIT_SEQUENCE() {
    // SENTENCE (NONTERMINAL)
    // DIGIT_SEQUENCE <- DIGIT+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[163] >= pos) {
      $$ = _getFromCache(163);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[163] = pos;
    }  
    // => DIGIT+ # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => DIGIT+
        var testing0;
        for (var first = true, reps; ;) {  
          // => DIGIT  
          $$ = _parse_DIGIT();  
          // <= DIGIT  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= DIGIT+
        if (success) {    
          // DIGIT+
          final $1 = $$;
          final $start = startPos0;
          $$ = _text();
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: DIGIT
      _failure(_expect87);
    }
    // <= DIGIT+ # Choice
    if (_cacheable[163]) {
      _addToCache($$, pos, 163);
    }    
    return $$;
  }
  
  dynamic _parse_DOUBLE() {
    // SENTENCE (NONTERMINAL)
    // DOUBLE <- 'double' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'double' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 100 ? 0 : _ch == -1 ? 2 : 1) {
      // [d]
      case 0:
        // => 'double' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'double'
          $$ = _matchString(_strings22, 'double');
          // <= 'double'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'double'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'double' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: double
      _failure(_expect75);
    }
    // <= 'double' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_Declaration() {
    // SENTENCE (NONTERMINAL)
    // Declaration <- FunctionDeclaration SEMICOLON+ / StructureDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / SEMICOLON+
    var $$;
    // => FunctionDeclaration SEMICOLON+ / StructureDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / SEMICOLON+ # Choice
    switch (_getState(_transitions0)) {
      // [*]
      case 0:
        // => FunctionDeclaration SEMICOLON+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FunctionDeclaration
          $$ = _parse_FunctionDeclaration();
          // <= FunctionDeclaration
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SEMICOLON+
          var testing0;
          for (var first = true, reps; ;) {  
            // => SEMICOLON  
            $$ = _parse_SEMICOLON();  
            // <= SEMICOLON  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= SEMICOLON+
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // FunctionDeclaration
            final $1 = seq[0];
            // SEMICOLON+
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionDeclaration SEMICOLON+ # Sequence
        break;
      // [;]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => SEMICOLON+
        var testing1;
        for (var first = true, reps; ;) {  
          // => SEMICOLON  
          $$ = _parse_SEMICOLON();  
          // <= SEMICOLON  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing1 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing1;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= SEMICOLON+
        if (success) {    
          // SEMICOLON+
          final $1 = $$;
          final $start = startPos1;
          $$ = new EmptyDeclaration();
        }
        _startPos = startPos1;
        break;
      // [A-Z] [\\]
      // EOF
      case 2:
      case 5:
        while (true) {
          // => FunctionDeclaration SEMICOLON+ # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FunctionDeclaration
            $$ = _parse_FunctionDeclaration();
            // <= FunctionDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing2;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing2 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing2;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // FunctionDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos2;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos2;
          // <= FunctionDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => VariableDeclaration SEMICOLON+ # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => VariableDeclaration
            $$ = _parse_VariableDeclaration();
            // <= VariableDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing3;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing3 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing3;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // VariableDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos3;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos3;
          // <= VariableDeclaration SEMICOLON+ # Sequence
          break;
        }
        break;
      // [_] [a-z]
      case 3:
        while (true) {
          // => FunctionDeclaration SEMICOLON+ # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FunctionDeclaration
            $$ = _parse_FunctionDeclaration();
            // <= FunctionDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing4;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing4 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing4;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // FunctionDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos4;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos4;
          // <= FunctionDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => StructureDeclaration SEMICOLON+ # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => StructureDeclaration
            $$ = _parse_StructureDeclaration();
            // <= StructureDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing5;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing5 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing5;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // StructureDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos5;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos5;
          // <= StructureDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => EnumDeclaration SEMICOLON+ # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => EnumDeclaration
            $$ = _parse_EnumDeclaration();
            // <= EnumDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing6;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing6 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing6;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // EnumDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos6;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos6;
          // <= EnumDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => TypedefDeclaration SEMICOLON+ # Sequence
          var ch6 = _ch, pos6 = _cursor, startPos7 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => TypedefDeclaration
            $$ = _parse_TypedefDeclaration();
            // <= TypedefDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing7;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing7 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing7;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // TypedefDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos7;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos7;
          // <= TypedefDeclaration SEMICOLON+ # Sequence
          if (success) break;
          // => VariableDeclaration SEMICOLON+ # Sequence
          var ch7 = _ch, pos7 = _cursor, startPos8 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => VariableDeclaration
            $$ = _parse_VariableDeclaration();
            // <= VariableDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON+
            var testing8;
            for (var first = true, reps; ;) {  
              // => SEMICOLON  
              $$ = _parse_SEMICOLON();  
              // <= SEMICOLON  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing8 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing8;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            // <= SEMICOLON+
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // VariableDeclaration
              final $1 = seq[0];
              // SEMICOLON+
              final $2 = seq[1];
              final $start = startPos8;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch7;
            _cursor = pos7;
          }
          _startPos = startPos8;
          // <= VariableDeclaration SEMICOLON+ # Sequence
          break;
        }
        break;
      // No matches
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, typedef, ;, NONDIGIT, \U, \u
      _failure(_expect2);
    }
    // <= FunctionDeclaration SEMICOLON+ / StructureDeclaration SEMICOLON+ / EnumDeclaration SEMICOLON+ / TypedefDeclaration SEMICOLON+ / VariableDeclaration SEMICOLON+ / SEMICOLON+ # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationList() {
    // SENTENCE (NONTERMINAL)
    // DeclarationList <- Declaration*
    var $$;
    // => Declaration* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => Declaration*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => Declaration
          $$ = _parse_Declaration();
          // <= Declaration
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= Declaration*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
      // EOF
      case 2:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => Declaration*
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => Declaration
            $$ = _parse_Declaration();
            // <= Declaration
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          // <= Declaration*
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => Declaration*
          var testing2 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => Declaration
            $$ = _parse_Declaration();
            // <= Declaration
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing2;
              $$ = reps;
              break; 
            }
          }
          // <= Declaration*
          _startPos = startPos2;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= Declaration* # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationModifier() {
    // SENTENCE (NONTERMINAL)
    // DeclarationModifier <- Identifier OPEN_PAREN DeclarationModifierArguments? CLOSE_PAREN / Identifier
    var $$;          
    var pos = _cursor;             
    if(_cachePos[7] >= pos) {
      $$ = _getFromCache(7);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[7] = pos;
    }  
    // => Identifier OPEN_PAREN DeclarationModifierArguments? CLOSE_PAREN / Identifier # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => Identifier OPEN_PAREN DeclarationModifierArguments? CLOSE_PAREN # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Identifier
            $$ = _parse_Identifier();
            // <= Identifier
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => OPEN_PAREN
            $$ = _parse_OPEN_PAREN();
            // <= OPEN_PAREN
            if (!success) break;
            seq[1] = $$;
            // => DeclarationModifierArguments?
            var testing0 = _testing;
            _testing = _cursor;
            // => DeclarationModifierArguments
            $$ = _parse_DeclarationModifierArguments();
            // <= DeclarationModifierArguments
            success = true; 
            _testing = testing0;
            // <= DeclarationModifierArguments?
            if (!success) break;
            seq[2] = $$;
            // => CLOSE_PAREN
            $$ = _parse_CLOSE_PAREN();
            // <= CLOSE_PAREN
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Identifier
              final $1 = seq[0];
              // OPEN_PAREN
              final $2 = seq[1];
              // DeclarationModifierArguments?
              final $3 = seq[2];
              // CLOSE_PAREN
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new DeclarationModifier(arguments: $3, identifier: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Identifier OPEN_PAREN DeclarationModifierArguments? CLOSE_PAREN # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (success) {    
            // Identifier
            final $1 = $$;
            final $start = startPos1;
            $$ = new DeclarationModifier(identifier: $1);
          }
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= Identifier OPEN_PAREN DeclarationModifierArguments? CLOSE_PAREN / Identifier # Choice
    if (_cacheable[7]) {
      _addToCache($$, pos, 7);
    }    
    return $$;
  }
  
  dynamic _parse_DeclarationModifierArgument() {
    // SENTENCE (NONTERMINAL)
    // DeclarationModifierArgument <- constant_expression
    var $$;          
    var pos = _cursor;             
    if(_cachePos[10] >= pos) {
      $$ = _getFromCache(10);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[10] = pos;
    }  
    // => constant_expression # Choice
    switch (_getState(_transitions3)) {
      // [!-\"] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => constant_expression
        $$ = _parse_constant_expression();
        // <= constant_expression
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, ", L", NONDIGIT, \U, \u
      _failure(_expect7);
    }
    // <= constant_expression # Choice
    if (_cacheable[10]) {
      _addToCache($$, pos, 10);
    }    
    return $$;
  }
  
  dynamic _parse_DeclarationModifierArguments() {
    // SENTENCE (NONTERMINAL)
    // DeclarationModifierArguments <- DeclarationModifierArgument (COMMA DeclarationModifierArgument)*
    var $$;
    // => DeclarationModifierArgument (COMMA DeclarationModifierArgument)* # Choice
    switch (_getState(_transitions3)) {
      // [!-\"] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => DeclarationModifierArgument (COMMA DeclarationModifierArgument)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => DeclarationModifierArgument
          $$ = _parse_DeclarationModifierArgument();
          // <= DeclarationModifierArgument
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA DeclarationModifierArgument)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA DeclarationModifierArgument) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA DeclarationModifierArgument # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => DeclarationModifierArgument
                  $$ = _parse_DeclarationModifierArgument();
                  // <= DeclarationModifierArgument
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA DeclarationModifierArgument # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ,
              _failure(_expect6);
            }
            // <= (COMMA DeclarationModifierArgument) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA DeclarationModifierArgument)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // DeclarationModifierArgument
            final $1 = seq[0];
            // (COMMA DeclarationModifierArgument)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new Arguments(elements: _list($1, $2));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= DeclarationModifierArgument (COMMA DeclarationModifierArgument)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, ", L", NONDIGIT, \U, \u
      _failure(_expect7);
    }
    // <= DeclarationModifierArgument (COMMA DeclarationModifierArgument)* # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationModifierList() {
    // SENTENCE (NONTERMINAL)
    // DeclarationModifierList <- DeclarationModifier (COMMA DeclarationModifier)*
    var $$;
    // => DeclarationModifier (COMMA DeclarationModifier)* # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => DeclarationModifier (COMMA DeclarationModifier)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => DeclarationModifier
          $$ = _parse_DeclarationModifier();
          // <= DeclarationModifier
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA DeclarationModifier)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA DeclarationModifier) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA DeclarationModifier # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => DeclarationModifier
                  $$ = _parse_DeclarationModifier();
                  // <= DeclarationModifier
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA DeclarationModifier # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ,
              _failure(_expect6);
            }
            // <= (COMMA DeclarationModifier) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA DeclarationModifier)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // DeclarationModifier
            final $1 = seq[0];
            // (COMMA DeclarationModifier)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new DeclarationModifiers(elements: _list($1, $2));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= DeclarationModifier (COMMA DeclarationModifier)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= DeclarationModifier (COMMA DeclarationModifier)* # Choice
    return $$;
  }
  
  dynamic _parse_DeclarationSpecifier() {
    // SENTENCE (NONTERMINAL)
    // DeclarationSpecifier <- ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN
    var $$;
    // => ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        // => ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ATTRIBUTE
          $$ = _parse_ATTRIBUTE();
          // <= ATTRIBUTE
          if (!success) break;
          var seq = new List(6)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[2] = $$;
          // => DeclarationModifierList?
          var testing0 = _testing;
          _testing = _cursor;
          // => DeclarationModifierList
          $$ = _parse_DeclarationModifierList();
          // <= DeclarationModifierList
          success = true; 
          _testing = testing0;
          // <= DeclarationModifierList?
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[4] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[5] = $$;
          $$ = seq;
          if (success) {    
            // ATTRIBUTE
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // OPEN_PAREN
            final $3 = seq[2];
            // DeclarationModifierList?
            final $4 = seq[3];
            // CLOSE_PAREN
            final $5 = seq[4];
            // CLOSE_PAREN
            final $6 = seq[5];
            final $start = startPos0;
            $$ = new DeclarationSpecifier(identifier: $1, modifiers: $4, parenthesis: true);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: __attribute__
      _failure(_expect4);
    }
    // <= ATTRIBUTE OPEN_PAREN OPEN_PAREN DeclarationModifierList? CLOSE_PAREN CLOSE_PAREN # Choice
    return $$;
  }
  
  dynamic _parse_DeclaratorAbstract() {
    // SENTENCE (NONTERMINAL)
    // DeclaratorAbstract <- PointerSpecifiers ArrayDimensions Metadata? / PointerSpecifiers? ArrayDimensions Metadata? / PointerSpecifiers ArrayDimensions? Metadata?
    var $$;
    // => PointerSpecifiers ArrayDimensions Metadata? / PointerSpecifiers? ArrayDimensions Metadata? / PointerSpecifiers ArrayDimensions? Metadata? # Choice
    switch (_getState(_transitions30)) {
      // [*]
      case 0:
        while (true) {
          // => PointerSpecifiers ArrayDimensions Metadata? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => PointerSpecifiers
            $$ = _parse_PointerSpecifiers();
            // <= PointerSpecifiers
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ArrayDimensions
            $$ = _parse_ArrayDimensions();
            // <= ArrayDimensions
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // PointerSpecifiers
              final $1 = seq[0];
              // ArrayDimensions
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              final $start = startPos0;
              $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= PointerSpecifiers ArrayDimensions Metadata? # Sequence
          if (success) break;
          // => PointerSpecifiers? ArrayDimensions Metadata? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => PointerSpecifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => PointerSpecifiers
            $$ = _parse_PointerSpecifiers();
            // <= PointerSpecifiers
            success = true; 
            _testing = testing1;
            // <= PointerSpecifiers?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ArrayDimensions
            $$ = _parse_ArrayDimensions();
            // <= ArrayDimensions
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // PointerSpecifiers?
              final $1 = seq[0];
              // ArrayDimensions
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= PointerSpecifiers? ArrayDimensions Metadata? # Sequence
          if (success) break;
          // => PointerSpecifiers ArrayDimensions? Metadata? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => PointerSpecifiers
            $$ = _parse_PointerSpecifiers();
            // <= PointerSpecifiers
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ArrayDimensions?
            var testing3 = _testing;
            _testing = _cursor;
            // => ArrayDimensions
            $$ = _parse_ArrayDimensions();
            // <= ArrayDimensions
            success = true; 
            _testing = testing3;
            // <= ArrayDimensions?
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing4 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing4;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // PointerSpecifiers
              final $1 = seq[0];
              // ArrayDimensions?
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              final $start = startPos2;
              $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= PointerSpecifiers ArrayDimensions? Metadata? # Sequence
          break;
        }
        break;
      // [[]
      case 1:
        // => PointerSpecifiers? ArrayDimensions Metadata? # Sequence
        var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing5 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing5;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => ArrayDimensions
          $$ = _parse_ArrayDimensions();
          // <= ArrayDimensions
          if (!success) break;
          seq[1] = $$;
          // => Metadata?
          var testing6 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing6;
          // <= Metadata?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // ArrayDimensions
            final $2 = seq[1];
            // Metadata?
            final $3 = seq[2];
            final $start = startPos3;
            $$ = new Declarator(dimensions: $2, metadata: $3, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch3;
          _cursor = pos3;
        }
        _startPos = startPos3;
        // <= PointerSpecifiers? ArrayDimensions Metadata? # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: *, [
      _failure(_expect51);
    }
    // <= PointerSpecifiers ArrayDimensions Metadata? / PointerSpecifiers? ArrayDimensions Metadata? / PointerSpecifiers ArrayDimensions? Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_DeclaratorNotAbstract() {
    // SENTENCE (NONTERMINAL)
    // DeclaratorNotAbstract <- PointerSpecifiers? Identifier ArrayDimensions? Metadata?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[95] >= pos) {
      $$ = _getFromCache(95);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[95] = pos;
    }  
    // => PointerSpecifiers? Identifier ArrayDimensions? Metadata? # Choice
    switch (_getState(_transitions22)) {
      // [*] [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => PointerSpecifiers? Identifier ArrayDimensions? Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing0;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[1] = $$;
          // => ArrayDimensions?
          var testing1 = _testing;
          _testing = _cursor;
          // => ArrayDimensions
          $$ = _parse_ArrayDimensions();
          // <= ArrayDimensions
          success = true; 
          _testing = testing1;
          // <= ArrayDimensions?
          if (!success) break;
          seq[2] = $$;
          // => Metadata?
          var testing2 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing2;
          // <= Metadata?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // Identifier
            final $2 = seq[1];
            // ArrayDimensions?
            final $3 = seq[2];
            // Metadata?
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Declarator(dimensions: $3, identifier: $2, metadata: $4, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerSpecifiers? Identifier ArrayDimensions? Metadata? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= PointerSpecifiers? Identifier ArrayDimensions? Metadata? # Choice
    if (_cacheable[95]) {
      _addToCache($$, pos, 95);
    }    
    return $$;
  }
  
  dynamic _parse_DefinedType() {
    // SENTENCE (NONTERMINAL)
    // DefinedType <- Identifier Metadata? TypeQualifiers?
    var $$;
    // => Identifier Metadata? TypeQualifiers? # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Identifier Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Identifier
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new DefinedTypeSpecification(identifier: $1, metadata: $2, qualifiers: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Identifier Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= Identifier Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_Dimension() {
    // SENTENCE (NONTERMINAL)
    // Dimension <- OPEN_BRACKET constant_expression? CLOSE_BRACKET
    var $$;
    // => OPEN_BRACKET constant_expression? CLOSE_BRACKET # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => OPEN_BRACKET constant_expression? CLOSE_BRACKET # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => OPEN_BRACKET
          $$ = _parse_OPEN_BRACKET();
          // <= OPEN_BRACKET
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => constant_expression?
          var testing0 = _testing;
          _testing = _cursor;
          // => constant_expression
          $$ = _parse_constant_expression();
          // <= constant_expression
          success = true; 
          _testing = testing0;
          // <= constant_expression?
          if (!success) break;
          seq[1] = $$;
          // => CLOSE_BRACKET
          $$ = _parse_CLOSE_BRACKET();
          // <= CLOSE_BRACKET
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // OPEN_BRACKET
            final $1 = seq[0];
            // constant_expression?
            final $2 = seq[1];
            // CLOSE_BRACKET
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= OPEN_BRACKET constant_expression? CLOSE_BRACKET # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: [
      _failure(_expect52);
    }
    // <= OPEN_BRACKET constant_expression? CLOSE_BRACKET # Choice
    return $$;
  }
  
  dynamic _parse_ELLIPSIS() {
    // SENTENCE (NONTERMINAL)
    // ELLIPSIS <- '...' SPACING
    var $$;
    // => '...' SPACING # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        // => '...' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '...'
          $$ = _matchString(_strings11, '...');
          // <= '...'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '...'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '...' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ...
      _failure(_expect63);
    }
    // <= '...' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_ENUM() {
    // SENTENCE (NONTERMINAL)
    // ENUM <- 'enum' !IDENTIFIER_BASE1 SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[120] >= pos) {
      $$ = _getFromCache(120);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[120] = pos;
    }  
    // => 'enum' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => 'enum' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'enum'
          $$ = _matchString(_strings12, 'enum');
          // <= 'enum'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'enum'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'enum' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: enum
      _failure(_expect53);
    }
    // <= 'enum' !IDENTIFIER_BASE1 SPACING # Choice
    if (_cacheable[120]) {
      _addToCache($$, pos, 120);
    }    
    return $$;
  }
  
  dynamic _parse_EOF() {
    // LEXEME (TOKEN)
    // EOF <- !.
    var $$;
    _token = 0;  
    _tokenStart = _cursor;  
    // => !. # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => !.
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
        _testing = _inputLen + 1;
        // => .
        $$ = _matchAny();
        // <= .
        _ch = ch0;
        _cursor = pos0; 
        _testing = testing0;
        $$ = null;
        success = !success;
        // <= !.
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= !. # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_EOL() {
    // MORHEME
    // EOL <- '\r\n' / [\n\r]
    var $$;
    // => '\r\n' / [\n\r] # Choice
    switch (_getState(_transitions47)) {
      // [\n]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\n\r]
        $$ = _matchMapping(10, 13, _mapping1);
        // <= [\n\r]
        _startPos = startPos0;
        break;
      // [\r]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => '\r\n'
          $$ = _matchString(_strings50, '\r\n');
          // <= '\r\n'
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => [\n\r]
          $$ = _matchMapping(10, 13, _mapping1);
          // <= [\n\r]
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= '\r\n' / [\n\r] # Choice
    return $$;
  }
  
  dynamic _parse_ESCAPE_SEQUENCE() {
    // SENTENCE (NONTERMINAL)
    // ESCAPE_SEQUENCE <- SIMPLE_ESCAPE_SEQUENCE / OCTAL_ESCAPE_SEQUENCE / HEXADECIMAL_ESCAPE_SEQUENCE / UNIVERSAL_CHARACTER_NAME
    var $$;          
    var pos = _cursor;             
    if(_cachePos[164] >= pos) {
      $$ = _getFromCache(164);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[164] = pos;
    }  
    // => SIMPLE_ESCAPE_SEQUENCE / OCTAL_ESCAPE_SEQUENCE / HEXADECIMAL_ESCAPE_SEQUENCE / UNIVERSAL_CHARACTER_NAME # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => SIMPLE_ESCAPE_SEQUENCE
          $$ = _parse_SIMPLE_ESCAPE_SEQUENCE();
          // <= SIMPLE_ESCAPE_SEQUENCE
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => OCTAL_ESCAPE_SEQUENCE
          $$ = _parse_OCTAL_ESCAPE_SEQUENCE();
          // <= OCTAL_ESCAPE_SEQUENCE
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => HEXADECIMAL_ESCAPE_SEQUENCE
          $$ = _parse_HEXADECIMAL_ESCAPE_SEQUENCE();
          // <= HEXADECIMAL_ESCAPE_SEQUENCE
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => UNIVERSAL_CHARACTER_NAME
          $$ = _parse_UNIVERSAL_CHARACTER_NAME();
          // <= UNIVERSAL_CHARACTER_NAME
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SIMPLE_ESCAPE_SEQUENCE, '\', \x, \U, \u
      _failure(_expect88);
    }
    // <= SIMPLE_ESCAPE_SEQUENCE / OCTAL_ESCAPE_SEQUENCE / HEXADECIMAL_ESCAPE_SEQUENCE / UNIVERSAL_CHARACTER_NAME # Choice
    if (_cacheable[164]) {
      _addToCache($$, pos, 164);
    }    
    return $$;
  }
  
  dynamic _parse_EXPONENT_PART() {
    // SENTENCE (NONTERMINAL)
    // EXPONENT_PART <- ('e' / 'E') SIGN? DIGIT_SEQUENCE
    var $$;          
    var pos = _cursor;             
    if(_cachePos[165] >= pos) {
      $$ = _getFromCache(165);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[165] = pos;
    }  
    // => ('e' / 'E') SIGN? DIGIT_SEQUENCE # Choice
    switch (_getState(_transitions55)) {
      // [E] [e]
      case 0:
        // => ('e' / 'E') SIGN? DIGIT_SEQUENCE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ('e' / 'E') # Choice
          switch (_getState(_transitions56)) {
            // [E]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => 'E'
              $$ = _matchChar(69, 'E');
              // <= 'E'
              _startPos = startPos1;
              break;
            // [e]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => 'e'
              $$ = 'e';
              success = true;
              if (++_cursor < _inputLen) {
                _ch = _input[_cursor];
              } else {
                _ch = -1;
              }
              // <= 'e'
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: e, E
            _failure(_expect89);
          }
          // <= ('e' / 'E') # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => SIGN?
          var testing0 = _testing;
          _testing = _cursor;
          // => SIGN
          $$ = _parse_SIGN();
          // <= SIGN
          success = true; 
          _testing = testing0;
          // <= SIGN?
          if (!success) break;
          seq[1] = $$;
          // => DIGIT_SEQUENCE
          $$ = _parse_DIGIT_SEQUENCE();
          // <= DIGIT_SEQUENCE
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ('e' / 'E')
            final $1 = seq[0];
            // SIGN?
            final $2 = seq[1];
            // DIGIT_SEQUENCE
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('e' / 'E') SIGN? DIGIT_SEQUENCE # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: e, E
      _failure(_expect89);
    }
    // <= ('e' / 'E') SIGN? DIGIT_SEQUENCE # Choice
    if (_cacheable[165]) {
      _addToCache($$, pos, 165);
    }    
    return $$;
  }
  
  dynamic _parse_EnumDeclaration() {
    // SENTENCE (NONTERMINAL)
    // EnumDeclaration <- Metadata? TypeQualifiers? EnumType
    var $$;
    // => Metadata? TypeQualifiers? EnumType # Choice
    switch (_getState(_transitions33)) {
      // [_] [c] [e] [v]
      case 0:
        // => Metadata? TypeQualifiers? EnumType # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => EnumType
          $$ = _parse_EnumType();
          // <= EnumType
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // EnumType
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new EnumDeclaration(metadata: $1, qualifiers: $2, type: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? EnumType # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: enum
      _failure(_expect53);
    }
    // <= Metadata? TypeQualifiers? EnumType # Choice
    return $$;
  }
  
  dynamic _parse_EnumType() {
    // SENTENCE (NONTERMINAL)
    // EnumType <- EnumTypeSpecifier OPEN_BRACE Enumerators CLOSE_BRACE Metadata? TypeQualifiers? / EnumTypeSpecifierWithTag Metadata? TypeQualifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[88] >= pos) {
      $$ = _getFromCache(88);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[88] = pos;
    }  
    // => EnumTypeSpecifier OPEN_BRACE Enumerators CLOSE_BRACE Metadata? TypeQualifiers? / EnumTypeSpecifierWithTag Metadata? TypeQualifiers? # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        while (true) {
          // => EnumTypeSpecifier OPEN_BRACE Enumerators CLOSE_BRACE Metadata? TypeQualifiers? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => EnumTypeSpecifier
            $$ = _parse_EnumTypeSpecifier();
            // <= EnumTypeSpecifier
            if (!success) break;
            var seq = new List(6)..[0] = $$;
            // => OPEN_BRACE
            $$ = _parse_OPEN_BRACE();
            // <= OPEN_BRACE
            if (!success) break;
            seq[1] = $$;
            // => Enumerators
            $$ = _parse_Enumerators();
            // <= Enumerators
            if (!success) break;
            seq[2] = $$;
            // => CLOSE_BRACE
            $$ = _parse_CLOSE_BRACE();
            // <= CLOSE_BRACE
            if (!success) break;
            seq[3] = $$;
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            seq[4] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[5] = $$;
            $$ = seq;
            if (success) {    
              // EnumTypeSpecifier
              final $1 = seq[0];
              // OPEN_BRACE
              final $2 = seq[1];
              // Enumerators
              final $3 = seq[2];
              // CLOSE_BRACE
              final $4 = seq[3];
              // Metadata?
              final $5 = seq[4];
              // TypeQualifiers?
              final $6 = seq[5];
              final $start = startPos0;
              $$ = new EnumTypeSpecification(metadata: $5, elaboratedType: $1, qualifiers: $6, enumerators: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= EnumTypeSpecifier OPEN_BRACE Enumerators CLOSE_BRACE Metadata? TypeQualifiers? # Sequence
          if (success) break;
          // => EnumTypeSpecifierWithTag Metadata? TypeQualifiers? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => EnumTypeSpecifierWithTag
            $$ = _parse_EnumTypeSpecifierWithTag();
            // <= EnumTypeSpecifierWithTag
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            seq[1] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // EnumTypeSpecifierWithTag
              final $1 = seq[0];
              // Metadata?
              final $2 = seq[1];
              // TypeQualifiers?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new EnumTypeSpecification(metadata: $2, elaboratedType: $1, qualifiers: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= EnumTypeSpecifierWithTag Metadata? TypeQualifiers? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: enum
      _failure(_expect53);
    }
    // <= EnumTypeSpecifier OPEN_BRACE Enumerators CLOSE_BRACE Metadata? TypeQualifiers? / EnumTypeSpecifierWithTag Metadata? TypeQualifiers? # Choice
    if (_cacheable[88]) {
      _addToCache($$, pos, 88);
    }    
    return $$;
  }
  
  dynamic _parse_EnumTypeSpecifier() {
    // SENTENCE (NONTERMINAL)
    // EnumTypeSpecifier <- ENUM Metadata? Identifier?
    var $$;
    // => ENUM Metadata? Identifier? # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => ENUM Metadata? Identifier? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ENUM
          $$ = _parse_ENUM();
          // <= ENUM
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => Identifier?
          var testing1 = _testing;
          _testing = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          success = true; 
          _testing = testing1;
          // <= Identifier?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ENUM
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // Identifier?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ENUM Metadata? Identifier? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: enum
      _failure(_expect53);
    }
    // <= ENUM Metadata? Identifier? # Choice
    return $$;
  }
  
  dynamic _parse_EnumTypeSpecifierWithTag() {
    // SENTENCE (NONTERMINAL)
    // EnumTypeSpecifierWithTag <- ENUM Metadata? Identifier
    var $$;
    // => ENUM Metadata? Identifier # Choice
    switch (_ch == 101 ? 0 : _ch == -1 ? 2 : 1) {
      // [e]
      case 0:
        // => ENUM Metadata? Identifier # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ENUM
          $$ = _parse_ENUM();
          // <= ENUM
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ENUM
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // Identifier
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ENUM Metadata? Identifier # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: enum
      _failure(_expect53);
    }
    // <= ENUM Metadata? Identifier # Choice
    return $$;
  }
  
  dynamic _parse_Enumerator() {
    // SENTENCE (NONTERMINAL)
    // Enumerator <- Identifier ASSIGN (constant_expression) / Identifier
    var $$;          
    var pos = _cursor;             
    if(_cachePos[92] >= pos) {
      $$ = _getFromCache(92);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[92] = pos;
    }  
    // => Identifier ASSIGN (constant_expression) / Identifier # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => Identifier ASSIGN (constant_expression) # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Identifier
            $$ = _parse_Identifier();
            // <= Identifier
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ASSIGN
            $$ = _parse_ASSIGN();
            // <= ASSIGN
            if (!success) break;
            seq[1] = $$;
            // => (constant_expression) # Choice
            switch (_getState(_transitions3)) {
              // [!-\"] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
              // EOF
              case 0:
              case 2:
                var startPos1 = _startPos;
                _startPos = _cursor;
                // => constant_expression
                $$ = _parse_constant_expression();
                // <= constant_expression
                _startPos = startPos1;
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, ", L", NONDIGIT, \U, \u
              _failure(_expect7);
            }
            // <= (constant_expression) # Choice
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // Identifier
              final $1 = seq[0];
              // ASSIGN
              final $2 = seq[1];
              // (constant_expression)
              final $3 = seq[2];
              final $start = startPos0;
              $$ = new Enumerator(identifier: $1, value: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Identifier ASSIGN (constant_expression) # Sequence
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (success) {    
            // Identifier
            final $1 = $$;
            final $start = startPos2;
            $$ = new Enumerator(identifier: $1);
          }
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= Identifier ASSIGN (constant_expression) / Identifier # Choice
    if (_cacheable[92]) {
      _addToCache($$, pos, 92);
    }    
    return $$;
  }
  
  dynamic _parse_EnumeratorList() {
    // SENTENCE (NONTERMINAL)
    // EnumeratorList <- Enumerator (COMMA Enumerator)* COMMA?
    var $$;
    // => Enumerator (COMMA Enumerator)* COMMA? # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Enumerator (COMMA Enumerator)* COMMA? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Enumerator
          $$ = _parse_Enumerator();
          // <= Enumerator
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (COMMA Enumerator)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA Enumerator) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA Enumerator # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => Enumerator
                  $$ = _parse_Enumerator();
                  // <= Enumerator
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA Enumerator # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ,
              _failure(_expect6);
            }
            // <= (COMMA Enumerator) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA Enumerator)*
          if (!success) break;
          seq[1] = $$;
          // => COMMA?
          var testing1 = _testing;
          _testing = _cursor;
          // => COMMA
          $$ = _parse_COMMA();
          // <= COMMA
          success = true; 
          _testing = testing1;
          // <= COMMA?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Enumerator
            final $1 = seq[0];
            // (COMMA Enumerator)*
            final $2 = seq[1];
            // COMMA?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Enumerator (COMMA Enumerator)* COMMA? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= Enumerator (COMMA Enumerator)* COMMA? # Choice
    return $$;
  }
  
  dynamic _parse_Enumerators() {
    // SENTENCE (NONTERMINAL)
    // Enumerators <- EnumeratorList
    var $$;
    // => EnumeratorList # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => EnumeratorList
        $$ = _parse_EnumeratorList();
        // <= EnumeratorList
        if (success) {    
          // EnumeratorList
          final $1 = $$;
          final $start = startPos0;
          $$ = new Enumerators(elements: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= EnumeratorList # Choice
    return $$;
  }
  
  dynamic _parse_FLOAT() {
    // SENTENCE (NONTERMINAL)
    // FLOAT <- 'float' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'float' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 102 ? 0 : _ch == -1 ? 2 : 1) {
      // [f]
      case 0:
        // => 'float' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'float'
          $$ = _matchString(_strings25, 'float');
          // <= 'float'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'float'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'float' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: float
      _failure(_expect76);
    }
    // <= 'float' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_FLOATING_SUFFIX() {
    // LEXEME (TOKEN)
    // FLOATING_SUFFIX <- [FLfl]
    var $$;          
    var pos = _cursor;             
    if(_cachePos[166] >= pos) {
      $$ = _getFromCache(166);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[166] = pos;
    }  
    _token = 4;    
    _tokenStart = _cursor;    
    // => [FLfl] # Choice
    switch (_getState(_transitions57)) {
      // [F] [L] [f] [l]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [FLfl]
        $$ = _matchMapping(70, 108, _mapping4);
        // <= [FLfl]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: FLOATING_SUFFIX
      _failure(_expect90);
    }
    // <= [FLfl] # Choice
    if (_cacheable[166]) {
      _addToCache($$, pos, 166);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_FRACTIONAL_CONSTANT() {
    // SENTENCE (NONTERMINAL)
    // FRACTIONAL_CONSTANT <- DIGIT_SEQUENCE? '.' DIGIT_SEQUENCE / DIGIT_SEQUENCE '.'
    var $$;
    // => DIGIT_SEQUENCE? '.' DIGIT_SEQUENCE / DIGIT_SEQUENCE '.' # Choice
    switch (_getState(_transitions14)) {
      // [.]
      case 0:
        // => DIGIT_SEQUENCE? '.' DIGIT_SEQUENCE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => DIGIT_SEQUENCE?
          var testing0 = _testing;
          _testing = _cursor;
          // => DIGIT_SEQUENCE
          $$ = _parse_DIGIT_SEQUENCE();
          // <= DIGIT_SEQUENCE
          success = true; 
          _testing = testing0;
          // <= DIGIT_SEQUENCE?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => '.'
          $$ = _matchChar(46, '.');
          // <= '.'
          if (!success) break;
          seq[1] = $$;
          // => DIGIT_SEQUENCE
          $$ = _parse_DIGIT_SEQUENCE();
          // <= DIGIT_SEQUENCE
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // DIGIT_SEQUENCE?
            final $1 = seq[0];
            // '.'
            final $2 = seq[1];
            // DIGIT_SEQUENCE
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= DIGIT_SEQUENCE? '.' DIGIT_SEQUENCE # Sequence
        break;
      // [0-9]
      case 1:
        while (true) {
          // => DIGIT_SEQUENCE? '.' DIGIT_SEQUENCE # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => DIGIT_SEQUENCE?
            var testing1 = _testing;
            _testing = _cursor;
            // => DIGIT_SEQUENCE
            $$ = _parse_DIGIT_SEQUENCE();
            // <= DIGIT_SEQUENCE
            success = true; 
            _testing = testing1;
            // <= DIGIT_SEQUENCE?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            // => DIGIT_SEQUENCE
            $$ = _parse_DIGIT_SEQUENCE();
            // <= DIGIT_SEQUENCE
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // DIGIT_SEQUENCE?
              final $1 = seq[0];
              // '.'
              final $2 = seq[1];
              // DIGIT_SEQUENCE
              final $3 = seq[2];
              final $start = startPos1;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= DIGIT_SEQUENCE? '.' DIGIT_SEQUENCE # Sequence
          if (success) break;
          // => DIGIT_SEQUENCE '.' # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => DIGIT_SEQUENCE
            $$ = _parse_DIGIT_SEQUENCE();
            // <= DIGIT_SEQUENCE
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // DIGIT_SEQUENCE
              final $1 = seq[0];
              // '.'
              final $2 = seq[1];
              final $start = startPos2;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= DIGIT_SEQUENCE '.' # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ., DIGIT
      _failure(_expect17);
    }
    // <= DIGIT_SEQUENCE? '.' DIGIT_SEQUENCE / DIGIT_SEQUENCE '.' # Choice
    return $$;
  }
  
  dynamic _parse_FloatType() {
    // SENTENCE (NONTERMINAL)
    // FloatType <- FloatTypeSpeficiers Metadata? TypeQualifiers?
    var $$;
    // => FloatTypeSpeficiers Metadata? TypeQualifiers? # Choice
    switch (_getState(_transitions26)) {
      // [d] [f]
      case 0:
        // => FloatTypeSpeficiers Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FloatTypeSpeficiers
          $$ = _parse_FloatTypeSpeficiers();
          // <= FloatTypeSpeficiers
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // FloatTypeSpeficiers
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new BasicTypeSpecification(metadata: $2, qualifiers: $3, specifiers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FloatTypeSpeficiers Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: float, double
      _failure(_expect45);
    }
    // <= FloatTypeSpeficiers Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_FloatTypeSpeficiers() {
    // SENTENCE (NONTERMINAL)
    // FloatTypeSpeficiers <- (FLOAT / DOUBLE)
    var $$;
    // => (FLOAT / DOUBLE) # Choice
    switch (_getState(_transitions26)) {
      // [d] [f]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (FLOAT / DOUBLE) # Choice
        switch (_getState(_transitions39)) {
          // [d]
          case 0:
            var startPos1 = _startPos;
            _startPos = _cursor;
            // => DOUBLE
            $$ = _parse_DOUBLE();
            // <= DOUBLE
            _startPos = startPos1;
            break;
          // [f]
          case 1:
            var startPos2 = _startPos;
            _startPos = _cursor;
            // => FLOAT
            $$ = _parse_FLOAT();
            // <= FLOAT
            _startPos = startPos2;
            break;
          // No matches
          // EOF
          case 2:
          case 3:
            $$ = null;
            success = false;
            break;
        }
        if (!success && _cursor > _testing) {
          // Expected: float, double
          _failure(_expect45);
        }
        // <= (FLOAT / DOUBLE) # Choice
        if (success) {    
          // (FLOAT / DOUBLE)
          final $1 = $$;
          final $start = startPos0;
          $$ = new TypeSpecifiers(elements: [$1]);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: float, double
      _failure(_expect45);
    }
    // <= (FLOAT / DOUBLE) # Choice
    return $$;
  }
  
  dynamic _parse_FunctionDeclaration() {
    // SENTENCE (NONTERMINAL)
    // FunctionDeclaration <- Metadata? TypeQualifiers? FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionDeclarator
    var $$;
    // => Metadata? TypeQualifiers? FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionDeclarator # Choice
    switch (_getState(_transitions1)) {
      // [*]
      case 0:
        // => Metadata? TypeQualifiers? FunctionDeclarator # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => FunctionDeclarator
          $$ = _parse_FunctionDeclarator();
          // <= FunctionDeclarator
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // FunctionDeclarator
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new FunctionDeclaration(declarator: $3, metadata: $1, qualifiers: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? FunctionDeclarator # Sequence
        break;
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 1:
      case 3:
        while (true) {
          // => Metadata? TypeQualifiers? FunctionDeclarator # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => FunctionDeclarator
            $$ = _parse_FunctionDeclarator();
            // <= FunctionDeclarator
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // FunctionDeclarator
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new FunctionDeclaration(declarator: $3, metadata: $1, qualifiers: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Metadata? TypeQualifiers? FunctionDeclarator # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type FunctionDeclarator # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing4 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing4;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing5 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing5;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => FunctionDeclarator
            $$ = _parse_FunctionDeclarator();
            // <= FunctionDeclarator
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // FunctionDeclarator
              final $4 = seq[3];
              final $start = startPos2;
              $$ = new FunctionDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= Metadata? TypeQualifiers? Type FunctionDeclarator # Sequence
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionDeclarator # Choice
    return $$;
  }
  
  dynamic _parse_FunctionDeclarator() {
    // SENTENCE (NONTERMINAL)
    // FunctionDeclarator <- PointerSpecifiers? Identifier OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[62] >= pos) {
      $$ = _getFromCache(62);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[62] = pos;
    }  
    // => PointerSpecifiers? Identifier OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata? # Choice
    switch (_getState(_transitions22)) {
      // [*] [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => PointerSpecifiers? Identifier OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing0;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(6)..[0] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[1] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[2] = $$;
          // => FunctionParameters
          $$ = _parse_FunctionParameters();
          // <= FunctionParameters
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[4] = $$;
          // => Metadata?
          var testing1 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing1;
          // <= Metadata?
          if (!success) break;
          seq[5] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // Identifier
            final $2 = seq[1];
            // OPEN_PAREN
            final $3 = seq[2];
            // FunctionParameters
            final $4 = seq[3];
            // CLOSE_PAREN
            final $5 = seq[4];
            // Metadata?
            final $6 = seq[5];
            final $start = startPos0;
            $$ = new Declarator(identifier: $2, metadata: $6, parameters: $4, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerSpecifiers? Identifier OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= PointerSpecifiers? Identifier OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata? # Choice
    if (_cacheable[62]) {
      _addToCache($$, pos, 62);
    }    
    return $$;
  }
  
  dynamic _parse_FunctionParameterDeclaration() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameterDeclaration <- ParameterDeclarationNotAbstract / ParameterDeclarationAbstract
    var $$;          
    var pos = _cursor;             
    if(_cachePos[67] >= pos) {
      $$ = _getFromCache(67);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[67] = pos;
    }  
    // => ParameterDeclarationNotAbstract / ParameterDeclarationAbstract # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => ParameterDeclarationNotAbstract
          $$ = _parse_ParameterDeclarationNotAbstract();
          // <= ParameterDeclarationNotAbstract
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => ParameterDeclarationAbstract
          $$ = _parse_ParameterDeclarationAbstract();
          // <= ParameterDeclarationAbstract
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= ParameterDeclarationNotAbstract / ParameterDeclarationAbstract # Choice
    if (_cacheable[67]) {
      _addToCache($$, pos, 67);
    }    
    return $$;
  }
  
  dynamic _parse_FunctionParameterList() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameterList <- FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)*
    var $$;
    // => FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FunctionParameterDeclaration
          $$ = _parse_FunctionParameterDeclaration();
          // <= FunctionParameterDeclaration
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA FunctionParameterDeclaration)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA FunctionParameterDeclaration) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA FunctionParameterDeclaration # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => FunctionParameterDeclaration
                  $$ = _parse_FunctionParameterDeclaration();
                  // <= FunctionParameterDeclaration
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA FunctionParameterDeclaration # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ,
              _failure(_expect6);
            }
            // <= (COMMA FunctionParameterDeclaration) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA FunctionParameterDeclaration)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // FunctionParameterDeclaration
            final $1 = seq[0];
            // (COMMA FunctionParameterDeclaration)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= FunctionParameterDeclaration (COMMA FunctionParameterDeclaration)* # Choice
    return $$;
  }
  
  dynamic _parse_FunctionParameters() {
    // SENTENCE (NONTERMINAL)
    // FunctionParameters <- FunctionParameterList? (COMMA ELLIPSIS)?
    var $$;
    // => FunctionParameterList? (COMMA ELLIPSIS)? # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        // => FunctionParameterList? (COMMA ELLIPSIS)? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FunctionParameterList?
          var testing0 = _testing;
          _testing = _cursor;
          // => FunctionParameterList
          $$ = _parse_FunctionParameterList();
          // <= FunctionParameterList
          success = true; 
          _testing = testing0;
          // <= FunctionParameterList?
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA ELLIPSIS)?
          var testing1 = _testing;
          _testing = _cursor;
          // => (COMMA ELLIPSIS) # Choice
          switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
            // [,]
            case 0:
              // => COMMA ELLIPSIS # Sequence
              var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                // => COMMA
                $$ = _parse_COMMA();
                // <= COMMA
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                // => ELLIPSIS
                $$ = _parse_ELLIPSIS();
                // <= ELLIPSIS
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                if (success) {    
                  // COMMA
                  final $1 = seq[0];
                  // ELLIPSIS
                  final $2 = seq[1];
                  final $start = startPos1;
                  $$ = $2;
                }
                break;
              }
              if (!success) {
                _ch = ch1;
                _cursor = pos1;
              }
              _startPos = startPos1;
              // <= COMMA ELLIPSIS # Sequence
              break;
            // No matches
            // EOF
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: ,
            _failure(_expect6);
          }
          // <= (COMMA ELLIPSIS) # Choice
          success = true; 
          _testing = testing1;
          // <= (COMMA ELLIPSIS)?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // FunctionParameterList?
            final $1 = seq[0];
            // (COMMA ELLIPSIS)?
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new FunctionParameters(elements: $1 != null ? $1 : [], ellipsis: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FunctionParameterList? (COMMA ELLIPSIS)? # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
      // EOF
      case 2:
        while (true) {
          // => FunctionParameterList? (COMMA ELLIPSIS)? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FunctionParameterList?
            var testing2 = _testing;
            _testing = _cursor;
            // => FunctionParameterList
            $$ = _parse_FunctionParameterList();
            // <= FunctionParameterList
            success = true; 
            _testing = testing2;
            // <= FunctionParameterList?
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => (COMMA ELLIPSIS)?
            var testing3 = _testing;
            _testing = _cursor;
            // => (COMMA ELLIPSIS) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA ELLIPSIS # Sequence
                var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => ELLIPSIS
                  $$ = _parse_ELLIPSIS();
                  // <= ELLIPSIS
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  if (success) {    
                    // COMMA
                    final $1 = seq[0];
                    // ELLIPSIS
                    final $2 = seq[1];
                    final $start = startPos3;
                    $$ = $2;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch3;
                  _cursor = pos3;
                }
                _startPos = startPos3;
                // <= COMMA ELLIPSIS # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ,
              _failure(_expect6);
            }
            // <= (COMMA ELLIPSIS) # Choice
            success = true; 
            _testing = testing3;
            // <= (COMMA ELLIPSIS)?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // FunctionParameterList?
              final $1 = seq[0];
              // (COMMA ELLIPSIS)?
              final $2 = seq[1];
              final $start = startPos2;
              $$ = new FunctionParameters(elements: $1 != null ? $1 : [], ellipsis: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= FunctionParameterList? (COMMA ELLIPSIS)? # Sequence
          if (success) break;
          // => FunctionParameterList? (COMMA ELLIPSIS)? # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FunctionParameterList?
            var testing4 = _testing;
            _testing = _cursor;
            // => FunctionParameterList
            $$ = _parse_FunctionParameterList();
            // <= FunctionParameterList
            success = true; 
            _testing = testing4;
            // <= FunctionParameterList?
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => (COMMA ELLIPSIS)?
            var testing5 = _testing;
            _testing = _cursor;
            // => (COMMA ELLIPSIS) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA ELLIPSIS # Sequence
                var ch5 = _ch, pos5 = _cursor, startPos5 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => ELLIPSIS
                  $$ = _parse_ELLIPSIS();
                  // <= ELLIPSIS
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  if (success) {    
                    // COMMA
                    final $1 = seq[0];
                    // ELLIPSIS
                    final $2 = seq[1];
                    final $start = startPos5;
                    $$ = $2;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch5;
                  _cursor = pos5;
                }
                _startPos = startPos5;
                // <= COMMA ELLIPSIS # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ,
              _failure(_expect6);
            }
            // <= (COMMA ELLIPSIS) # Choice
            success = true; 
            _testing = testing5;
            // <= (COMMA ELLIPSIS)?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // FunctionParameterList?
              final $1 = seq[0];
              // (COMMA ELLIPSIS)?
              final $2 = seq[1];
              final $start = startPos4;
              $$ = new FunctionParameters(elements: $1 != null ? $1 : [], ellipsis: $2);
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos4;
          // <= FunctionParameterList? (COMMA ELLIPSIS)? # Sequence
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= FunctionParameterList? (COMMA ELLIPSIS)? # Choice
    return $$;
  }
  
  dynamic _parse_FunctionPointerDeclarator() {
    // SENTENCE (NONTERMINAL)
    // FunctionPointerDeclarator <- PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN ArrayDimensions? Metadata?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[94] >= pos) {
      $$ = _getFromCache(94);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[94] = pos;
    }  
    // => PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN ArrayDimensions? Metadata? # Choice
    switch (_getState(_transitions31)) {
      // [(] [*]
      case 0:
        // => PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN ArrayDimensions? Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing0;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(10)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          if (!success) break;
          seq[2] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[3] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[4] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[5] = $$;
          // => FunctionParameters
          $$ = _parse_FunctionParameters();
          // <= FunctionParameters
          if (!success) break;
          seq[6] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[7] = $$;
          // => ArrayDimensions?
          var testing1 = _testing;
          _testing = _cursor;
          // => ArrayDimensions
          $$ = _parse_ArrayDimensions();
          // <= ArrayDimensions
          success = true; 
          _testing = testing1;
          // <= ArrayDimensions?
          if (!success) break;
          seq[8] = $$;
          // => Metadata?
          var testing2 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing2;
          // <= Metadata?
          if (!success) break;
          seq[9] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // PointerSpecifiers
            final $3 = seq[2];
            // Identifier
            final $4 = seq[3];
            // CLOSE_PAREN
            final $5 = seq[4];
            // OPEN_PAREN
            final $6 = seq[5];
            // FunctionParameters
            final $7 = seq[6];
            // CLOSE_PAREN
            final $8 = seq[7];
            // ArrayDimensions?
            final $9 = seq[8];
            // Metadata?
            final $10 = seq[9];
            final $start = startPos0;
            $$ = new Declarator(dimensions: $9, functionPointers: $3, identifier: $4, metadata: $10, parameters: $7, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN ArrayDimensions? Metadata? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: (
      _failure(_expect18);
    }
    // <= PointerSpecifiers? OPEN_PAREN PointerSpecifiers Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN ArrayDimensions? Metadata? # Choice
    if (_cacheable[94]) {
      _addToCache($$, pos, 94);
    }    
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_CONSTANT() {
    // SENTENCE (NONTERMINAL)
    // HEXADECIMAL_CONSTANT <- HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1
    var $$;
    // => HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1 # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => HEXADECIMAL_PREFIX
          $$ = _parse_HEXADECIMAL_PREFIX();
          // <= HEXADECIMAL_PREFIX
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[1] = $$;
          // => HEXADECIMAL_CONSTANT1
          $$ = _parse_HEXADECIMAL_CONSTANT1();
          // <= HEXADECIMAL_CONSTANT1
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // HEXADECIMAL_PREFIX
            final $1 = seq[0];
            // HEXADECIMAL_DIGIT
            final $2 = seq[1];
            // HEXADECIMAL_CONSTANT1
            final $3 = seq[2];
            final $start = startPos0;
            $$ = int.parse(_text(2), radix: 16);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: HEXADECIMAL_PREFIX
      _failure(_expect72);
    }
    // <= HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1 # Choice
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_CONSTANT1() {
    // SENTENCE (NONTERMINAL)
    // HEXADECIMAL_CONSTANT1 <- (HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1)?
    var $$;
    // => (HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1)? # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1)?
        var testing0 = _testing;
        _testing = _cursor;
        // => (HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1) # Choice
        switch (_getState(_transitions58)) {
          // [0-9] [A-F] [a-f]
          case 0:
            // => HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1 # Sequence
            var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
            _startPos = _cursor;
            while (true) {  
              // => HEXADECIMAL_DIGIT
              $$ = _parse_HEXADECIMAL_DIGIT();
              // <= HEXADECIMAL_DIGIT
              if (!success) break;
              var seq = new List(2)..[0] = $$;
              // => HEXADECIMAL_CONSTANT1
              $$ = _parse_HEXADECIMAL_CONSTANT1();
              // <= HEXADECIMAL_CONSTANT1
              if (!success) break;
              seq[1] = $$;
              $$ = seq;
              break;
            }
            if (!success) {
              _ch = ch0;
              _cursor = pos0;
            }
            _startPos = startPos1;
            // <= HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1 # Sequence
            break;
          // No matches
          // EOF
          case 1:
          case 2:
            $$ = null;
            success = false;
            break;
        }
        if (!success && _cursor > _testing) {
          // Expected: HEXADECIMAL_DIGIT
          _failure(_expect91);
        }
        // <= (HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1) # Choice
        success = true; 
        _testing = testing0;
        // <= (HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1)?
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= (HEXADECIMAL_DIGIT HEXADECIMAL_CONSTANT1)? # Choice
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_DIGIT() {
    // LEXEME (TOKEN)
    // HEXADECIMAL_DIGIT <- [0-9A-Fa-f]
    var $$;          
    var pos = _cursor;             
    if(_cachePos[171] >= pos) {
      $$ = _getFromCache(171);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[171] = pos;
    }  
    _token = 5;    
    _tokenStart = _cursor;    
    // => [0-9A-Fa-f] # Choice
    switch (_getState(_transitions58)) {
      // [0-9] [A-F] [a-f]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-9A-Fa-f]
        $$ = _matchMapping(48, 102, _mapping5);
        // <= [0-9A-Fa-f]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: HEXADECIMAL_DIGIT
      _failure(_expect91);
    }
    // <= [0-9A-Fa-f] # Choice
    if (_cacheable[171]) {
      _addToCache($$, pos, 171);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_DIGIT_SEQUENCE() {
    // SENTENCE (NONTERMINAL)
    // HEXADECIMAL_DIGIT_SEQUENCE <- HEXADECIMAL_DIGIT+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[172] >= pos) {
      $$ = _getFromCache(172);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[172] = pos;
    }  
    // => HEXADECIMAL_DIGIT+ # Choice
    switch (_getState(_transitions58)) {
      // [0-9] [A-F] [a-f]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => HEXADECIMAL_DIGIT+
        var testing0;
        for (var first = true, reps; ;) {  
          // => HEXADECIMAL_DIGIT  
          $$ = _parse_HEXADECIMAL_DIGIT();  
          // <= HEXADECIMAL_DIGIT  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= HEXADECIMAL_DIGIT+
        if (success) {    
          // HEXADECIMAL_DIGIT+
          final $1 = $$;
          final $start = startPos0;
          $$ = _text();
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: HEXADECIMAL_DIGIT
      _failure(_expect91);
    }
    // <= HEXADECIMAL_DIGIT+ # Choice
    if (_cacheable[172]) {
      _addToCache($$, pos, 172);
    }    
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_ESCAPE_SEQUENCE() {
    // SENTENCE (NONTERMINAL)
    // HEXADECIMAL_ESCAPE_SEQUENCE <- '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1
    var $$;
    // => '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        // => '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '\\x'
          $$ = _matchString(_strings51, '\\x');
          // <= '\\x'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[1] = $$;
          // => HEXADECIMAL_ESCAPE_SEQUENCE1
          $$ = _parse_HEXADECIMAL_ESCAPE_SEQUENCE1();
          // <= HEXADECIMAL_ESCAPE_SEQUENCE1
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '\\x'
            final $1 = seq[0];
            // HEXADECIMAL_DIGIT
            final $2 = seq[1];
            // HEXADECIMAL_ESCAPE_SEQUENCE1
            final $3 = seq[2];
            final $start = startPos0;
            $$ = int.parse(_text(2), radix: 16);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: \x
      _failure(_expect92);
    }
    // <= '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Choice
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_ESCAPE_SEQUENCE1() {
    // SENTENCE (NONTERMINAL)
    // HEXADECIMAL_ESCAPE_SEQUENCE1 <- (HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1)?
    var $$;
    // => (HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1)? # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1)?
        var testing0 = _testing;
        _testing = _cursor;
        // => (HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1) # Choice
        switch (_getState(_transitions58)) {
          // [0-9] [A-F] [a-f]
          case 0:
            // => HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Sequence
            var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
            _startPos = _cursor;
            while (true) {  
              // => HEXADECIMAL_DIGIT
              $$ = _parse_HEXADECIMAL_DIGIT();
              // <= HEXADECIMAL_DIGIT
              if (!success) break;
              var seq = new List(2)..[0] = $$;
              // => HEXADECIMAL_ESCAPE_SEQUENCE1
              $$ = _parse_HEXADECIMAL_ESCAPE_SEQUENCE1();
              // <= HEXADECIMAL_ESCAPE_SEQUENCE1
              if (!success) break;
              seq[1] = $$;
              $$ = seq;
              break;
            }
            if (!success) {
              _ch = ch0;
              _cursor = pos0;
            }
            _startPos = startPos1;
            // <= HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1 # Sequence
            break;
          // No matches
          // EOF
          case 1:
          case 2:
            $$ = null;
            success = false;
            break;
        }
        if (!success && _cursor > _testing) {
          // Expected: HEXADECIMAL_DIGIT
          _failure(_expect91);
        }
        // <= (HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1) # Choice
        success = true; 
        _testing = testing0;
        // <= (HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1)?
        if (success) {    
          // (HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1)?
          final $1 = $$;
          final $start = startPos0;
          $$ = _text();
        }
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= (HEXADECIMAL_DIGIT HEXADECIMAL_ESCAPE_SEQUENCE1)? # Choice
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_FRACTIONAL_CONSTANT() {
    // SENTENCE (NONTERMINAL)
    // HEXADECIMAL_FRACTIONAL_CONSTANT <- HEXADECIMAL_DIGIT_SEQUENCE? '.' HEXADECIMAL_DIGIT_SEQUENCE / HEXADECIMAL_DIGIT_SEQUENCE '.'
    var $$;
    // => HEXADECIMAL_DIGIT_SEQUENCE? '.' HEXADECIMAL_DIGIT_SEQUENCE / HEXADECIMAL_DIGIT_SEQUENCE '.' # Choice
    switch (_getState(_transitions59)) {
      // [.]
      case 0:
        // => HEXADECIMAL_DIGIT_SEQUENCE? '.' HEXADECIMAL_DIGIT_SEQUENCE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => HEXADECIMAL_DIGIT_SEQUENCE?
          var testing0 = _testing;
          _testing = _cursor;
          // => HEXADECIMAL_DIGIT_SEQUENCE
          $$ = _parse_HEXADECIMAL_DIGIT_SEQUENCE();
          // <= HEXADECIMAL_DIGIT_SEQUENCE
          success = true; 
          _testing = testing0;
          // <= HEXADECIMAL_DIGIT_SEQUENCE?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => '.'
          $$ = _matchChar(46, '.');
          // <= '.'
          if (!success) break;
          seq[1] = $$;
          // => HEXADECIMAL_DIGIT_SEQUENCE
          $$ = _parse_HEXADECIMAL_DIGIT_SEQUENCE();
          // <= HEXADECIMAL_DIGIT_SEQUENCE
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= HEXADECIMAL_DIGIT_SEQUENCE? '.' HEXADECIMAL_DIGIT_SEQUENCE # Sequence
        break;
      // [0-9] [A-F] [a-f]
      case 1:
        while (true) {
          // => HEXADECIMAL_DIGIT_SEQUENCE? '.' HEXADECIMAL_DIGIT_SEQUENCE # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => HEXADECIMAL_DIGIT_SEQUENCE?
            var testing1 = _testing;
            _testing = _cursor;
            // => HEXADECIMAL_DIGIT_SEQUENCE
            $$ = _parse_HEXADECIMAL_DIGIT_SEQUENCE();
            // <= HEXADECIMAL_DIGIT_SEQUENCE
            success = true; 
            _testing = testing1;
            // <= HEXADECIMAL_DIGIT_SEQUENCE?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            // => HEXADECIMAL_DIGIT_SEQUENCE
            $$ = _parse_HEXADECIMAL_DIGIT_SEQUENCE();
            // <= HEXADECIMAL_DIGIT_SEQUENCE
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= HEXADECIMAL_DIGIT_SEQUENCE? '.' HEXADECIMAL_DIGIT_SEQUENCE # Sequence
          if (success) break;
          // => HEXADECIMAL_DIGIT_SEQUENCE '.' # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => HEXADECIMAL_DIGIT_SEQUENCE
            $$ = _parse_HEXADECIMAL_DIGIT_SEQUENCE();
            // <= HEXADECIMAL_DIGIT_SEQUENCE
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= HEXADECIMAL_DIGIT_SEQUENCE '.' # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ., HEXADECIMAL_DIGIT
      _failure(_expect93);
    }
    // <= HEXADECIMAL_DIGIT_SEQUENCE? '.' HEXADECIMAL_DIGIT_SEQUENCE / HEXADECIMAL_DIGIT_SEQUENCE '.' # Choice
    return $$;
  }
  
  dynamic _parse_HEXADECIMAL_PREFIX() {
    // LEXEME (TOKEN)
    // HEXADECIMAL_PREFIX <- '0x' / '0X'
    var $$;          
    var pos = _cursor;             
    if(_cachePos[176] >= pos) {
      $$ = _getFromCache(176);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[176] = pos;
    }  
    _token = 6;    
    _tokenStart = _cursor;    
    // => '0x' / '0X' # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => '0x'
          $$ = _matchString(_strings52, '0x');
          // <= '0x'
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => '0X'
          $$ = _matchString(_strings53, '0X');
          // <= '0X'
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: HEXADECIMAL_PREFIX
      _failure(_expect72);
    }
    // <= '0x' / '0X' # Choice
    if (_cacheable[176]) {
      _addToCache($$, pos, 176);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_HEX_QUAD() {
    // SENTENCE (NONTERMINAL)
    // HEX_QUAD <- HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT
    var $$;          
    var pos = _cursor;             
    if(_cachePos[168] >= pos) {
      $$ = _getFromCache(168);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[168] = pos;
    }  
    // => HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT # Choice
    switch (_getState(_transitions58)) {
      // [0-9] [A-F] [a-f]
      case 0:
        // => HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[1] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[2] = $$;
          // => HEXADECIMAL_DIGIT
          $$ = _parse_HEXADECIMAL_DIGIT();
          // <= HEXADECIMAL_DIGIT
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // HEXADECIMAL_DIGIT
            final $1 = seq[0];
            // HEXADECIMAL_DIGIT
            final $2 = seq[1];
            // HEXADECIMAL_DIGIT
            final $3 = seq[2];
            // HEXADECIMAL_DIGIT
            final $4 = seq[3];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: HEXADECIMAL_DIGIT
      _failure(_expect91);
    }
    // <= HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT # Choice
    if (_cacheable[168]) {
      _addToCache($$, pos, 168);
    }    
    return $$;
  }
  
  dynamic _parse_IDENTIFIER_BASE1() {
    // SENTENCE (NONTERMINAL)
    // IDENTIFIER_BASE1 <- IDENTIFIER_NONDIGIT / DIGIT
    var $$;          
    var pos = _cursor;             
    if(_cachePos[149] >= pos) {
      $$ = _getFromCache(149);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[149] = pos;
    }  
    // => IDENTIFIER_NONDIGIT / DIGIT # Choice
    switch (_getState(_transitions48)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => DIGIT
        $$ = _parse_DIGIT();
        // <= DIGIT
        if (success) {    
          // DIGIT
          final $1 = $$;
          final $start = startPos0;
          $$ = _text();
        }
        _startPos = startPos0;
        break;
      // [A-Z] [\\] [_] [a-z]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => IDENTIFIER_NONDIGIT
        $$ = _parse_IDENTIFIER_NONDIGIT();
        // <= IDENTIFIER_NONDIGIT
        if (success) {    
          // IDENTIFIER_NONDIGIT
          final $1 = $$;
          final $start = startPos1;
          $$ = _text();
        }
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u, DIGIT
      _failure(_expect78);
    }
    // <= IDENTIFIER_NONDIGIT / DIGIT # Choice
    if (_cacheable[149]) {
      _addToCache($$, pos, 149);
    }    
    return $$;
  }
  
  dynamic _parse_IDENTIFIER_NONDIGIT() {
    // SENTENCE (NONTERMINAL)
    // IDENTIFIER_NONDIGIT <- NONDIGIT / UNIVERSAL_CHARACTER_NAME
    var $$;          
    var pos = _cursor;             
    if(_cachePos[150] >= pos) {
      $$ = _getFromCache(150);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[150] = pos;
    }  
    // => NONDIGIT / UNIVERSAL_CHARACTER_NAME # Choice
    switch (_getState(_transitions49)) {
      // [A-Z] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => NONDIGIT
        $$ = _parse_NONDIGIT();
        // <= NONDIGIT
        _startPos = startPos0;
        break;
      // [\\]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => UNIVERSAL_CHARACTER_NAME
        $$ = _parse_UNIVERSAL_CHARACTER_NAME();
        // <= UNIVERSAL_CHARACTER_NAME
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= NONDIGIT / UNIVERSAL_CHARACTER_NAME # Choice
    if (_cacheable[150]) {
      _addToCache($$, pos, 150);
    }    
    return $$;
  }
  
  dynamic _parse_INT() {
    // SENTENCE (NONTERMINAL)
    // INT <- 'int' !IDENTIFIER_BASE1 SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[148] >= pos) {
      $$ = _getFromCache(148);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[148] = pos;
    }  
    // => 'int' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 105 ? 0 : _ch == -1 ? 2 : 1) {
      // [i]
      case 0:
        // => 'int' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'int'
          $$ = _matchString(_strings30, 'int');
          // <= 'int'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'int'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'int' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: int
      _failure(_expect77);
    }
    // <= 'int' !IDENTIFIER_BASE1 SPACING # Choice
    if (_cacheable[148]) {
      _addToCache($$, pos, 148);
    }    
    return $$;
  }
  
  dynamic _parse_INTEGER_SUFFIX() {
    // LEXEME (TOKEN)
    // INTEGER_SUFFIX <- UNSIGNED_SUFFIX LONG_LONG_SUFFIX / UNSIGNED_SUFFIX LONG_SUFFIX? / LONG_LONG_SUFFIX UNSIGNED_SUFFIX? / LONG_SUFFIX UNSIGNED_SUFFIX?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[177] >= pos) {
      $$ = _getFromCache(177);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[177] = pos;
    }  
    _token = 7;    
    _tokenStart = _cursor;    
    // => UNSIGNED_SUFFIX LONG_LONG_SUFFIX / UNSIGNED_SUFFIX LONG_SUFFIX? / LONG_LONG_SUFFIX UNSIGNED_SUFFIX? / LONG_SUFFIX UNSIGNED_SUFFIX? # Choice
    switch (_getState(_transitions60)) {
      // [L] [l]
      case 0:
        while (true) {
          // => LONG_LONG_SUFFIX UNSIGNED_SUFFIX? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => LONG_LONG_SUFFIX
            $$ = _parse_LONG_LONG_SUFFIX();
            // <= LONG_LONG_SUFFIX
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => UNSIGNED_SUFFIX?
            var testing0 = _testing;
            _testing = _cursor;
            // => UNSIGNED_SUFFIX
            $$ = _parse_UNSIGNED_SUFFIX();
            // <= UNSIGNED_SUFFIX
            success = true; 
            _testing = testing0;
            // <= UNSIGNED_SUFFIX?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= LONG_LONG_SUFFIX UNSIGNED_SUFFIX? # Sequence
          if (success) break;
          // => LONG_SUFFIX UNSIGNED_SUFFIX? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => LONG_SUFFIX
            $$ = _parse_LONG_SUFFIX();
            // <= LONG_SUFFIX
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => UNSIGNED_SUFFIX?
            var testing1 = _testing;
            _testing = _cursor;
            // => UNSIGNED_SUFFIX
            $$ = _parse_UNSIGNED_SUFFIX();
            // <= UNSIGNED_SUFFIX
            success = true; 
            _testing = testing1;
            // <= UNSIGNED_SUFFIX?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= LONG_SUFFIX UNSIGNED_SUFFIX? # Sequence
          break;
        }
        break;
      // [U] [u]
      case 1:
        while (true) {
          // => UNSIGNED_SUFFIX LONG_LONG_SUFFIX # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => UNSIGNED_SUFFIX
            $$ = _parse_UNSIGNED_SUFFIX();
            // <= UNSIGNED_SUFFIX
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => LONG_LONG_SUFFIX
            $$ = _parse_LONG_LONG_SUFFIX();
            // <= LONG_LONG_SUFFIX
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= UNSIGNED_SUFFIX LONG_LONG_SUFFIX # Sequence
          if (success) break;
          // => UNSIGNED_SUFFIX LONG_SUFFIX? # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => UNSIGNED_SUFFIX
            $$ = _parse_UNSIGNED_SUFFIX();
            // <= UNSIGNED_SUFFIX
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => LONG_SUFFIX?
            var testing2 = _testing;
            _testing = _cursor;
            // => LONG_SUFFIX
            $$ = _parse_LONG_SUFFIX();
            // <= LONG_SUFFIX
            success = true; 
            _testing = testing2;
            // <= LONG_SUFFIX?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos3;
          // <= UNSIGNED_SUFFIX LONG_SUFFIX? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: INTEGER_SUFFIX
      _failure(_expect94);
    }
    // <= UNSIGNED_SUFFIX LONG_LONG_SUFFIX / UNSIGNED_SUFFIX LONG_SUFFIX? / LONG_LONG_SUFFIX UNSIGNED_SUFFIX? / LONG_SUFFIX UNSIGNED_SUFFIX? # Choice
    if (_cacheable[177]) {
      _addToCache($$, pos, 177);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_Identifier() {
    // SENTENCE (NONTERMINAL)
    // Identifier <- !RESERVED_WORD Identifier_base SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[8] >= pos) {
      $$ = _getFromCache(8);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[8] = pos;
    }  
    // => !RESERVED_WORD Identifier_base SPACING # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => !RESERVED_WORD Identifier_base SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !RESERVED_WORD
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => RESERVED_WORD
          $$ = _parse_RESERVED_WORD();
          // <= RESERVED_WORD
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !RESERVED_WORD
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Identifier_base
          $$ = _parse_Identifier_base();
          // <= Identifier_base
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // !RESERVED_WORD
            final $1 = seq[0];
            // Identifier_base
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !RESERVED_WORD Identifier_base SPACING # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= !RESERVED_WORD Identifier_base SPACING # Choice
    if (_cacheable[8]) {
      _addToCache($$, pos, 8);
    }    
    return $$;
  }
  
  dynamic _parse_Identifier_base() {
    // SENTENCE (NONTERMINAL)
    // Identifier_base <- IDENTIFIER_NONDIGIT IDENTIFIER_BASE1*
    var $$;
    // => IDENTIFIER_NONDIGIT IDENTIFIER_BASE1* # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      case 0:
        // => IDENTIFIER_NONDIGIT IDENTIFIER_BASE1* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => IDENTIFIER_NONDIGIT
          $$ = _parse_IDENTIFIER_NONDIGIT();
          // <= IDENTIFIER_NONDIGIT
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => IDENTIFIER_BASE1*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => IDENTIFIER_BASE1
            $$ = _parse_IDENTIFIER_BASE1();
            // <= IDENTIFIER_BASE1
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= IDENTIFIER_BASE1*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // IDENTIFIER_NONDIGIT
            final $1 = seq[0];
            // IDENTIFIER_BASE1*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new Identifier(name: _text());
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= IDENTIFIER_NONDIGIT IDENTIFIER_BASE1* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= IDENTIFIER_NONDIGIT IDENTIFIER_BASE1* # Choice
    return $$;
  }
  
  dynamic _parse_IntegerType() {
    // SENTENCE (NONTERMINAL)
    // IntegerType <- (CharTypeSpecifiers / Integer_Type_Specifiers) Metadata? TypeQualifiers?
    var $$;
    // => (CharTypeSpecifiers / Integer_Type_Specifiers) Metadata? TypeQualifiers? # Choice
    switch (_getState(_transitions24)) {
      // [c] [i] [l] [s] [u]
      case 0:
        // => (CharTypeSpecifiers / Integer_Type_Specifiers) Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (CharTypeSpecifiers / Integer_Type_Specifiers) # Choice
          switch (_getState(_transitions25)) {
            // [c]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => CharTypeSpecifiers
              $$ = _parse_CharTypeSpecifiers();
              // <= CharTypeSpecifiers
              _startPos = startPos1;
              break;
            // [i] [l]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => Integer_Type_Specifiers
              $$ = _parse_Integer_Type_Specifiers();
              // <= Integer_Type_Specifiers
              _startPos = startPos2;
              break;
            // [s] [u]
            case 2:
              while (true) {
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => CharTypeSpecifiers
                $$ = _parse_CharTypeSpecifiers();
                // <= CharTypeSpecifiers
                _startPos = startPos3;
                if (success) break;
                var startPos4 = _startPos;
                _startPos = _cursor;
                // => Integer_Type_Specifiers
                $$ = _parse_Integer_Type_Specifiers();
                // <= Integer_Type_Specifiers
                _startPos = startPos4;
                break;
              }
              break;
            // No matches
            // EOF
            case 3:
            case 4:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: char, short, long, int, signed, unsigned
            _failure(_expect44);
          }
          // <= (CharTypeSpecifiers / Integer_Type_Specifiers) # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // (CharTypeSpecifiers / Integer_Type_Specifiers)
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new BasicTypeSpecification(metadata: $2, qualifiers: $3, specifiers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (CharTypeSpecifiers / Integer_Type_Specifiers) Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned
      _failure(_expect44);
    }
    // <= (CharTypeSpecifiers / Integer_Type_Specifiers) Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_Integer_Type_Specifiers() {
    // SENTENCE (NONTERMINAL)
    // Integer_Type_Specifiers <- SIGNMODIFIER? SIZEMODIFIER INT / SIGNMODIFIER? INT SIZEMODIFIER / SIZEMODIFIER? SIGNMODIFIER INT / SIZEMODIFIER? INT SIGNMODIFIER / INT? SIGNMODIFIER SIZEMODIFIER / INT? SIZEMODIFIER SIGNMODIFIER / SIGNMODIFIER / SIZEMODIFIER / INT
    var $$;
    // => SIGNMODIFIER? SIZEMODIFIER INT / SIGNMODIFIER? INT SIZEMODIFIER / SIZEMODIFIER? SIGNMODIFIER INT / SIZEMODIFIER? INT SIGNMODIFIER / INT? SIGNMODIFIER SIZEMODIFIER / INT? SIZEMODIFIER SIGNMODIFIER / SIGNMODIFIER / SIZEMODIFIER / INT # Choice
    switch (_getState(_transitions40)) {
      // [i]
      case 0:
        while (true) {
          // => SIGNMODIFIER? INT SIZEMODIFIER # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNMODIFIER?
            var testing0 = _testing;
            _testing = _cursor;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            success = true; 
            _testing = testing0;
            // <= SIGNMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[1] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIGNMODIFIER?
              final $1 = seq[0];
              // INT
              final $2 = seq[1];
              // SIZEMODIFIER
              final $3 = seq[2];
              final $start = startPos0;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= SIGNMODIFIER? INT SIZEMODIFIER # Sequence
          if (success) break;
          // => SIZEMODIFIER? INT SIGNMODIFIER # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIZEMODIFIER?
            var testing1 = _testing;
            _testing = _cursor;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            success = true; 
            _testing = testing1;
            // <= SIZEMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[1] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIZEMODIFIER?
              final $1 = seq[0];
              // INT
              final $2 = seq[1];
              // SIGNMODIFIER
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= SIZEMODIFIER? INT SIGNMODIFIER # Sequence
          if (success) break;
          // => INT? SIGNMODIFIER SIZEMODIFIER # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => INT?
            var testing2 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing2;
            // <= INT?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // INT?
              final $1 = seq[0];
              // SIGNMODIFIER
              final $2 = seq[1];
              // SIZEMODIFIER
              final $3 = seq[2];
              final $start = startPos2;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= INT? SIGNMODIFIER SIZEMODIFIER # Sequence
          if (success) break;
          // => INT? SIZEMODIFIER SIGNMODIFIER # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => INT?
            var testing3 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing3;
            // <= INT?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // INT?
              final $1 = seq[0];
              // SIZEMODIFIER
              final $2 = seq[1];
              // SIGNMODIFIER
              final $3 = seq[2];
              final $start = startPos3;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos3;
          // <= INT? SIZEMODIFIER SIGNMODIFIER # Sequence
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => INT
          $$ = _parse_INT();
          // <= INT
          if (success) {    
            // INT
            final $1 = $$;
            final $start = startPos4;
            $$ = new TypeSpecifiers(elements: _flatten([$1]));
          }
          _startPos = startPos4;
          break;
        }
        break;
      // [l]
      case 1:
        while (true) {
          // => SIGNMODIFIER? SIZEMODIFIER INT # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNMODIFIER?
            var testing4 = _testing;
            _testing = _cursor;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            success = true; 
            _testing = testing4;
            // <= SIGNMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIGNMODIFIER?
              final $1 = seq[0];
              // SIZEMODIFIER
              final $2 = seq[1];
              // INT
              final $3 = seq[2];
              final $start = startPos5;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos5;
          // <= SIGNMODIFIER? SIZEMODIFIER INT # Sequence
          if (success) break;
          // => SIZEMODIFIER? SIGNMODIFIER INT # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIZEMODIFIER?
            var testing5 = _testing;
            _testing = _cursor;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            success = true; 
            _testing = testing5;
            // <= SIZEMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIZEMODIFIER?
              final $1 = seq[0];
              // SIGNMODIFIER
              final $2 = seq[1];
              // INT
              final $3 = seq[2];
              final $start = startPos6;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos6;
          // <= SIZEMODIFIER? SIGNMODIFIER INT # Sequence
          if (success) break;
          // => SIZEMODIFIER? INT SIGNMODIFIER # Sequence
          var ch6 = _ch, pos6 = _cursor, startPos7 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIZEMODIFIER?
            var testing6 = _testing;
            _testing = _cursor;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            success = true; 
            _testing = testing6;
            // <= SIZEMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[1] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIZEMODIFIER?
              final $1 = seq[0];
              // INT
              final $2 = seq[1];
              // SIGNMODIFIER
              final $3 = seq[2];
              final $start = startPos7;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos7;
          // <= SIZEMODIFIER? INT SIGNMODIFIER # Sequence
          if (success) break;
          // => INT? SIZEMODIFIER SIGNMODIFIER # Sequence
          var ch7 = _ch, pos7 = _cursor, startPos8 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => INT?
            var testing7 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing7;
            // <= INT?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // INT?
              final $1 = seq[0];
              // SIZEMODIFIER
              final $2 = seq[1];
              // SIGNMODIFIER
              final $3 = seq[2];
              final $start = startPos8;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch7;
            _cursor = pos7;
          }
          _startPos = startPos8;
          // <= INT? SIZEMODIFIER SIGNMODIFIER # Sequence
          if (success) break;
          var startPos9 = _startPos;
          _startPos = _cursor;
          // => SIZEMODIFIER
          $$ = _parse_SIZEMODIFIER();
          // <= SIZEMODIFIER
          if (success) {    
            // SIZEMODIFIER
            final $1 = $$;
            final $start = startPos9;
            $$ = new TypeSpecifiers(elements: _flatten([$1]));
          }
          _startPos = startPos9;
          break;
        }
        break;
      // [s]
      case 2:
        while (true) {
          // => SIGNMODIFIER? SIZEMODIFIER INT # Sequence
          var ch8 = _ch, pos8 = _cursor, startPos10 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNMODIFIER?
            var testing8 = _testing;
            _testing = _cursor;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            success = true; 
            _testing = testing8;
            // <= SIGNMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIGNMODIFIER?
              final $1 = seq[0];
              // SIZEMODIFIER
              final $2 = seq[1];
              // INT
              final $3 = seq[2];
              final $start = startPos10;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch8;
            _cursor = pos8;
          }
          _startPos = startPos10;
          // <= SIGNMODIFIER? SIZEMODIFIER INT # Sequence
          if (success) break;
          // => SIGNMODIFIER? INT SIZEMODIFIER # Sequence
          var ch9 = _ch, pos9 = _cursor, startPos11 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNMODIFIER?
            var testing9 = _testing;
            _testing = _cursor;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            success = true; 
            _testing = testing9;
            // <= SIGNMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[1] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIGNMODIFIER?
              final $1 = seq[0];
              // INT
              final $2 = seq[1];
              // SIZEMODIFIER
              final $3 = seq[2];
              final $start = startPos11;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch9;
            _cursor = pos9;
          }
          _startPos = startPos11;
          // <= SIGNMODIFIER? INT SIZEMODIFIER # Sequence
          if (success) break;
          // => SIZEMODIFIER? SIGNMODIFIER INT # Sequence
          var ch10 = _ch, pos10 = _cursor, startPos12 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIZEMODIFIER?
            var testing10 = _testing;
            _testing = _cursor;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            success = true; 
            _testing = testing10;
            // <= SIZEMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIZEMODIFIER?
              final $1 = seq[0];
              // SIGNMODIFIER
              final $2 = seq[1];
              // INT
              final $3 = seq[2];
              final $start = startPos12;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch10;
            _cursor = pos10;
          }
          _startPos = startPos12;
          // <= SIZEMODIFIER? SIGNMODIFIER INT # Sequence
          if (success) break;
          // => SIZEMODIFIER? INT SIGNMODIFIER # Sequence
          var ch11 = _ch, pos11 = _cursor, startPos13 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIZEMODIFIER?
            var testing11 = _testing;
            _testing = _cursor;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            success = true; 
            _testing = testing11;
            // <= SIZEMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[1] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIZEMODIFIER?
              final $1 = seq[0];
              // INT
              final $2 = seq[1];
              // SIGNMODIFIER
              final $3 = seq[2];
              final $start = startPos13;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch11;
            _cursor = pos11;
          }
          _startPos = startPos13;
          // <= SIZEMODIFIER? INT SIGNMODIFIER # Sequence
          if (success) break;
          // => INT? SIGNMODIFIER SIZEMODIFIER # Sequence
          var ch12 = _ch, pos12 = _cursor, startPos14 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => INT?
            var testing12 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing12;
            // <= INT?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // INT?
              final $1 = seq[0];
              // SIGNMODIFIER
              final $2 = seq[1];
              // SIZEMODIFIER
              final $3 = seq[2];
              final $start = startPos14;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch12;
            _cursor = pos12;
          }
          _startPos = startPos14;
          // <= INT? SIGNMODIFIER SIZEMODIFIER # Sequence
          if (success) break;
          // => INT? SIZEMODIFIER SIGNMODIFIER # Sequence
          var ch13 = _ch, pos13 = _cursor, startPos15 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => INT?
            var testing13 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing13;
            // <= INT?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // INT?
              final $1 = seq[0];
              // SIZEMODIFIER
              final $2 = seq[1];
              // SIGNMODIFIER
              final $3 = seq[2];
              final $start = startPos15;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch13;
            _cursor = pos13;
          }
          _startPos = startPos15;
          // <= INT? SIZEMODIFIER SIGNMODIFIER # Sequence
          if (success) break;
          var startPos16 = _startPos;
          _startPos = _cursor;
          // => SIGNMODIFIER
          $$ = _parse_SIGNMODIFIER();
          // <= SIGNMODIFIER
          if (success) {    
            // SIGNMODIFIER
            final $1 = $$;
            final $start = startPos16;
            $$ = new TypeSpecifiers(elements: _flatten([$1]));
          }
          _startPos = startPos16;
          if (success) break;
          var startPos17 = _startPos;
          _startPos = _cursor;
          // => SIZEMODIFIER
          $$ = _parse_SIZEMODIFIER();
          // <= SIZEMODIFIER
          if (success) {    
            // SIZEMODIFIER
            final $1 = $$;
            final $start = startPos17;
            $$ = new TypeSpecifiers(elements: _flatten([$1]));
          }
          _startPos = startPos17;
          break;
        }
        break;
      // [u]
      case 3:
        while (true) {
          // => SIGNMODIFIER? SIZEMODIFIER INT # Sequence
          var ch14 = _ch, pos14 = _cursor, startPos18 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNMODIFIER?
            var testing14 = _testing;
            _testing = _cursor;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            success = true; 
            _testing = testing14;
            // <= SIGNMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIGNMODIFIER?
              final $1 = seq[0];
              // SIZEMODIFIER
              final $2 = seq[1];
              // INT
              final $3 = seq[2];
              final $start = startPos18;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch14;
            _cursor = pos14;
          }
          _startPos = startPos18;
          // <= SIGNMODIFIER? SIZEMODIFIER INT # Sequence
          if (success) break;
          // => SIGNMODIFIER? INT SIZEMODIFIER # Sequence
          var ch15 = _ch, pos15 = _cursor, startPos19 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIGNMODIFIER?
            var testing15 = _testing;
            _testing = _cursor;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            success = true; 
            _testing = testing15;
            // <= SIGNMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[1] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIGNMODIFIER?
              final $1 = seq[0];
              // INT
              final $2 = seq[1];
              // SIZEMODIFIER
              final $3 = seq[2];
              final $start = startPos19;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch15;
            _cursor = pos15;
          }
          _startPos = startPos19;
          // <= SIGNMODIFIER? INT SIZEMODIFIER # Sequence
          if (success) break;
          // => SIZEMODIFIER? SIGNMODIFIER INT # Sequence
          var ch16 = _ch, pos16 = _cursor, startPos20 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => SIZEMODIFIER?
            var testing16 = _testing;
            _testing = _cursor;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            success = true; 
            _testing = testing16;
            // <= SIZEMODIFIER?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => INT
            $$ = _parse_INT();
            // <= INT
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // SIZEMODIFIER?
              final $1 = seq[0];
              // SIGNMODIFIER
              final $2 = seq[1];
              // INT
              final $3 = seq[2];
              final $start = startPos20;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch16;
            _cursor = pos16;
          }
          _startPos = startPos20;
          // <= SIZEMODIFIER? SIGNMODIFIER INT # Sequence
          if (success) break;
          // => INT? SIGNMODIFIER SIZEMODIFIER # Sequence
          var ch17 = _ch, pos17 = _cursor, startPos21 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => INT?
            var testing17 = _testing;
            _testing = _cursor;
            // => INT
            $$ = _parse_INT();
            // <= INT
            success = true; 
            _testing = testing17;
            // <= INT?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => SIGNMODIFIER
            $$ = _parse_SIGNMODIFIER();
            // <= SIGNMODIFIER
            if (!success) break;
            seq[1] = $$;
            // => SIZEMODIFIER
            $$ = _parse_SIZEMODIFIER();
            // <= SIZEMODIFIER
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // INT?
              final $1 = seq[0];
              // SIGNMODIFIER
              final $2 = seq[1];
              // SIZEMODIFIER
              final $3 = seq[2];
              final $start = startPos21;
              $$ = new TypeSpecifiers(elements: _removeNull(_flatten([$1, $2, $3])));
            }
            break;
          }
          if (!success) {
            _ch = ch17;
            _cursor = pos17;
          }
          _startPos = startPos21;
          // <= INT? SIGNMODIFIER SIZEMODIFIER # Sequence
          if (success) break;
          var startPos22 = _startPos;
          _startPos = _cursor;
          // => SIGNMODIFIER
          $$ = _parse_SIGNMODIFIER();
          // <= SIGNMODIFIER
          if (success) {    
            // SIGNMODIFIER
            final $1 = $$;
            final $start = startPos22;
            $$ = new TypeSpecifiers(elements: _flatten([$1]));
          }
          _startPos = startPos22;
          break;
        }
        break;
      // No matches
      // EOF
      case 4:
      case 5:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: short, long, int, signed, unsigned
      _failure(_expect64);
    }
    // <= SIGNMODIFIER? SIZEMODIFIER INT / SIGNMODIFIER? INT SIZEMODIFIER / SIZEMODIFIER? SIGNMODIFIER INT / SIZEMODIFIER? INT SIGNMODIFIER / INT? SIGNMODIFIER SIZEMODIFIER / INT? SIZEMODIFIER SIGNMODIFIER / SIGNMODIFIER / SIZEMODIFIER / INT # Choice
    return $$;
  }
  
  dynamic _parse_LEADING_SPACES() {
    // SENTENCE (NONTERMINAL)
    // LEADING_SPACES <- SPACING
    var $$;
    // => SPACING # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => SPACING
        $$ = _parse_SPACING();
        // <= SPACING
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SPACING
      _failure(_expect65);
    }
    // <= SPACING # Choice
    return $$;
  }
  
  dynamic _parse_LONG() {
    // SENTENCE (NONTERMINAL)
    // LONG <- 'long' !IDENTIFIER_BASE1 SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[151] >= pos) {
      $$ = _getFromCache(151);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[151] = pos;
    }  
    // => 'long' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 108 ? 0 : _ch == -1 ? 2 : 1) {
      // [l]
      case 0:
        // => 'long' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'long'
          $$ = _matchString(_strings31, 'long');
          // <= 'long'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'long'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'long' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: long
      _failure(_expect79);
    }
    // <= 'long' !IDENTIFIER_BASE1 SPACING # Choice
    if (_cacheable[151]) {
      _addToCache($$, pos, 151);
    }    
    return $$;
  }
  
  dynamic _parse_LONG_LONG_SUFFIX() {
    // MORHEME
    // LONG_LONG_SUFFIX <- 'll' / 'LL'
    var $$;
    // => 'll' / 'LL' # Choice
    switch (_getState(_transitions61)) {
      // [L]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => 'LL'
        $$ = _matchString(_strings54, 'LL');
        // <= 'LL'
        _startPos = startPos0;
        break;
      // [l]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => 'll'
        $$ = _matchString(_strings55, 'll');
        // <= 'll'
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ll, LL
      _failure(_expect95);
    }
    // <= 'll' / 'LL' # Choice
    return $$;
  }
  
  dynamic _parse_LONG_SUFFIX() {
    // MORHEME
    // LONG_SUFFIX <- [Ll]
    var $$;
    // => [Ll] # Choice
    switch (_getState(_transitions62)) {
      // [L] [l]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [Ll]
        $$ = _matchMapping(76, 108, _mapping6);
        // <= [Ll]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [Ll] # Choice
    return $$;
  }
  
  dynamic _parse_Metadata() {
    // SENTENCE (NONTERMINAL)
    // Metadata <- DeclarationSpecifier+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[4] >= pos) {
      $$ = _getFromCache(4);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[4] = pos;
    }  
    // => DeclarationSpecifier+ # Choice
    switch (_ch == 95 ? 0 : _ch == -1 ? 2 : 1) {
      // [_]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => DeclarationSpecifier+
        var testing0;
        for (var first = true, reps; ;) {  
          // => DeclarationSpecifier  
          $$ = _parse_DeclarationSpecifier();  
          // <= DeclarationSpecifier  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= DeclarationSpecifier+
        if (success) {    
          // DeclarationSpecifier+
          final $1 = $$;
          final $start = startPos0;
          $$ = new DeclarationSpecifiers(elements: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: __attribute__
      _failure(_expect4);
    }
    // <= DeclarationSpecifier+ # Choice
    if (_cacheable[4]) {
      _addToCache($$, pos, 4);
    }    
    return $$;
  }
  
  dynamic _parse_NONDIGIT() {
    // LEXEME (TOKEN)
    // NONDIGIT <- [A-Z_a-z]
    var $$;
    _token = 8;  
    _tokenStart = _cursor;  
    // => [A-Z_a-z] # Choice
    switch (_getState(_transitions63)) {
      // [A-Z] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [A-Z_a-z]
        $$ = _matchMapping(65, 122, _mapping7);
        // <= [A-Z_a-z]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT
      _failure(_expect96);
    }
    // <= [A-Z_a-z] # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_NONZERO_DIGIT() {
    // LEXEME (TOKEN)
    // NONZERO_DIGIT <- [1-9]
    var $$;
    _token = 9;  
    _tokenStart = _cursor;  
    // => [1-9] # Choice
    switch (_ch >= 49 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [1-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [1-9]
        $$ = _matchRange(49, 57);
        // <= [1-9]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONZERO_DIGIT
      _failure(_expect86);
    }
    // <= [1-9] # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OCTAL_CONSTANT() {
    // LEXEME (TOKEN)
    // OCTAL_CONSTANT <- '0' OCTAL_CONSTANT1
    var $$;
    _token = 10;  
    _tokenStart = _cursor;  
    // => '0' OCTAL_CONSTANT1 # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => '0' OCTAL_CONSTANT1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '0'
          $$ = '0';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '0'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => OCTAL_CONSTANT1
          $$ = _parse_OCTAL_CONSTANT1();
          // <= OCTAL_CONSTANT1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '0'
            final $1 = seq[0];
            // OCTAL_CONSTANT1
            final $2 = seq[1];
            final $start = startPos0;
            $$ = int.parse(_text(), radix: 8);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '0' OCTAL_CONSTANT1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '0'
      _failure(_expect97);
    }
    // <= '0' OCTAL_CONSTANT1 # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OCTAL_CONSTANT1() {
    // MORHEME
    // OCTAL_CONSTANT1 <- (OCTAL_DIGIT OCTAL_CONSTANT1)?
    var $$;
    // => (OCTAL_DIGIT OCTAL_CONSTANT1)? # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (OCTAL_DIGIT OCTAL_CONSTANT1)?
        var testing0 = _testing;
        _testing = _cursor;
        // => (OCTAL_DIGIT OCTAL_CONSTANT1) # Choice
        switch (_ch >= 48 && _ch <= 55 ? 0 : _ch == -1 ? 2 : 1) {
          // [0-7]
          case 0:
            // => OCTAL_DIGIT OCTAL_CONSTANT1 # Sequence
            var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
            _startPos = _cursor;
            while (true) {  
              // => OCTAL_DIGIT
              $$ = _parse_OCTAL_DIGIT();
              // <= OCTAL_DIGIT
              if (!success) break;
              var seq = new List(2)..[0] = $$;
              // => OCTAL_CONSTANT1
              $$ = _parse_OCTAL_CONSTANT1();
              // <= OCTAL_CONSTANT1
              if (!success) break;
              seq[1] = $$;
              $$ = seq;
              break;
            }
            if (!success) {
              _ch = ch0;
              _cursor = pos0;
            }
            _startPos = startPos1;
            // <= OCTAL_DIGIT OCTAL_CONSTANT1 # Sequence
            break;
          // No matches
          // EOF
          case 1:
          case 2:
            $$ = null;
            success = false;
            break;
        }
        if (!success && _cursor > _testing) {
          // Expected: 
          _failure(const [null]);
        }
        // <= (OCTAL_DIGIT OCTAL_CONSTANT1) # Choice
        success = true; 
        _testing = testing0;
        // <= (OCTAL_DIGIT OCTAL_CONSTANT1)?
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect1);
    }
    // <= (OCTAL_DIGIT OCTAL_CONSTANT1)? # Choice
    return $$;
  }
  
  dynamic _parse_OCTAL_DIGIT() {
    // MORHEME
    // OCTAL_DIGIT <- [0-7]
    var $$;
    // => [0-7] # Choice
    switch (_ch >= 48 && _ch <= 55 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-7]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-7]
        $$ = _matchRange(48, 55);
        // <= [0-7]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [0-7] # Choice
    return $$;
  }
  
  dynamic _parse_OCTAL_ESCAPE_SEQUENCE() {
    // LEXEME (TOKEN)
    // OCTAL_ESCAPE_SEQUENCE <- '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT
    var $$;
    _token = 11;  
    _tokenStart = _cursor;  
    // => '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          // => '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[1] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[2] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // OCTAL_DIGIT
              final $2 = seq[1];
              // OCTAL_DIGIT
              final $3 = seq[2];
              // OCTAL_DIGIT
              final $4 = seq[3];
              final $start = startPos0;
              $$ = int.parse(_text(1), radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT # Sequence
          if (success) break;
          // => '\\' OCTAL_DIGIT OCTAL_DIGIT # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = _matchChar(92, '\\');
            // <= '\\'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[1] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // OCTAL_DIGIT
              final $2 = seq[1];
              // OCTAL_DIGIT
              final $3 = seq[2];
              final $start = startPos1;
              $$ = int.parse(_text(1), radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '\\' OCTAL_DIGIT OCTAL_DIGIT # Sequence
          if (success) break;
          // => '\\' OCTAL_DIGIT # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = _matchChar(92, '\\');
            // <= '\\'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => OCTAL_DIGIT
            $$ = _parse_OCTAL_DIGIT();
            // <= OCTAL_DIGIT
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // OCTAL_DIGIT
              final $2 = seq[1];
              final $start = startPos2;
              $$ = int.parse($2, radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= '\\' OCTAL_DIGIT # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '\'
      _failure(_expect98);
    }
    // <= '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT OCTAL_DIGIT / '\\' OCTAL_DIGIT # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_OPEN_BRACE() {
    // SENTENCE (NONTERMINAL)
    // OPEN_BRACE <- '{' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[126] >= pos) {
      $$ = _getFromCache(126);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[126] = pos;
    }  
    // => '{' SPACING # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => '{' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '{'
          $$ = '{';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '{'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '{'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '{' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: {
      _failure(_expect49);
    }
    // <= '{' SPACING # Choice
    if (_cacheable[126]) {
      _addToCache($$, pos, 126);
    }    
    return $$;
  }
  
  dynamic _parse_OPEN_BRACKET() {
    // SENTENCE (NONTERMINAL)
    // OPEN_BRACKET <- '[' SPACING
    var $$;
    // => '[' SPACING # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => '[' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '['
          $$ = '[';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '['
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '['
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '[' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: [
      _failure(_expect52);
    }
    // <= '[' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_OPEN_PAREN() {
    // SENTENCE (NONTERMINAL)
    // OPEN_PAREN <- '(' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[128] >= pos) {
      $$ = _getFromCache(128);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[128] = pos;
    }  
    // => '(' SPACING # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => '(' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '('
          $$ = '(';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '('
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '('
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '(' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: (
      _failure(_expect18);
    }
    // <= '(' SPACING # Choice
    if (_cacheable[128]) {
      _addToCache($$, pos, 128);
    }    
    return $$;
  }
  
  dynamic _parse_ParameterDeclarationAbstract() {
    // SENTENCE (NONTERMINAL)
    // ParameterDeclarationAbstract <- Metadata? TypeQualifiers? Type DeclaratorAbstract / Metadata? TypeQualifiers? Type
    var $$;          
    var pos = _cursor;             
    if(_cachePos[83] >= pos) {
      $$ = _getFromCache(83);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[83] = pos;
    }  
    // => Metadata? TypeQualifiers? Type DeclaratorAbstract / Metadata? TypeQualifiers? Type # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => Metadata? TypeQualifiers? Type DeclaratorAbstract # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => DeclaratorAbstract
            $$ = _parse_DeclaratorAbstract();
            // <= DeclaratorAbstract
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // DeclaratorAbstract
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2, type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Metadata? TypeQualifiers? Type DeclaratorAbstract # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new ParameterDeclaration(metadata: $1, qualifiers: $2, type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Metadata? TypeQualifiers? Type # Sequence
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? Type DeclaratorAbstract / Metadata? TypeQualifiers? Type # Choice
    if (_cacheable[83]) {
      _addToCache($$, pos, 83);
    }    
    return $$;
  }
  
  dynamic _parse_ParameterDeclarationNotAbstract() {
    // SENTENCE (NONTERMINAL)
    // ParameterDeclarationNotAbstract <- Metadata? TypeQualifiers? Type FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionPointerDeclarator / Metadata? TypeQualifiers? Type DeclaratorNotAbstract
    var $$;          
    var pos = _cursor;             
    if(_cachePos[68] >= pos) {
      $$ = _getFromCache(68);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[68] = pos;
    }  
    // => Metadata? TypeQualifiers? Type FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionPointerDeclarator / Metadata? TypeQualifiers? Type DeclaratorNotAbstract # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => Metadata? TypeQualifiers? Type FunctionDeclarator # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => FunctionDeclarator
            $$ = _parse_FunctionDeclarator();
            // <= FunctionDeclarator
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // FunctionDeclarator
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= Metadata? TypeQualifiers? Type FunctionDeclarator # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type FunctionPointerDeclarator # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => FunctionPointerDeclarator
            $$ = _parse_FunctionPointerDeclarator();
            // <= FunctionPointerDeclarator
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // FunctionPointerDeclarator
              final $4 = seq[3];
              final $start = startPos1;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= Metadata? TypeQualifiers? Type FunctionPointerDeclarator # Sequence
          if (success) break;
          // => Metadata? TypeQualifiers? Type DeclaratorNotAbstract # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => Metadata?
            var testing4 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing4;
            // <= Metadata?
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => TypeQualifiers?
            var testing5 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing5;
            // <= TypeQualifiers?
            if (!success) break;
            seq[1] = $$;
            // => Type
            $$ = _parse_Type();
            // <= Type
            if (!success) break;
            seq[2] = $$;
            // => DeclaratorNotAbstract
            $$ = _parse_DeclaratorNotAbstract();
            // <= DeclaratorNotAbstract
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // Metadata?
              final $1 = seq[0];
              // TypeQualifiers?
              final $2 = seq[1];
              // Type
              final $3 = seq[2];
              // DeclaratorNotAbstract
              final $4 = seq[3];
              final $start = startPos2;
              $$ = new ParameterDeclaration(declarator: $4, metadata: $1, qualifiers: $2,  type: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= Metadata? TypeQualifiers? Type DeclaratorNotAbstract # Sequence
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? Type FunctionDeclarator / Metadata? TypeQualifiers? Type FunctionPointerDeclarator / Metadata? TypeQualifiers? Type DeclaratorNotAbstract # Choice
    if (_cacheable[68]) {
      _addToCache($$, pos, 68);
    }    
    return $$;
  }
  
  dynamic _parse_PointerSpecifier() {
    // SENTENCE (NONTERMINAL)
    // PointerSpecifier <- ASTERISK Metadata? TypeQualifiers?
    var $$;
    // => ASTERISK Metadata? TypeQualifiers? # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => ASTERISK Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ASTERISK
          $$ = _parse_ASTERISK();
          // <= ASTERISK
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ASTERISK
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new PointerSpecifier(metadata: $2, qualifiers: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ASTERISK Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: *
      _failure(_expect25);
    }
    // <= ASTERISK Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_PointerSpecifiers() {
    // SENTENCE (NONTERMINAL)
    // PointerSpecifiers <- PointerSpecifier+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[63] >= pos) {
      $$ = _getFromCache(63);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[63] = pos;
    }  
    // => PointerSpecifier+ # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => PointerSpecifier+
        var testing0;
        for (var first = true, reps; ;) {  
          // => PointerSpecifier  
          $$ = _parse_PointerSpecifier();  
          // <= PointerSpecifier  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= PointerSpecifier+
        if (success) {    
          // PointerSpecifier+
          final $1 = $$;
          final $start = startPos0;
          $$ = new PointerSpecifiers(elements: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: *
      _failure(_expect25);
    }
    // <= PointerSpecifier+ # Choice
    if (_cacheable[63]) {
      _addToCache($$, pos, 63);
    }    
    return $$;
  }
  
  dynamic _parse_RESERVED_WORD() {
    // SENTENCE (NONTERMINAL)
    // RESERVED_WORD <- ('__attribute__' / 'auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !IDENTIFIER_BASE1
    var $$;
    // => ('__attribute__' / 'auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !IDENTIFIER_BASE1 # Choice
    switch (_getState(_transitions41)) {
      // [_] [a-g] [i] [l] [r-w]
      case 0:
        // => ('__attribute__' / 'auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !IDENTIFIER_BASE1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ('__attribute__' / 'auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') # Choice
          switch (_getState(_transitions42)) {
            // [_]
            case 0:
              while (true) {
                var startPos1 = _startPos;
                _startPos = _cursor;
                // => '__attribute__'
                $$ = _matchString(_strings8, '__attribute__');
                // <= '__attribute__'
                _startPos = startPos1;
                if (success) break;
                var startPos2 = _startPos;
                _startPos = _cursor;
                // => '_Bool'
                $$ = _matchString(_strings9, '_Bool');
                // <= '_Bool'
                _startPos = startPos2;
                if (success) break;
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => '_Complex'
                $$ = _matchString(_strings13, '_Complex');
                // <= '_Complex'
                _startPos = startPos3;
                if (success) break;
                var startPos4 = _startPos;
                _startPos = _cursor;
                // => '_Imaginary'
                $$ = _matchString(_strings14, '_Imaginary');
                // <= '_Imaginary'
                _startPos = startPos4;
                break;
              }
              break;
            // [a]
            case 1:
              var startPos5 = _startPos;
              _startPos = _cursor;
              // => 'auto'
              $$ = _matchString(_strings15, 'auto');
              // <= 'auto'
              _startPos = startPos5;
              break;
            // [b]
            case 2:
              var startPos6 = _startPos;
              _startPos = _cursor;
              // => 'break'
              $$ = _matchString(_strings16, 'break');
              // <= 'break'
              _startPos = startPos6;
              break;
            // [c]
            case 3:
              while (true) {
                var startPos7 = _startPos;
                _startPos = _cursor;
                // => 'case'
                $$ = _matchString(_strings17, 'case');
                // <= 'case'
                _startPos = startPos7;
                if (success) break;
                var startPos8 = _startPos;
                _startPos = _cursor;
                // => 'char'
                $$ = _matchString(_strings18, 'char');
                // <= 'char'
                _startPos = startPos8;
                if (success) break;
                var startPos9 = _startPos;
                _startPos = _cursor;
                // => 'const'
                $$ = _matchString(_strings10, 'const');
                // <= 'const'
                _startPos = startPos9;
                if (success) break;
                var startPos10 = _startPos;
                _startPos = _cursor;
                // => 'continue'
                $$ = _matchString(_strings19, 'continue');
                // <= 'continue'
                _startPos = startPos10;
                break;
              }
              break;
            // [d]
            case 4:
              while (true) {
                var startPos11 = _startPos;
                _startPos = _cursor;
                // => 'default'
                $$ = _matchString(_strings20, 'default');
                // <= 'default'
                _startPos = startPos11;
                if (success) break;
                var startPos12 = _startPos;
                _startPos = _cursor;
                // => 'do'
                $$ = _matchString(_strings21, 'do');
                // <= 'do'
                _startPos = startPos12;
                if (success) break;
                var startPos13 = _startPos;
                _startPos = _cursor;
                // => 'double'
                $$ = _matchString(_strings22, 'double');
                // <= 'double'
                _startPos = startPos13;
                break;
              }
              break;
            // [e]
            case 5:
              while (true) {
                var startPos14 = _startPos;
                _startPos = _cursor;
                // => 'else'
                $$ = _matchString(_strings23, 'else');
                // <= 'else'
                _startPos = startPos14;
                if (success) break;
                var startPos15 = _startPos;
                _startPos = _cursor;
                // => 'enum'
                $$ = _matchString(_strings12, 'enum');
                // <= 'enum'
                _startPos = startPos15;
                if (success) break;
                var startPos16 = _startPos;
                _startPos = _cursor;
                // => 'extern'
                $$ = _matchString(_strings24, 'extern');
                // <= 'extern'
                _startPos = startPos16;
                break;
              }
              break;
            // [f]
            case 6:
              while (true) {
                var startPos17 = _startPos;
                _startPos = _cursor;
                // => 'float'
                $$ = _matchString(_strings25, 'float');
                // <= 'float'
                _startPos = startPos17;
                if (success) break;
                var startPos18 = _startPos;
                _startPos = _cursor;
                // => 'for'
                $$ = _matchString(_strings26, 'for');
                // <= 'for'
                _startPos = startPos18;
                break;
              }
              break;
            // [g]
            case 7:
              var startPos19 = _startPos;
              _startPos = _cursor;
              // => 'goto'
              $$ = _matchString(_strings27, 'goto');
              // <= 'goto'
              _startPos = startPos19;
              break;
            // [i]
            case 8:
              while (true) {
                var startPos20 = _startPos;
                _startPos = _cursor;
                // => 'if'
                $$ = _matchString(_strings28, 'if');
                // <= 'if'
                _startPos = startPos20;
                if (success) break;
                var startPos21 = _startPos;
                _startPos = _cursor;
                // => 'inline'
                $$ = _matchString(_strings29, 'inline');
                // <= 'inline'
                _startPos = startPos21;
                if (success) break;
                var startPos22 = _startPos;
                _startPos = _cursor;
                // => 'int'
                $$ = _matchString(_strings30, 'int');
                // <= 'int'
                _startPos = startPos22;
                break;
              }
              break;
            // [l]
            case 9:
              var startPos23 = _startPos;
              _startPos = _cursor;
              // => 'long'
              $$ = _matchString(_strings31, 'long');
              // <= 'long'
              _startPos = startPos23;
              break;
            // [r]
            case 10:
              while (true) {
                var startPos24 = _startPos;
                _startPos = _cursor;
                // => 'register'
                $$ = _matchString(_strings32, 'register');
                // <= 'register'
                _startPos = startPos24;
                if (success) break;
                var startPos25 = _startPos;
                _startPos = _cursor;
                // => 'restrict'
                $$ = _matchString(_strings33, 'restrict');
                // <= 'restrict'
                _startPos = startPos25;
                if (success) break;
                var startPos26 = _startPos;
                _startPos = _cursor;
                // => 'return'
                $$ = _matchString(_strings34, 'return');
                // <= 'return'
                _startPos = startPos26;
                break;
              }
              break;
            // [s]
            case 11:
              while (true) {
                var startPos27 = _startPos;
                _startPos = _cursor;
                // => 'short'
                $$ = _matchString(_strings35, 'short');
                // <= 'short'
                _startPos = startPos27;
                if (success) break;
                var startPos28 = _startPos;
                _startPos = _cursor;
                // => 'signed'
                $$ = _matchString(_strings36, 'signed');
                // <= 'signed'
                _startPos = startPos28;
                if (success) break;
                var startPos29 = _startPos;
                _startPos = _cursor;
                // => 'sizeof'
                $$ = _matchString(_strings37, 'sizeof');
                // <= 'sizeof'
                _startPos = startPos29;
                if (success) break;
                var startPos30 = _startPos;
                _startPos = _cursor;
                // => 'static'
                $$ = _matchString(_strings38, 'static');
                // <= 'static'
                _startPos = startPos30;
                if (success) break;
                var startPos31 = _startPos;
                _startPos = _cursor;
                // => 'struct'
                $$ = _matchString(_strings39, 'struct');
                // <= 'struct'
                _startPos = startPos31;
                if (success) break;
                var startPos32 = _startPos;
                _startPos = _cursor;
                // => 'switch'
                $$ = _matchString(_strings40, 'switch');
                // <= 'switch'
                _startPos = startPos32;
                break;
              }
              break;
            // [t]
            case 12:
              var startPos33 = _startPos;
              _startPos = _cursor;
              // => 'typedef'
              $$ = _matchString(_strings41, 'typedef');
              // <= 'typedef'
              _startPos = startPos33;
              break;
            // [u]
            case 13:
              while (true) {
                var startPos34 = _startPos;
                _startPos = _cursor;
                // => 'union'
                $$ = _matchString(_strings42, 'union');
                // <= 'union'
                _startPos = startPos34;
                if (success) break;
                var startPos35 = _startPos;
                _startPos = _cursor;
                // => 'unsigned'
                $$ = _matchString(_strings43, 'unsigned');
                // <= 'unsigned'
                _startPos = startPos35;
                break;
              }
              break;
            // [v]
            case 14:
              while (true) {
                var startPos36 = _startPos;
                _startPos = _cursor;
                // => 'void'
                $$ = _matchString(_strings44, 'void');
                // <= 'void'
                _startPos = startPos36;
                if (success) break;
                var startPos37 = _startPos;
                _startPos = _cursor;
                // => 'volatile'
                $$ = _matchString(_strings45, 'volatile');
                // <= 'volatile'
                _startPos = startPos37;
                break;
              }
              break;
            // [w]
            case 15:
              var startPos38 = _startPos;
              _startPos = _cursor;
              // => 'while'
              $$ = _matchString(_strings46, 'while');
              // <= 'while'
              _startPos = startPos38;
              break;
            // No matches
            // EOF
            case 16:
            case 17:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: __attribute__, auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while, _Bool, _Complex, _Imaginary
            _failure(_expect66);
          }
          // <= ('__attribute__' / 'auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') # Choice
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('__attribute__' / 'auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !IDENTIFIER_BASE1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: __attribute__, auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while, _Bool, _Complex, _Imaginary
      _failure(_expect66);
    }
    // <= ('__attribute__' / 'auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'do' / 'double' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'inline' / 'int' / 'long' / 'register' / 'restrict' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while' / '_Bool' / '_Complex' / '_Imaginary') !IDENTIFIER_BASE1 # Choice
    return $$;
  }
  
  dynamic _parse_SEMICOLON() {
    // SENTENCE (NONTERMINAL)
    // SEMICOLON <- ';' SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[130] >= pos) {
      $$ = _getFromCache(130);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[130] = pos;
    }  
    // => ';' SPACING # Choice
    switch (_ch == 59 ? 0 : _ch == -1 ? 2 : 1) {
      // [;]
      case 0:
        // => ';' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ';'
          $$ = ';';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ';'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ';'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ';' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ;
      _failure(_expect67);
    }
    // <= ';' SPACING # Choice
    if (_cacheable[130]) {
      _addToCache($$, pos, 130);
    }    
    return $$;
  }
  
  dynamic _parse_SHORT() {
    // SENTENCE (NONTERMINAL)
    // SHORT <- 'short' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'short' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'short' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'short'
          $$ = _matchString(_strings35, 'short');
          // <= 'short'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'short'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'short' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: short
      _failure(_expect80);
    }
    // <= 'short' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_SIGN() {
    // LEXEME (TOKEN)
    // SIGN <- [+\-]
    var $$;          
    var pos = _cursor;             
    if(_cachePos[188] >= pos) {
      $$ = _getFromCache(188);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[188] = pos;
    }  
    _token = 12;    
    _tokenStart = _cursor;    
    // => [+\-] # Choice
    switch (_getState(_transitions8)) {
      // [+] [-]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [+\-]
        $$ = _matchMapping(43, 45, _mapping9);
        // <= [+\-]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SIGN
      _failure(_expect99);
    }
    // <= [+\-] # Choice
    if (_cacheable[188]) {
      _addToCache($$, pos, 188);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SIGNED() {
    // SENTENCE (NONTERMINAL)
    // SIGNED <- 'signed' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'signed' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'signed' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'signed'
          $$ = _matchString(_strings36, 'signed');
          // <= 'signed'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'signed'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'signed' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: signed
      _failure(_expect81);
    }
    // <= 'signed' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_SIGNMODIFIER() {
    // SENTENCE (NONTERMINAL)
    // SIGNMODIFIER <- SIGNED / UNSIGNED
    var $$;          
    var pos = _cursor;             
    if(_cachePos[156] >= pos) {
      $$ = _getFromCache(156);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[156] = pos;
    }  
    // => SIGNED / UNSIGNED # Choice
    switch (_getState(_transitions28)) {
      // [s]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => SIGNED
        $$ = _parse_SIGNED();
        // <= SIGNED
        _startPos = startPos0;
        break;
      // [u]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => UNSIGNED
        $$ = _parse_UNSIGNED();
        // <= UNSIGNED
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: signed, unsigned
      _failure(_expect82);
    }
    // <= SIGNED / UNSIGNED # Choice
    if (_cacheable[156]) {
      _addToCache($$, pos, 156);
    }    
    return $$;
  }
  
  dynamic _parse_SIMPLE_ESCAPE_SEQUENCE() {
    // LEXEME (TOKEN)
    // SIMPLE_ESCAPE_SEQUENCE <- [\\] ["'?\\a-bfnrtv]
    var $$;
    _token = 13;  
    _tokenStart = _cursor;  
    // => [\\] ["'?\\a-bfnrtv] # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        // => [\\] ["'?\\a-bfnrtv] # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => [\\]
          $$ = '\\';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= [\\]
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ["'?\\a-bfnrtv]
          $$ = _matchMapping(34, 118, _mapping10);
          // <= ["'?\\a-bfnrtv]
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // [\\]
            final $1 = seq[0];
            // ["'?\\a-bfnrtv]
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _escape($1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= [\\] ["'?\\a-bfnrtv] # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SIMPLE_ESCAPE_SEQUENCE
      _failure(_expect100);
    }
    // <= [\\] ["'?\\a-bfnrtv] # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SIZEMODIFIER() {
    // SENTENCE (NONTERMINAL)
    // SIZEMODIFIER <- SHORT / LONG LONG / LONG
    var $$;          
    var pos = _cursor;             
    if(_cachePos[157] >= pos) {
      $$ = _getFromCache(157);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[157] = pos;
    }  
    // => SHORT / LONG LONG / LONG # Choice
    switch (_getState(_transitions52)) {
      // [l]
      case 0:
        while (true) {
          // => LONG LONG # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => LONG
            $$ = _parse_LONG();
            // <= LONG
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => LONG
            $$ = _parse_LONG();
            // <= LONG
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= LONG LONG # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => LONG
          $$ = _parse_LONG();
          // <= LONG
          _startPos = startPos1;
          break;
        }
        break;
      // [s]
      case 1:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => SHORT
        $$ = _parse_SHORT();
        // <= SHORT
        _startPos = startPos2;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: short, long
      _failure(_expect83);
    }
    // <= SHORT / LONG LONG / LONG # Choice
    if (_cacheable[157]) {
      _addToCache($$, pos, 157);
    }    
    return $$;
  }
  
  dynamic _parse_SIZEOF() {
    // SENTENCE (NONTERMINAL)
    // SIZEOF <- 'sizeof' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'sizeof' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'sizeof' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'sizeof'
          $$ = _matchString(_strings37, 'sizeof');
          // <= 'sizeof'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'sizeof'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'sizeof' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof
      _failure(_expect14);
    }
    // <= 'sizeof' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_SPACE() {
    // MORHEME
    // SPACE <- [\t-\n\r ]
    var $$;
    // => [\t-\n\r ] # Choice
    switch (_getState(_transitions50)) {
      // [\t-\n] [\r] [ ]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\t-\n\r ]
        $$ = _matchMapping(9, 32, _mapping2);
        // <= [\t-\n\r ]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [\t-\n\r ] # Choice
    return $$;
  }
  
  dynamic _parse_SPACING() {
    // LEXEME (TOKEN)
    // SPACING <- (SPACE / COMMENT)*
    var $$;
    _token = 2;  
    _tokenStart = _cursor;  
    // => (SPACE / COMMENT)* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (SPACE / COMMENT)*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => (SPACE / COMMENT) # Choice
          switch (_getState(_transitions51)) {
            // [\t-\n] [\r] [ ]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => SPACE
              $$ = _parse_SPACE();
              // <= SPACE
              _startPos = startPos1;
              break;
            // [/]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => COMMENT
              $$ = _parse_COMMENT();
              // <= COMMENT
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (SPACE / COMMENT) # Choice
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= (SPACE / COMMENT)*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SPACING
      _failure(_expect65);
    }
    // <= (SPACE / COMMENT)* # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_STRUCT() {
    // SENTENCE (NONTERMINAL)
    // STRUCT <- 'struct' !IDENTIFIER_BASE1 SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[132] >= pos) {
      $$ = _getFromCache(132);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[132] = pos;
    }  
    // => 'struct' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => 'struct' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'struct'
          $$ = _matchString(_strings39, 'struct');
          // <= 'struct'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'struct'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'struct' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: struct
      _failure(_expect68);
    }
    // <= 'struct' !IDENTIFIER_BASE1 SPACING # Choice
    if (_cacheable[132]) {
      _addToCache($$, pos, 132);
    }    
    return $$;
  }
  
  dynamic _parse_S_CHAR() {
    // SENTENCE (NONTERMINAL)
    // S_CHAR <- ![\n\r"\\] . / ESCAPE_SEQUENCE
    var $$;
    // => ![\n\r"\\] . / ESCAPE_SEQUENCE # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        while (true) {
          // => ![\n\r"\\] . # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ![\n\r"\\]
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            // => [\n\r"\\]
            $$ = _matchMapping(10, 92, _mapping8);
            // <= [\n\r"\\]
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            // <= ![\n\r"\\]
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => .
            $$ = _matchAny();
            // <= .
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ![\n\r"\\]
              final $1 = seq[0];
              // .
              final $2 = seq[1];
              final $start = startPos0;
              $$ = $2.codeUnitAt(0);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= ![\n\r"\\] . # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => ESCAPE_SEQUENCE
          $$ = _parse_ESCAPE_SEQUENCE();
          // <= ESCAPE_SEQUENCE
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
      // EOF
      case 2:
        // => ![\n\r"\\] . # Sequence
        var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ![\n\r"\\]
          var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          // => [\n\r"\\]
          $$ = _matchMapping(10, 92, _mapping8);
          // <= [\n\r"\\]
          _ch = ch3;
          _cursor = pos3; 
          _testing = testing1;
          $$ = null;
          success = !success;
          // <= ![\n\r"\\]
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => .
          $$ = _matchAny();
          // <= .
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ![\n\r"\\]
            final $1 = seq[0];
            // .
            final $2 = seq[1];
            final $start = startPos2;
            $$ = $2.codeUnitAt(0);
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos2;
        // <= ![\n\r"\\] . # Sequence
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= ![\n\r"\\] . / ESCAPE_SEQUENCE # Choice
    return $$;
  }
  
  dynamic _parse_S_CHAR_SEQUENCE() {
    // SENTENCE (NONTERMINAL)
    // S_CHAR_SEQUENCE <- S_CHAR+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[187] >= pos) {
      $$ = _getFromCache(187);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[187] = pos;
    }  
    // => S_CHAR+ # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => S_CHAR+
        var testing0;
        for (var first = true, reps; ;) {  
          // => S_CHAR  
          $$ = _parse_S_CHAR();  
          // <= S_CHAR  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= S_CHAR+
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= S_CHAR+ # Choice
    if (_cacheable[187]) {
      _addToCache($$, pos, 187);
    }    
    return $$;
  }
  
  dynamic _parse_StructureDeclaration() {
    // SENTENCE (NONTERMINAL)
    // StructureDeclaration <- Metadata? TypeQualifiers? StructureType
    var $$;
    // => Metadata? TypeQualifiers? StructureType # Choice
    switch (_getState(_transitions32)) {
      // [_] [c] [s] [u-v]
      case 0:
        // => Metadata? TypeQualifiers? StructureType # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => StructureType
          $$ = _parse_StructureType();
          // <= StructureType
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // StructureType
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new StructureDeclaration(metadata: $1, qualifiers: $2, type: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? StructureType # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: struct, union
      _failure(_expect48);
    }
    // <= Metadata? TypeQualifiers? StructureType # Choice
    return $$;
  }
  
  dynamic _parse_StructureMember() {
    // SENTENCE (NONTERMINAL)
    // StructureMember <- BitFieldParameterDeclaration SEMICOLON / ParameterDeclarationNotAbstract SEMICOLON / ParameterDeclarationAbstract SEMICOLON
    var $$;
    // => BitFieldParameterDeclaration SEMICOLON / ParameterDeclarationNotAbstract SEMICOLON / ParameterDeclarationAbstract SEMICOLON # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => BitFieldParameterDeclaration SEMICOLON # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => BitFieldParameterDeclaration
            $$ = _parse_BitFieldParameterDeclaration();
            // <= BitFieldParameterDeclaration
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // BitFieldParameterDeclaration
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos0;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= BitFieldParameterDeclaration SEMICOLON # Sequence
          if (success) break;
          // => ParameterDeclarationNotAbstract SEMICOLON # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ParameterDeclarationNotAbstract
            $$ = _parse_ParameterDeclarationNotAbstract();
            // <= ParameterDeclarationNotAbstract
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ParameterDeclarationNotAbstract
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos1;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= ParameterDeclarationNotAbstract SEMICOLON # Sequence
          if (success) break;
          // => ParameterDeclarationAbstract SEMICOLON # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ParameterDeclarationAbstract
            $$ = _parse_ParameterDeclarationAbstract();
            // <= ParameterDeclarationAbstract
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ParameterDeclarationAbstract
              final $1 = seq[0];
              // SEMICOLON
              final $2 = seq[1];
              final $start = startPos2;
              $$ = $1;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= ParameterDeclarationAbstract SEMICOLON # Sequence
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= BitFieldParameterDeclaration SEMICOLON / ParameterDeclarationNotAbstract SEMICOLON / ParameterDeclarationAbstract SEMICOLON # Choice
    return $$;
  }
  
  dynamic _parse_StructureMemberList() {
    // SENTENCE (NONTERMINAL)
    // StructureMemberList <- OPEN_BRACE StructureMember+ CLOSE_BRACE
    var $$;
    // => OPEN_BRACE StructureMember+ CLOSE_BRACE # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => OPEN_BRACE StructureMember+ CLOSE_BRACE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => OPEN_BRACE
          $$ = _parse_OPEN_BRACE();
          // <= OPEN_BRACE
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => StructureMember+
          var testing0;
          for (var first = true, reps; ;) {  
            // => StructureMember  
            $$ = _parse_StructureMember();  
            // <= StructureMember  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= StructureMember+
          if (!success) break;
          seq[1] = $$;
          // => CLOSE_BRACE
          $$ = _parse_CLOSE_BRACE();
          // <= CLOSE_BRACE
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // OPEN_BRACE
            final $1 = seq[0];
            // StructureMember+
            final $2 = seq[1];
            // CLOSE_BRACE
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new MemberDeclarations(elements: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= OPEN_BRACE StructureMember+ CLOSE_BRACE # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: {
      _failure(_expect49);
    }
    // <= OPEN_BRACE StructureMember+ CLOSE_BRACE # Choice
    return $$;
  }
  
  dynamic _parse_StructureType() {
    // SENTENCE (NONTERMINAL)
    // StructureType <- StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? / StructureTypeSpecifierWithTag Metadata? TypeQualifiers?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[75] >= pos) {
      $$ = _getFromCache(75);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[75] = pos;
    }  
    // => StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? / StructureTypeSpecifierWithTag Metadata? TypeQualifiers? # Choice
    switch (_getState(_transitions27)) {
      // [s] [u]
      case 0:
        while (true) {
          // => StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => StructureTypeSpecifier
            $$ = _parse_StructureTypeSpecifier();
            // <= StructureTypeSpecifier
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => StructureMemberList
            $$ = _parse_StructureMemberList();
            // <= StructureMemberList
            if (!success) break;
            seq[1] = $$;
            // => Metadata?
            var testing0 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing0;
            // <= Metadata?
            if (!success) break;
            seq[2] = $$;
            // => TypeQualifiers?
            var testing1 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing1;
            // <= TypeQualifiers?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // StructureTypeSpecifier
              final $1 = seq[0];
              // StructureMemberList
              final $2 = seq[1];
              // Metadata?
              final $3 = seq[2];
              // TypeQualifiers?
              final $4 = seq[3];
              final $start = startPos0;
              $$ = new StructureTypeSpecification(metadata: $3, elaboratedType: $1, members: $2, qualifiers: $4);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? # Sequence
          if (success) break;
          // => StructureTypeSpecifierWithTag Metadata? TypeQualifiers? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => StructureTypeSpecifierWithTag
            $$ = _parse_StructureTypeSpecifierWithTag();
            // <= StructureTypeSpecifierWithTag
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => Metadata?
            var testing2 = _testing;
            _testing = _cursor;
            // => Metadata
            $$ = _parse_Metadata();
            // <= Metadata
            success = true; 
            _testing = testing2;
            // <= Metadata?
            if (!success) break;
            seq[1] = $$;
            // => TypeQualifiers?
            var testing3 = _testing;
            _testing = _cursor;
            // => TypeQualifiers
            $$ = _parse_TypeQualifiers();
            // <= TypeQualifiers
            success = true; 
            _testing = testing3;
            // <= TypeQualifiers?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // StructureTypeSpecifierWithTag
              final $1 = seq[0];
              // Metadata?
              final $2 = seq[1];
              // TypeQualifiers?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = new StructureTypeSpecification(metadata: $2, elaboratedType: $1, qualifiers: $3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= StructureTypeSpecifierWithTag Metadata? TypeQualifiers? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: struct, union
      _failure(_expect48);
    }
    // <= StructureTypeSpecifier StructureMemberList Metadata? TypeQualifiers? / StructureTypeSpecifierWithTag Metadata? TypeQualifiers? # Choice
    if (_cacheable[75]) {
      _addToCache($$, pos, 75);
    }    
    return $$;
  }
  
  dynamic _parse_StructureTypeSpecifier() {
    // SENTENCE (NONTERMINAL)
    // StructureTypeSpecifier <- (STRUCT / UNION) Metadata? Identifier?
    var $$;
    // => (STRUCT / UNION) Metadata? Identifier? # Choice
    switch (_getState(_transitions27)) {
      // [s] [u]
      case 0:
        // => (STRUCT / UNION) Metadata? Identifier? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (STRUCT / UNION) # Choice
          switch (_getState(_transitions28)) {
            // [s]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => STRUCT
              $$ = _parse_STRUCT();
              // <= STRUCT
              _startPos = startPos1;
              break;
            // [u]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => UNION
              $$ = _parse_UNION();
              // <= UNION
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: struct, union
            _failure(_expect48);
          }
          // <= (STRUCT / UNION) # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => Identifier?
          var testing1 = _testing;
          _testing = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          success = true; 
          _testing = testing1;
          // <= Identifier?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // (STRUCT / UNION)
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // Identifier?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (STRUCT / UNION) Metadata? Identifier? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: struct, union
      _failure(_expect48);
    }
    // <= (STRUCT / UNION) Metadata? Identifier? # Choice
    return $$;
  }
  
  dynamic _parse_StructureTypeSpecifierWithTag() {
    // SENTENCE (NONTERMINAL)
    // StructureTypeSpecifierWithTag <- (STRUCT / UNION) Metadata? Identifier
    var $$;
    // => (STRUCT / UNION) Metadata? Identifier # Choice
    switch (_getState(_transitions27)) {
      // [s] [u]
      case 0:
        // => (STRUCT / UNION) Metadata? Identifier # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (STRUCT / UNION) # Choice
          switch (_getState(_transitions28)) {
            // [s]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => STRUCT
              $$ = _parse_STRUCT();
              // <= STRUCT
              _startPos = startPos1;
              break;
            // [u]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => UNION
              $$ = _parse_UNION();
              // <= UNION
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: struct, union
            _failure(_expect48);
          }
          // <= (STRUCT / UNION) # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // (STRUCT / UNION)
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // Identifier
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ElaboratedTypeSpecifier(kind: $1, metadata: $2, tag: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (STRUCT / UNION) Metadata? Identifier # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: struct, union
      _failure(_expect48);
    }
    // <= (STRUCT / UNION) Metadata? Identifier # Choice
    return $$;
  }
  
  dynamic _parse_TYPEDEF() {
    // SENTENCE (NONTERMINAL)
    // TYPEDEF <- 'typedef' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'typedef' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => 'typedef' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'typedef'
          $$ = _matchString(_strings41, 'typedef');
          // <= 'typedef'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'typedef'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'typedef' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: typedef
      _failure(_expect54);
    }
    // <= 'typedef' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_Type() {
    // SENTENCE (NONTERMINAL)
    // Type <- DefinedType / IntegerType / FloatType / VoidType / BoolType / StructureType / EnumType
    var $$;          
    var pos = _cursor;             
    if(_cachePos[69] >= pos) {
      $$ = _getFromCache(69);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[69] = pos;
    }  
    // => DefinedType / IntegerType / FloatType / VoidType / BoolType / StructureType / EnumType # Choice
    switch (_getState(_transitions23)) {
      // [A-Z] [\\]
      // EOF
      case 0:
      case 4:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => DefinedType
        $$ = _parse_DefinedType();
        // <= DefinedType
        _startPos = startPos0;
        break;
      // [_]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => DefinedType
          $$ = _parse_DefinedType();
          // <= DefinedType
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => BoolType
          $$ = _parse_BoolType();
          // <= BoolType
          _startPos = startPos2;
          break;
        }
        break;
      // [a-z]
      case 2:
        while (true) {
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => DefinedType
          $$ = _parse_DefinedType();
          // <= DefinedType
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => IntegerType
          $$ = _parse_IntegerType();
          // <= IntegerType
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          // => FloatType
          $$ = _parse_FloatType();
          // <= FloatType
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          _startPos = _cursor;
          // => VoidType
          $$ = _parse_VoidType();
          // <= VoidType
          _startPos = startPos6;
          if (success) break;
          var startPos7 = _startPos;
          _startPos = _cursor;
          // => StructureType
          $$ = _parse_StructureType();
          // <= StructureType
          _startPos = startPos7;
          if (success) break;
          var startPos8 = _startPos;
          _startPos = _cursor;
          // => EnumType
          $$ = _parse_EnumType();
          // <= EnumType
          _startPos = startPos8;
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= DefinedType / IntegerType / FloatType / VoidType / BoolType / StructureType / EnumType # Choice
    if (_cacheable[69]) {
      _addToCache($$, pos, 69);
    }    
    return $$;
  }
  
  dynamic _parse_TypeDeclarator() {
    // SENTENCE (NONTERMINAL)
    // TypeDeclarator <- FunctionDeclarator / FunctionPointerDeclarator / DeclaratorNotAbstract / TypedefFunctionDeclarator
    var $$;          
    var pos = _cursor;             
    if(_cachePos[101] >= pos) {
      $$ = _getFromCache(101);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[101] = pos;
    }  
    // => FunctionDeclarator / FunctionPointerDeclarator / DeclaratorNotAbstract / TypedefFunctionDeclarator # Choice
    switch (_getState(_transitions36)) {
      // [(]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => FunctionPointerDeclarator
          $$ = _parse_FunctionPointerDeclarator();
          // <= FunctionPointerDeclarator
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => TypedefFunctionDeclarator
          $$ = _parse_TypedefFunctionDeclarator();
          // <= TypedefFunctionDeclarator
          _startPos = startPos1;
          break;
        }
        break;
      // [*]
      case 1:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => FunctionDeclarator
          $$ = _parse_FunctionDeclarator();
          // <= FunctionDeclarator
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => FunctionPointerDeclarator
          $$ = _parse_FunctionPointerDeclarator();
          // <= FunctionPointerDeclarator
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => DeclaratorNotAbstract
          $$ = _parse_DeclaratorNotAbstract();
          // <= DeclaratorNotAbstract
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          // => TypedefFunctionDeclarator
          $$ = _parse_TypedefFunctionDeclarator();
          // <= TypedefFunctionDeclarator
          _startPos = startPos5;
          break;
        }
        break;
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 2:
      case 4:
        while (true) {
          var startPos6 = _startPos;
          _startPos = _cursor;
          // => FunctionDeclarator
          $$ = _parse_FunctionDeclarator();
          // <= FunctionDeclarator
          _startPos = startPos6;
          if (success) break;
          var startPos7 = _startPos;
          _startPos = _cursor;
          // => DeclaratorNotAbstract
          $$ = _parse_DeclaratorNotAbstract();
          // <= DeclaratorNotAbstract
          _startPos = startPos7;
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: (, NONDIGIT, \U, \u
      _failure(_expect55);
    }
    // <= FunctionDeclarator / FunctionPointerDeclarator / DeclaratorNotAbstract / TypedefFunctionDeclarator # Choice
    if (_cacheable[101]) {
      _addToCache($$, pos, 101);
    }    
    return $$;
  }
  
  dynamic _parse_TypeDeclaratorList() {
    // SENTENCE (NONTERMINAL)
    // TypeDeclaratorList <- TypeDeclarator (COMMA TypeDeclarator)*
    var $$;
    // => TypeDeclarator (COMMA TypeDeclarator)* # Choice
    switch (_getState(_transitions35)) {
      // [(] [*] [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => TypeDeclarator (COMMA TypeDeclarator)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => TypeDeclarator
          $$ = _parse_TypeDeclarator();
          // <= TypeDeclarator
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA TypeDeclarator)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA TypeDeclarator) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA TypeDeclarator # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => TypeDeclarator
                  $$ = _parse_TypeDeclarator();
                  // <= TypeDeclarator
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA TypeDeclarator # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ,
              _failure(_expect6);
            }
            // <= (COMMA TypeDeclarator) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA TypeDeclarator)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // TypeDeclarator
            final $1 = seq[0];
            // (COMMA TypeDeclarator)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new TypedefDeclarators(elements: _list($1, $2));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TypeDeclarator (COMMA TypeDeclarator)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: (, NONDIGIT, \U, \u
      _failure(_expect55);
    }
    // <= TypeDeclarator (COMMA TypeDeclarator)* # Choice
    return $$;
  }
  
  dynamic _parse_TypeQualifier() {
    // SENTENCE (NONTERMINAL)
    // TypeQualifier <- (CONST / VOLATILE) Metadata?
    var $$;
    // => (CONST / VOLATILE) Metadata? # Choice
    switch (_getState(_transitions20)) {
      // [c] [v]
      case 0:
        // => (CONST / VOLATILE) Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (CONST / VOLATILE) # Choice
          switch (_getState(_transitions21)) {
            // [c]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => CONST
              $$ = _parse_CONST();
              // <= CONST
              _startPos = startPos1;
              break;
            // [v]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => VOLATILE
              $$ = _parse_VOLATILE();
              // <= VOLATILE
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: const, volatile
            _failure(_expect43);
          }
          // <= (CONST / VOLATILE) # Choice
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // (CONST / VOLATILE)
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new TypeQualifier(identifier: $1, metadata: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (CONST / VOLATILE) Metadata? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: const, volatile
      _failure(_expect43);
    }
    // <= (CONST / VOLATILE) Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_TypeQualifiers() {
    // SENTENCE (NONTERMINAL)
    // TypeQualifiers <- TypeQualifier+
    var $$;          
    var pos = _cursor;             
    if(_cachePos[60] >= pos) {
      $$ = _getFromCache(60);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[60] = pos;
    }  
    // => TypeQualifier+ # Choice
    switch (_getState(_transitions20)) {
      // [c] [v]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => TypeQualifier+
        var testing0;
        for (var first = true, reps; ;) {  
          // => TypeQualifier  
          $$ = _parse_TypeQualifier();  
          // <= TypeQualifier  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= TypeQualifier+
        if (success) {    
          // TypeQualifier+
          final $1 = $$;
          final $start = startPos0;
          $$ = new TypeQualifiers(elements: $1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: const, volatile
      _failure(_expect43);
    }
    // <= TypeQualifier+ # Choice
    if (_cacheable[60]) {
      _addToCache($$, pos, 60);
    }    
    return $$;
  }
  
  dynamic _parse_TypedefDeclaration() {
    // SENTENCE (NONTERMINAL)
    // TypedefDeclaration <- Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList
    var $$;
    // => Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList # Choice
    switch (_getState(_transitions34)) {
      // [_] [c] [t] [v]
      case 0:
        // => Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => TypedefSpecifier
          $$ = _parse_TypedefSpecifier();
          // <= TypedefSpecifier
          if (!success) break;
          seq[2] = $$;
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          seq[3] = $$;
          // => TypeDeclaratorList
          $$ = _parse_TypeDeclaratorList();
          // <= TypeDeclaratorList
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // TypedefSpecifier
            final $3 = seq[2];
            // Type
            final $4 = seq[3];
            // TypeDeclaratorList
            final $5 = seq[4];
            final $start = startPos0;
            $$ = new TypedefDeclaration(declarators: $5, metadata: $1, qualifiers: $2, type: $4, typedef: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: typedef
      _failure(_expect54);
    }
    // <= Metadata? TypeQualifiers? TypedefSpecifier Type TypeDeclaratorList # Choice
    return $$;
  }
  
  dynamic _parse_TypedefFunctionDeclarator() {
    // SENTENCE (NONTERMINAL)
    // TypedefFunctionDeclarator <- PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata?
    var $$;
    // => PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata? # Choice
    switch (_getState(_transitions31)) {
      // [(] [*]
      case 0:
        // => PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => PointerSpecifiers?
          var testing0 = _testing;
          _testing = _cursor;
          // => PointerSpecifiers
          $$ = _parse_PointerSpecifiers();
          // <= PointerSpecifiers
          success = true; 
          _testing = testing0;
          // <= PointerSpecifiers?
          if (!success) break;
          var seq = new List(8)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          if (!success) break;
          seq[2] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[3] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[4] = $$;
          // => FunctionParameters
          $$ = _parse_FunctionParameters();
          // <= FunctionParameters
          if (!success) break;
          seq[5] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[6] = $$;
          // => Metadata?
          var testing1 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing1;
          // <= Metadata?
          if (!success) break;
          seq[7] = $$;
          $$ = seq;
          if (success) {    
            // PointerSpecifiers?
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // Identifier
            final $3 = seq[2];
            // CLOSE_PAREN
            final $4 = seq[3];
            // OPEN_PAREN
            final $5 = seq[4];
            // FunctionParameters
            final $6 = seq[5];
            // CLOSE_PAREN
            final $7 = seq[6];
            // Metadata?
            final $8 = seq[7];
            final $start = startPos0;
            $$ = new Declarator(identifier: $3, metadata: $8, parameters: $6, pointers: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: (
      _failure(_expect18);
    }
    // <= PointerSpecifiers? OPEN_PAREN Identifier CLOSE_PAREN OPEN_PAREN FunctionParameters CLOSE_PAREN Metadata? # Choice
    return $$;
  }
  
  dynamic _parse_TypedefSpecifier() {
    // SENTENCE (NONTERMINAL)
    // TypedefSpecifier <- TYPEDEF Metadata? TypeQualifiers?
    var $$;
    // => TYPEDEF Metadata? TypeQualifiers? # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => TYPEDEF Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => TYPEDEF
          $$ = _parse_TYPEDEF();
          // <= TYPEDEF
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // TYPEDEF
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new TypedefSpecifier(metadata: $2, qualifiers: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= TYPEDEF Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: typedef
      _failure(_expect54);
    }
    // <= TYPEDEF Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_UNION() {
    // SENTENCE (NONTERMINAL)
    // UNION <- 'union' !IDENTIFIER_BASE1 SPACING
    var $$;          
    var pos = _cursor;             
    if(_cachePos[134] >= pos) {
      $$ = _getFromCache(134);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[134] = pos;
    }  
    // => 'union' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      // [u]
      case 0:
        // => 'union' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'union'
          $$ = _matchString(_strings42, 'union');
          // <= 'union'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'union'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'union' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: union
      _failure(_expect69);
    }
    // <= 'union' !IDENTIFIER_BASE1 SPACING # Choice
    if (_cacheable[134]) {
      _addToCache($$, pos, 134);
    }    
    return $$;
  }
  
  dynamic _parse_UNIVERSAL_CHARACTER_NAME() {
    // SENTENCE (NONTERMINAL)
    // UNIVERSAL_CHARACTER_NAME <- '\\U' HEX_QUAD HEX_QUAD / '\\u' HEX_QUAD
    var $$;          
    var pos = _cursor;             
    if(_cachePos[190] >= pos) {
      $$ = _getFromCache(190);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[190] = pos;
    }  
    // => '\\U' HEX_QUAD HEX_QUAD / '\\u' HEX_QUAD # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          // => '\\U' HEX_QUAD HEX_QUAD # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\U'
            $$ = _matchString(_strings56, '\\U');
            // <= '\\U'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => HEX_QUAD
            $$ = _parse_HEX_QUAD();
            // <= HEX_QUAD
            if (!success) break;
            seq[1] = $$;
            // => HEX_QUAD
            $$ = _parse_HEX_QUAD();
            // <= HEX_QUAD
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // '\\U'
              final $1 = seq[0];
              // HEX_QUAD
              final $2 = seq[1];
              // HEX_QUAD
              final $3 = seq[2];
              final $start = startPos0;
              $$ = int.parse(_text(2), radix: 16);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '\\U' HEX_QUAD HEX_QUAD # Sequence
          if (success) break;
          // => '\\u' HEX_QUAD # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\u'
            $$ = _matchString(_strings57, '\\u');
            // <= '\\u'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => HEX_QUAD
            $$ = _parse_HEX_QUAD();
            // <= HEX_QUAD
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // '\\u'
              final $1 = seq[0];
              // HEX_QUAD
              final $2 = seq[1];
              final $start = startPos1;
              $$ = int.parse(_text(2), radix: 16);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '\\u' HEX_QUAD # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: \U, \u
      _failure(_expect101);
    }
    // <= '\\U' HEX_QUAD HEX_QUAD / '\\u' HEX_QUAD # Choice
    if (_cacheable[190]) {
      _addToCache($$, pos, 190);
    }    
    return $$;
  }
  
  dynamic _parse_UNSIGNED() {
    // SENTENCE (NONTERMINAL)
    // UNSIGNED <- 'unsigned' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'unsigned' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      // [u]
      case 0:
        // => 'unsigned' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'unsigned'
          $$ = _matchString(_strings43, 'unsigned');
          // <= 'unsigned'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'unsigned'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'unsigned' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: unsigned
      _failure(_expect84);
    }
    // <= 'unsigned' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_UNSIGNED_SUFFIX() {
    // MORHEME
    // UNSIGNED_SUFFIX <- [Uu]
    var $$;
    // => [Uu] # Choice
    switch (_getState(_transitions64)) {
      // [U] [u]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [Uu]
        $$ = _matchMapping(85, 117, _mapping11);
        // <= [Uu]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [Uu] # Choice
    return $$;
  }
  
  dynamic _parse_VOID() {
    // SENTENCE (NONTERMINAL)
    // VOID <- 'void' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'void' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        // => 'void' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'void'
          $$ = _matchString(_strings44, 'void');
          // <= 'void'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'void'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'void' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: void
      _failure(_expect46);
    }
    // <= 'void' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_VOLATILE() {
    // SENTENCE (NONTERMINAL)
    // VOLATILE <- 'volatile' !IDENTIFIER_BASE1 SPACING
    var $$;
    // => 'volatile' !IDENTIFIER_BASE1 SPACING # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        // => 'volatile' !IDENTIFIER_BASE1 SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'volatile'
          $$ = _matchString(_strings45, 'volatile');
          // <= 'volatile'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !IDENTIFIER_BASE1
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => IDENTIFIER_BASE1
          $$ = _parse_IDENTIFIER_BASE1();
          // <= IDENTIFIER_BASE1
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !IDENTIFIER_BASE1
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'volatile'
            final $1 = seq[0];
            // !IDENTIFIER_BASE1
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Identifier(name: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'volatile' !IDENTIFIER_BASE1 SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: volatile
      _failure(_expect70);
    }
    // <= 'volatile' !IDENTIFIER_BASE1 SPACING # Choice
    return $$;
  }
  
  dynamic _parse_VariableDeclaration() {
    // SENTENCE (NONTERMINAL)
    // VariableDeclaration <- Metadata? TypeQualifiers? Type VariableDeclaratorList
    var $$;
    // => Metadata? TypeQualifiers? Type VariableDeclaratorList # Choice
    switch (_getState(_transitions2)) {
      // [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => Metadata? TypeQualifiers? Type VariableDeclaratorList # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[1] = $$;
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          seq[2] = $$;
          // => VariableDeclaratorList
          $$ = _parse_VariableDeclaratorList();
          // <= VariableDeclaratorList
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // Metadata?
            final $1 = seq[0];
            // TypeQualifiers?
            final $2 = seq[1];
            // Type
            final $3 = seq[2];
            // VariableDeclaratorList
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new VariableDeclaration(declarators: $4, metadata: $1, qualifiers: $2, type: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Metadata? TypeQualifiers? Type VariableDeclaratorList # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: char, short, long, int, signed, unsigned, float, double, void, _Bool, struct, union, enum, NONDIGIT, \U, \u
      _failure(_expect3);
    }
    // <= Metadata? TypeQualifiers? Type VariableDeclaratorList # Choice
    return $$;
  }
  
  dynamic _parse_VariableDeclarator() {
    // SENTENCE (NONTERMINAL)
    // VariableDeclarator <- DeclaratorNotAbstract
    var $$;          
    var pos = _cursor;             
    if(_cachePos[105] >= pos) {
      $$ = _getFromCache(105);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[105] = pos;
    }  
    // => DeclaratorNotAbstract # Choice
    switch (_getState(_transitions22)) {
      // [*] [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => DeclaratorNotAbstract
        $$ = _parse_DeclaratorNotAbstract();
        // <= DeclaratorNotAbstract
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= DeclaratorNotAbstract # Choice
    if (_cacheable[105]) {
      _addToCache($$, pos, 105);
    }    
    return $$;
  }
  
  dynamic _parse_VariableDeclaratorList() {
    // SENTENCE (NONTERMINAL)
    // VariableDeclaratorList <- VariableDeclarator (COMMA VariableDeclarator)*
    var $$;
    // => VariableDeclarator (COMMA VariableDeclarator)* # Choice
    switch (_getState(_transitions22)) {
      // [*] [A-Z] [\\] [_] [a-z]
      // EOF
      case 0:
      case 2:
        // => VariableDeclarator (COMMA VariableDeclarator)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => VariableDeclarator
          $$ = _parse_VariableDeclarator();
          // <= VariableDeclarator
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (COMMA VariableDeclarator)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (COMMA VariableDeclarator) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => COMMA VariableDeclarator # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => COMMA
                  $$ = _parse_COMMA();
                  // <= COMMA
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => VariableDeclarator
                  $$ = _parse_VariableDeclarator();
                  // <= VariableDeclarator
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= COMMA VariableDeclarator # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ,
              _failure(_expect6);
            }
            // <= (COMMA VariableDeclarator) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (COMMA VariableDeclarator)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // VariableDeclarator
            final $1 = seq[0];
            // (COMMA VariableDeclarator)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new VariableDeclarators(elements: _list($1, $2));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= VariableDeclarator (COMMA VariableDeclarator)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONDIGIT, \U, \u
      _failure(_expect5);
    }
    // <= VariableDeclarator (COMMA VariableDeclarator)* # Choice
    return $$;
  }
  
  dynamic _parse_VoidType() {
    // SENTENCE (NONTERMINAL)
    // VoidType <- VOID Metadata? TypeQualifiers?
    var $$;
    // => VOID Metadata? TypeQualifiers? # Choice
    switch (_ch == 118 ? 0 : _ch == -1 ? 2 : 1) {
      // [v]
      case 0:
        // => VOID Metadata? TypeQualifiers? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => VOID
          $$ = _parse_VOID();
          // <= VOID
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Metadata?
          var testing0 = _testing;
          _testing = _cursor;
          // => Metadata
          $$ = _parse_Metadata();
          // <= Metadata
          success = true; 
          _testing = testing0;
          // <= Metadata?
          if (!success) break;
          seq[1] = $$;
          // => TypeQualifiers?
          var testing1 = _testing;
          _testing = _cursor;
          // => TypeQualifiers
          $$ = _parse_TypeQualifiers();
          // <= TypeQualifiers
          success = true; 
          _testing = testing1;
          // <= TypeQualifiers?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // VOID
            final $1 = seq[0];
            // Metadata?
            final $2 = seq[1];
            // TypeQualifiers?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new VoidTypeSpecification(identifier: _ident([$1]), metadata: $2, qualifiers: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= VOID Metadata? TypeQualifiers? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: void
      _failure(_expect46);
    }
    // <= VOID Metadata? TypeQualifiers? # Choice
    return $$;
  }
  
  dynamic _parse_additive_expression() {
    // SENTENCE (NONTERMINAL)
    // additive_expression <- multiplicative_expression (additive_operator multiplicative_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[21] >= pos) {
      $$ = _getFromCache(21);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[21] = pos;
    }  
    // => multiplicative_expression (additive_operator multiplicative_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => multiplicative_expression (additive_operator multiplicative_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => multiplicative_expression
          $$ = _parse_multiplicative_expression();
          // <= multiplicative_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (additive_operator multiplicative_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (additive_operator multiplicative_expression) # Choice
            switch (_getState(_transitions8)) {
              // [+] [-]
              case 0:
                // => additive_operator multiplicative_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => additive_operator
                  $$ = _parse_additive_operator();
                  // <= additive_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => multiplicative_expression
                  $$ = _parse_multiplicative_expression();
                  // <= multiplicative_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= additive_operator multiplicative_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: +, -
              _failure(_expect11);
            }
            // <= (additive_operator multiplicative_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (additive_operator multiplicative_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // multiplicative_expression
            final $1 = seq[0];
            // (additive_operator multiplicative_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= multiplicative_expression (additive_operator multiplicative_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= multiplicative_expression (additive_operator multiplicative_expression)* # Choice
    if (_cacheable[21]) {
      _addToCache($$, pos, 21);
    }    
    return $$;
  }
  
  dynamic _parse_additive_operator() {
    // SENTENCE (NONTERMINAL)
    // additive_operator <- plus / minus
    var $$;
    // => plus / minus # Choice
    switch (_getState(_transitions18)) {
      // [+]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => plus
        $$ = _parse_plus();
        // <= plus
        _startPos = startPos0;
        break;
      // [-]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => minus
        $$ = _parse_minus();
        // <= minus
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: +, -
      _failure(_expect11);
    }
    // <= plus / minus # Choice
    return $$;
  }
  
  dynamic _parse_and_expression() {
    // SENTENCE (NONTERMINAL)
    // and_expression <- equality_expression (and_operator equality_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[17] >= pos) {
      $$ = _getFromCache(17);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[17] = pos;
    }  
    // => equality_expression (and_operator equality_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => equality_expression (and_operator equality_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => equality_expression
          $$ = _parse_equality_expression();
          // <= equality_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (and_operator equality_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (and_operator equality_expression) # Choice
            switch (_getState(_transitions6)) {
              // No matches
              // EOF
              case 0:
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(_expect1);
            }
            // <= (and_operator equality_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (and_operator equality_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // equality_expression
            final $1 = seq[0];
            // (and_operator equality_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= equality_expression (and_operator equality_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= equality_expression (and_operator equality_expression)* # Choice
    if (_cacheable[17]) {
      _addToCache($$, pos, 17);
    }    
    return $$;
  }
  
  dynamic _parse_asterisk() {
    // SENTENCE (NONTERMINAL)
    // asterisk <- '*' spaces
    var $$;
    // => '*' spaces # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => '*' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '*'
          $$ = '*';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '*'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '*'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '*' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: *
      _failure(_expect25);
    }
    // <= '*' spaces # Choice
    return $$;
  }
  
  dynamic _parse_character_constant_base() {
    // SENTENCE (NONTERMINAL)
    // character_constant_base <- '\'' C_CHAR '\'' / 'L\'' C_CHAR '\''
    var $$;
    // => '\'' C_CHAR '\'' / 'L\'' C_CHAR '\'' # Choice
    switch (_getState(_transitions43)) {
      // [\']
      case 0:
        // => '\'' C_CHAR '\'' # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '\''
          $$ = '\'';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '\''
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => C_CHAR
          $$ = _parse_C_CHAR();
          // <= C_CHAR
          if (!success) break;
          seq[1] = $$;
          // => '\''
          $$ = _matchChar(39, '\'');
          // <= '\''
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '\''
            final $1 = seq[0];
            // C_CHAR
            final $2 = seq[1];
            // '\''
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new CharacterLiteral(text: _text(), value: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '\'' C_CHAR '\'' # Sequence
        break;
      // [L]
      case 1:
        // => 'L\'' C_CHAR '\'' # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'L\''
          $$ = _matchString(_strings47, 'L\'');
          // <= 'L\''
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => C_CHAR
          $$ = _parse_C_CHAR();
          // <= C_CHAR
          if (!success) break;
          seq[1] = $$;
          // => '\''
          $$ = _matchChar(39, '\'');
          // <= '\''
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'L\''
            final $1 = seq[0];
            // C_CHAR
            final $2 = seq[1];
            // '\''
            final $3 = seq[2];
            final $start = startPos1;
            $$ = new CharacterLiteral(text: _text(), value: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= 'L\'' C_CHAR '\'' # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ', L'
      _failure(_expect71);
    }
    // <= '\'' C_CHAR '\'' / 'L\'' C_CHAR '\'' # Choice
    return $$;
  }
  
  dynamic _parse_conditional_expression() {
    // SENTENCE (NONTERMINAL)
    // conditional_expression <- logical_or_expression question_mark expression semicolon conditional_expression / logical_or_expression
    var $$;          
    var pos = _cursor;             
    if(_cachePos[12] >= pos) {
      $$ = _getFromCache(12);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[12] = pos;
    }  
    // => logical_or_expression question_mark expression semicolon conditional_expression / logical_or_expression # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => logical_or_expression question_mark expression semicolon conditional_expression # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => logical_or_expression
            $$ = _parse_logical_or_expression();
            // <= logical_or_expression
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => question_mark
            $$ = _parse_question_mark();
            // <= question_mark
            if (!success) break;
            seq[1] = $$;
            // => expression
            $$ = _parse_expression();
            // <= expression
            if (!success) break;
            seq[2] = $$;
            // => semicolon
            $$ = _parse_semicolon();
            // <= semicolon
            if (!success) break;
            seq[3] = $$;
            // => conditional_expression
            $$ = _parse_conditional_expression();
            // <= conditional_expression
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              // logical_or_expression
              final $1 = seq[0];
              // question_mark
              final $2 = seq[1];
              // expression
              final $3 = seq[2];
              // semicolon
              final $4 = seq[3];
              // conditional_expression
              final $5 = seq[4];
              final $start = startPos0;
              $$ = _conditional($1, $3, $5);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= logical_or_expression question_mark expression semicolon conditional_expression # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => logical_or_expression
          $$ = _parse_logical_or_expression();
          // <= logical_or_expression
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= logical_or_expression question_mark expression semicolon conditional_expression / logical_or_expression # Choice
    if (_cacheable[12]) {
      _addToCache($$, pos, 12);
    }    
    return $$;
  }
  
  dynamic _parse_constant() {
    // SENTENCE (NONTERMINAL)
    // constant <- constant_base SPACING
    var $$;
    // => constant_base SPACING # Choice
    switch (_getState(_transitions12)) {
      // [\'] [.] [0-9] [L]
      case 0:
        // => constant_base SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => constant_base
          $$ = _parse_constant_base();
          // <= constant_base
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // constant_base
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= constant_base SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L'
      _failure(_expect15);
    }
    // <= constant_base SPACING # Choice
    return $$;
  }
  
  dynamic _parse_constant_base() {
    // SENTENCE (NONTERMINAL)
    // constant_base <- floating_constant_base / integer_constant_base / character_constant_base
    var $$;
    // => floating_constant_base / integer_constant_base / character_constant_base # Choice
    switch (_getState(_transitions13)) {
      // [\'] [L]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => character_constant_base
        $$ = _parse_character_constant_base();
        // <= character_constant_base
        _startPos = startPos0;
        break;
      // [.]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => floating_constant_base
        $$ = _parse_floating_constant_base();
        // <= floating_constant_base
        _startPos = startPos1;
        break;
      // [0-9]
      case 2:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => floating_constant_base
          $$ = _parse_floating_constant_base();
          // <= floating_constant_base
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => integer_constant_base
          $$ = _parse_integer_constant_base();
          // <= integer_constant_base
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L'
      _failure(_expect15);
    }
    // <= floating_constant_base / integer_constant_base / character_constant_base # Choice
    return $$;
  }
  
  dynamic _parse_constant_expression() {
    // SENTENCE (NONTERMINAL)
    // constant_expression <- conditional_expression / string_literal
    var $$;          
    var pos = _cursor;             
    if(_cachePos[11] >= pos) {
      $$ = _getFromCache(11);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[11] = pos;
    }  
    // => conditional_expression / string_literal # Choice
    switch (_getState(_transitions4)) {
      // [!] [\'-(] [+] [--.] [0-9] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 4:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => conditional_expression
        $$ = _parse_conditional_expression();
        // <= conditional_expression
        _startPos = startPos0;
        break;
      // [\"]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => string_literal
        $$ = _parse_string_literal();
        // <= string_literal
        _startPos = startPos1;
        break;
      // [A-Z]
      case 2:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => conditional_expression
          $$ = _parse_conditional_expression();
          // <= conditional_expression
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => string_literal
          $$ = _parse_string_literal();
          // <= string_literal
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, ", L", NONDIGIT, \U, \u
      _failure(_expect7);
    }
    // <= conditional_expression / string_literal # Choice
    if (_cacheable[11]) {
      _addToCache($$, pos, 11);
    }    
    return $$;
  }
  
  dynamic _parse_decimal_floating_constant() {
    // SENTENCE (NONTERMINAL)
    // decimal_floating_constant <- decimal_floating_constant_base SPACING
    var $$;
    // => decimal_floating_constant_base SPACING # Choice
    switch (_getState(_transitions15)) {
      // [.] [0-9]
      case 0:
        // => decimal_floating_constant_base SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => decimal_floating_constant_base
          $$ = _parse_decimal_floating_constant_base();
          // <= decimal_floating_constant_base
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // decimal_floating_constant_base
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= decimal_floating_constant_base SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ., DIGIT
      _failure(_expect17);
    }
    // <= decimal_floating_constant_base SPACING # Choice
    return $$;
  }
  
  dynamic _parse_decimal_floating_constant_base() {
    // SENTENCE (NONTERMINAL)
    // decimal_floating_constant_base <- FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX? / DIGIT_SEQUENCE EXPONENT_PART FLOATING_SUFFIX?
    var $$;
    // => FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX? / DIGIT_SEQUENCE EXPONENT_PART FLOATING_SUFFIX? # Choice
    switch (_getState(_transitions14)) {
      // [.]
      case 0:
        // => FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => FRACTIONAL_CONSTANT
          $$ = _parse_FRACTIONAL_CONSTANT();
          // <= FRACTIONAL_CONSTANT
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => EXPONENT_PART?
          var testing0 = _testing;
          _testing = _cursor;
          // => EXPONENT_PART
          $$ = _parse_EXPONENT_PART();
          // <= EXPONENT_PART
          success = true; 
          _testing = testing0;
          // <= EXPONENT_PART?
          if (!success) break;
          seq[1] = $$;
          // => FLOATING_SUFFIX?
          var testing1 = _testing;
          _testing = _cursor;
          // => FLOATING_SUFFIX
          $$ = _parse_FLOATING_SUFFIX();
          // <= FLOATING_SUFFIX
          success = true; 
          _testing = testing1;
          // <= FLOATING_SUFFIX?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // FRACTIONAL_CONSTANT
            final $1 = seq[0];
            // EXPONENT_PART?
            final $2 = seq[1];
            // FLOATING_SUFFIX?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _floatLiteral(_text());
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX? # Sequence
        break;
      // [0-9]
      case 1:
        while (true) {
          // => FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => FRACTIONAL_CONSTANT
            $$ = _parse_FRACTIONAL_CONSTANT();
            // <= FRACTIONAL_CONSTANT
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => EXPONENT_PART?
            var testing2 = _testing;
            _testing = _cursor;
            // => EXPONENT_PART
            $$ = _parse_EXPONENT_PART();
            // <= EXPONENT_PART
            success = true; 
            _testing = testing2;
            // <= EXPONENT_PART?
            if (!success) break;
            seq[1] = $$;
            // => FLOATING_SUFFIX?
            var testing3 = _testing;
            _testing = _cursor;
            // => FLOATING_SUFFIX
            $$ = _parse_FLOATING_SUFFIX();
            // <= FLOATING_SUFFIX
            success = true; 
            _testing = testing3;
            // <= FLOATING_SUFFIX?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // FRACTIONAL_CONSTANT
              final $1 = seq[0];
              // EXPONENT_PART?
              final $2 = seq[1];
              // FLOATING_SUFFIX?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = _floatLiteral(_text());
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX? # Sequence
          if (success) break;
          // => DIGIT_SEQUENCE EXPONENT_PART FLOATING_SUFFIX? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => DIGIT_SEQUENCE
            $$ = _parse_DIGIT_SEQUENCE();
            // <= DIGIT_SEQUENCE
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => EXPONENT_PART
            $$ = _parse_EXPONENT_PART();
            // <= EXPONENT_PART
            if (!success) break;
            seq[1] = $$;
            // => FLOATING_SUFFIX?
            var testing4 = _testing;
            _testing = _cursor;
            // => FLOATING_SUFFIX
            $$ = _parse_FLOATING_SUFFIX();
            // <= FLOATING_SUFFIX
            success = true; 
            _testing = testing4;
            // <= FLOATING_SUFFIX?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // DIGIT_SEQUENCE
              final $1 = seq[0];
              // EXPONENT_PART
              final $2 = seq[1];
              // FLOATING_SUFFIX?
              final $3 = seq[2];
              final $start = startPos2;
              $$ = _floatLiteral(_text());
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= DIGIT_SEQUENCE EXPONENT_PART FLOATING_SUFFIX? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ., DIGIT
      _failure(_expect17);
    }
    // <= FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX? / DIGIT_SEQUENCE EXPONENT_PART FLOATING_SUFFIX? # Choice
    return $$;
  }
  
  dynamic _parse_equality_expression() {
    // SENTENCE (NONTERMINAL)
    // equality_expression <- relational_expression (equality_operator relational_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[18] >= pos) {
      $$ = _getFromCache(18);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[18] = pos;
    }  
    // => relational_expression (equality_operator relational_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => relational_expression (equality_operator relational_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => relational_expression
          $$ = _parse_relational_expression();
          // <= relational_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (equality_operator relational_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (equality_operator relational_expression) # Choice
            switch (_getState(_transitions6)) {
              // No matches
              // EOF
              case 0:
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(_expect1);
            }
            // <= (equality_operator relational_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (equality_operator relational_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // relational_expression
            final $1 = seq[0];
            // (equality_operator relational_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= relational_expression (equality_operator relational_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= relational_expression (equality_operator relational_expression)* # Choice
    if (_cacheable[18]) {
      _addToCache($$, pos, 18);
    }    
    return $$;
  }
  
  dynamic _parse_exclamation() {
    // SENTENCE (NONTERMINAL)
    // exclamation <- '!' spaces
    var $$;
    // => '!' spaces # Choice
    switch (_ch == 33 ? 0 : _ch == -1 ? 2 : 1) {
      // [!]
      case 0:
        // => '!' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '!'
          $$ = '!';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '!'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '!'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '!' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: !
      _failure(_expect24);
    }
    // <= '!' spaces # Choice
    return $$;
  }
  
  dynamic _parse_exclusive_or_expression() {
    // SENTENCE (NONTERMINAL)
    // exclusive_or_expression <- and_expression (exclusive_or_operator and_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[16] >= pos) {
      $$ = _getFromCache(16);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[16] = pos;
    }  
    // => and_expression (exclusive_or_operator and_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => and_expression (exclusive_or_operator and_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => and_expression
          $$ = _parse_and_expression();
          // <= and_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (exclusive_or_operator and_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (exclusive_or_operator and_expression) # Choice
            switch (_getState(_transitions6)) {
              // No matches
              // EOF
              case 0:
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(_expect1);
            }
            // <= (exclusive_or_operator and_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (exclusive_or_operator and_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // and_expression
            final $1 = seq[0];
            // (exclusive_or_operator and_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= and_expression (exclusive_or_operator and_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= and_expression (exclusive_or_operator and_expression)* # Choice
    if (_cacheable[16]) {
      _addToCache($$, pos, 16);
    }    
    return $$;
  }
  
  dynamic _parse_expression() {
    // SENTENCE (NONTERMINAL)
    // expression <- conditional_expression
    var $$;          
    var pos = _cursor;             
    if(_cachePos[26] >= pos) {
      $$ = _getFromCache(26);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[26] = pos;
    }  
    // => conditional_expression # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => conditional_expression
        $$ = _parse_conditional_expression();
        // <= conditional_expression
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= conditional_expression # Choice
    if (_cacheable[26]) {
      _addToCache($$, pos, 26);
    }    
    return $$;
  }
  
  dynamic _parse_floating_constant_base() {
    // SENTENCE (NONTERMINAL)
    // floating_constant_base <- decimal_floating_constant / hexadecimal_floating_constant
    var $$;
    // => decimal_floating_constant / hexadecimal_floating_constant # Choice
    switch (_getState(_transitions14)) {
      // [.]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => decimal_floating_constant
        $$ = _parse_decimal_floating_constant();
        // <= decimal_floating_constant
        _startPos = startPos0;
        break;
      // [0-9]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => decimal_floating_constant
          $$ = _parse_decimal_floating_constant();
          // <= decimal_floating_constant
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => hexadecimal_floating_constant
          $$ = _parse_hexadecimal_floating_constant();
          // <= hexadecimal_floating_constant
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ., DIGIT, HEXADECIMAL_PREFIX
      _failure(_expect16);
    }
    // <= decimal_floating_constant / hexadecimal_floating_constant # Choice
    return $$;
  }
  
  dynamic _parse_gt() {
    // SENTENCE (NONTERMINAL)
    // gt <- '>' spaces
    var $$;
    // => '>' spaces # Choice
    switch (_ch == 62 ? 0 : _ch == -1 ? 2 : 1) {
      // [>]
      case 0:
        // => '>' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '>'
          $$ = '>';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '>'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '>'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '>' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: >
      _failure(_expect31);
    }
    // <= '>' spaces # Choice
    return $$;
  }
  
  dynamic _parse_gte() {
    // SENTENCE (NONTERMINAL)
    // gte <- '>=' spaces
    var $$;
    // => '>=' spaces # Choice
    switch (_ch == 62 ? 0 : _ch == -1 ? 2 : 1) {
      // [>]
      case 0:
        // => '>=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '>='
          $$ = _matchString(_strings3, '>=');
          // <= '>='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '>='
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '>=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: >=
      _failure(_expect33);
    }
    // <= '>=' spaces # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_floating_constant() {
    // SENTENCE (NONTERMINAL)
    // hexadecimal_floating_constant <- HEXADECIMAL_PREFIX HEXADECIMAL_FRACTIONAL_CONSTANT BINARY_EXPONENT_PART FLOATING_SUFFIX? / HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT_SEQUENCE BINARY_EXPONENT_PART FLOATING_SUFFIX?
    var $$;
    // => HEXADECIMAL_PREFIX HEXADECIMAL_FRACTIONAL_CONSTANT BINARY_EXPONENT_PART FLOATING_SUFFIX? / HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT_SEQUENCE BINARY_EXPONENT_PART FLOATING_SUFFIX? # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        while (true) {
          // => HEXADECIMAL_PREFIX HEXADECIMAL_FRACTIONAL_CONSTANT BINARY_EXPONENT_PART FLOATING_SUFFIX? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => HEXADECIMAL_PREFIX
            $$ = _parse_HEXADECIMAL_PREFIX();
            // <= HEXADECIMAL_PREFIX
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => HEXADECIMAL_FRACTIONAL_CONSTANT
            $$ = _parse_HEXADECIMAL_FRACTIONAL_CONSTANT();
            // <= HEXADECIMAL_FRACTIONAL_CONSTANT
            if (!success) break;
            seq[1] = $$;
            // => BINARY_EXPONENT_PART
            $$ = _parse_BINARY_EXPONENT_PART();
            // <= BINARY_EXPONENT_PART
            if (!success) break;
            seq[2] = $$;
            // => FLOATING_SUFFIX?
            var testing0 = _testing;
            _testing = _cursor;
            // => FLOATING_SUFFIX
            $$ = _parse_FLOATING_SUFFIX();
            // <= FLOATING_SUFFIX
            success = true; 
            _testing = testing0;
            // <= FLOATING_SUFFIX?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // HEXADECIMAL_PREFIX
              final $1 = seq[0];
              // HEXADECIMAL_FRACTIONAL_CONSTANT
              final $2 = seq[1];
              // BINARY_EXPONENT_PART
              final $3 = seq[2];
              // FLOATING_SUFFIX?
              final $4 = seq[3];
              final $start = startPos0;
              $$ = _floatLiteral(_text());
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= HEXADECIMAL_PREFIX HEXADECIMAL_FRACTIONAL_CONSTANT BINARY_EXPONENT_PART FLOATING_SUFFIX? # Sequence
          if (success) break;
          // => HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT_SEQUENCE BINARY_EXPONENT_PART FLOATING_SUFFIX? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => HEXADECIMAL_PREFIX
            $$ = _parse_HEXADECIMAL_PREFIX();
            // <= HEXADECIMAL_PREFIX
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => HEXADECIMAL_DIGIT_SEQUENCE
            $$ = _parse_HEXADECIMAL_DIGIT_SEQUENCE();
            // <= HEXADECIMAL_DIGIT_SEQUENCE
            if (!success) break;
            seq[1] = $$;
            // => BINARY_EXPONENT_PART
            $$ = _parse_BINARY_EXPONENT_PART();
            // <= BINARY_EXPONENT_PART
            if (!success) break;
            seq[2] = $$;
            // => FLOATING_SUFFIX?
            var testing1 = _testing;
            _testing = _cursor;
            // => FLOATING_SUFFIX
            $$ = _parse_FLOATING_SUFFIX();
            // <= FLOATING_SUFFIX
            success = true; 
            _testing = testing1;
            // <= FLOATING_SUFFIX?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // HEXADECIMAL_PREFIX
              final $1 = seq[0];
              // HEXADECIMAL_DIGIT_SEQUENCE
              final $2 = seq[1];
              // BINARY_EXPONENT_PART
              final $3 = seq[2];
              // FLOATING_SUFFIX?
              final $4 = seq[3];
              final $start = startPos1;
              $$ = _floatLiteral(_text());
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT_SEQUENCE BINARY_EXPONENT_PART FLOATING_SUFFIX? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: HEXADECIMAL_PREFIX
      _failure(_expect72);
    }
    // <= HEXADECIMAL_PREFIX HEXADECIMAL_FRACTIONAL_CONSTANT BINARY_EXPONENT_PART FLOATING_SUFFIX? / HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT_SEQUENCE BINARY_EXPONENT_PART FLOATING_SUFFIX? # Choice
    return $$;
  }
  
  dynamic _parse_inclusive_or_expression() {
    // SENTENCE (NONTERMINAL)
    // inclusive_or_expression <- exclusive_or_expression (inclusive_or_operator exclusive_or_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[15] >= pos) {
      $$ = _getFromCache(15);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[15] = pos;
    }  
    // => exclusive_or_expression (inclusive_or_operator exclusive_or_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => exclusive_or_expression (inclusive_or_operator exclusive_or_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => exclusive_or_expression
          $$ = _parse_exclusive_or_expression();
          // <= exclusive_or_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (inclusive_or_operator exclusive_or_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (inclusive_or_operator exclusive_or_expression) # Choice
            switch (_getState(_transitions6)) {
              // No matches
              // EOF
              case 0:
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(_expect1);
            }
            // <= (inclusive_or_operator exclusive_or_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (inclusive_or_operator exclusive_or_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // exclusive_or_expression
            final $1 = seq[0];
            // (inclusive_or_operator exclusive_or_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= exclusive_or_expression (inclusive_or_operator exclusive_or_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= exclusive_or_expression (inclusive_or_operator exclusive_or_expression)* # Choice
    if (_cacheable[15]) {
      _addToCache($$, pos, 15);
    }    
    return $$;
  }
  
  dynamic _parse_integer_constant() {
    // SENTENCE (NONTERMINAL)
    // integer_constant <- integer_constant_base spaces
    var $$;          
    var pos = _cursor;             
    if(_cachePos[81] >= pos) {
      $$ = _getFromCache(81);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[81] = pos;
    }  
    // => integer_constant_base spaces # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        // => integer_constant_base spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => integer_constant_base
          $$ = _parse_integer_constant_base();
          // <= integer_constant_base
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // integer_constant_base
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= integer_constant_base spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONZERO_DIGIT, HEXADECIMAL_PREFIX, '0'
      _failure(_expect50);
    }
    // <= integer_constant_base spaces # Choice
    if (_cacheable[81]) {
      _addToCache($$, pos, 81);
    }    
    return $$;
  }
  
  dynamic _parse_integer_constant_base() {
    // SENTENCE (NONTERMINAL)
    // integer_constant_base <- DECIMAL_CONSTANT INTEGER_SUFFIX? / HEXADECIMAL_CONSTANT INTEGER_SUFFIX? / OCTAL_CONSTANT INTEGER_SUFFIX?
    var $$;          
    var pos = _cursor;             
    if(_cachePos[140] >= pos) {
      $$ = _getFromCache(140);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[140] = pos;
    }  
    // => DECIMAL_CONSTANT INTEGER_SUFFIX? / HEXADECIMAL_CONSTANT INTEGER_SUFFIX? / OCTAL_CONSTANT INTEGER_SUFFIX? # Choice
    switch (_getState(_transitions44)) {
      // [0]
      case 0:
        while (true) {
          // => HEXADECIMAL_CONSTANT INTEGER_SUFFIX? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => HEXADECIMAL_CONSTANT
            $$ = _parse_HEXADECIMAL_CONSTANT();
            // <= HEXADECIMAL_CONSTANT
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => INTEGER_SUFFIX?
            var testing0 = _testing;
            _testing = _cursor;
            // => INTEGER_SUFFIX
            $$ = _parse_INTEGER_SUFFIX();
            // <= INTEGER_SUFFIX
            success = true; 
            _testing = testing0;
            // <= INTEGER_SUFFIX?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // HEXADECIMAL_CONSTANT
              final $1 = seq[0];
              // INTEGER_SUFFIX?
              final $2 = seq[1];
              final $start = startPos0;
              $$ = new IntegerLiteral(text: _text(), value: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= HEXADECIMAL_CONSTANT INTEGER_SUFFIX? # Sequence
          if (success) break;
          // => OCTAL_CONSTANT INTEGER_SUFFIX? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => OCTAL_CONSTANT
            $$ = _parse_OCTAL_CONSTANT();
            // <= OCTAL_CONSTANT
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => INTEGER_SUFFIX?
            var testing1 = _testing;
            _testing = _cursor;
            // => INTEGER_SUFFIX
            $$ = _parse_INTEGER_SUFFIX();
            // <= INTEGER_SUFFIX
            success = true; 
            _testing = testing1;
            // <= INTEGER_SUFFIX?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // OCTAL_CONSTANT
              final $1 = seq[0];
              // INTEGER_SUFFIX?
              final $2 = seq[1];
              final $start = startPos1;
              $$ = new IntegerLiteral(text: _text(), value: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= OCTAL_CONSTANT INTEGER_SUFFIX? # Sequence
          break;
        }
        break;
      // [1-9]
      case 1:
        // => DECIMAL_CONSTANT INTEGER_SUFFIX? # Sequence
        var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => DECIMAL_CONSTANT
          $$ = _parse_DECIMAL_CONSTANT();
          // <= DECIMAL_CONSTANT
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => INTEGER_SUFFIX?
          var testing2 = _testing;
          _testing = _cursor;
          // => INTEGER_SUFFIX
          $$ = _parse_INTEGER_SUFFIX();
          // <= INTEGER_SUFFIX
          success = true; 
          _testing = testing2;
          // <= INTEGER_SUFFIX?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // DECIMAL_CONSTANT
            final $1 = seq[0];
            // INTEGER_SUFFIX?
            final $2 = seq[1];
            final $start = startPos2;
            $$ = new IntegerLiteral(text: _text(), value: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos2;
        // <= DECIMAL_CONSTANT INTEGER_SUFFIX? # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NONZERO_DIGIT, HEXADECIMAL_PREFIX, '0'
      _failure(_expect50);
    }
    // <= DECIMAL_CONSTANT INTEGER_SUFFIX? / HEXADECIMAL_CONSTANT INTEGER_SUFFIX? / OCTAL_CONSTANT INTEGER_SUFFIX? # Choice
    if (_cacheable[140]) {
      _addToCache($$, pos, 140);
    }    
    return $$;
  }
  
  dynamic _parse_logical_and_expression() {
    // SENTENCE (NONTERMINAL)
    // logical_and_expression <- inclusive_or_expression (logical_and_operator inclusive_or_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[14] >= pos) {
      $$ = _getFromCache(14);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[14] = pos;
    }  
    // => inclusive_or_expression (logical_and_operator inclusive_or_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => inclusive_or_expression (logical_and_operator inclusive_or_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => inclusive_or_expression
          $$ = _parse_inclusive_or_expression();
          // <= inclusive_or_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (logical_and_operator inclusive_or_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (logical_and_operator inclusive_or_expression) # Choice
            switch (_getState(_transitions6)) {
              // No matches
              // EOF
              case 0:
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(_expect1);
            }
            // <= (logical_and_operator inclusive_or_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (logical_and_operator inclusive_or_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // inclusive_or_expression
            final $1 = seq[0];
            // (logical_and_operator inclusive_or_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= inclusive_or_expression (logical_and_operator inclusive_or_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= inclusive_or_expression (logical_and_operator inclusive_or_expression)* # Choice
    if (_cacheable[14]) {
      _addToCache($$, pos, 14);
    }    
    return $$;
  }
  
  dynamic _parse_logical_or_expression() {
    // SENTENCE (NONTERMINAL)
    // logical_or_expression <- logical_and_expression (logical_or_operator logical_and_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[13] >= pos) {
      $$ = _getFromCache(13);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[13] = pos;
    }  
    // => logical_and_expression (logical_or_operator logical_and_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => logical_and_expression (logical_or_operator logical_and_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => logical_and_expression
          $$ = _parse_logical_and_expression();
          // <= logical_and_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (logical_or_operator logical_and_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (logical_or_operator logical_and_expression) # Choice
            switch (_getState(_transitions6)) {
              // No matches
              // EOF
              case 0:
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: 
              _failure(_expect1);
            }
            // <= (logical_or_operator logical_and_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (logical_or_operator logical_and_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // logical_and_expression
            final $1 = seq[0];
            // (logical_or_operator logical_and_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= logical_and_expression (logical_or_operator logical_and_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= logical_and_expression (logical_or_operator logical_and_expression)* # Choice
    if (_cacheable[13]) {
      _addToCache($$, pos, 13);
    }    
    return $$;
  }
  
  dynamic _parse_lparen() {
    // SENTENCE (NONTERMINAL)
    // lparen <- '(' spaces
    var $$;
    // => '(' spaces # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => '(' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '('
          $$ = '(';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '('
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '('
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '(' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: (
      _failure(_expect18);
    }
    // <= '(' spaces # Choice
    return $$;
  }
  
  dynamic _parse_lsh() {
    // SENTENCE (NONTERMINAL)
    // lsh <- '<<' spaces
    var $$;
    // => '<<' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<<' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<<'
          $$ = _matchString(_strings0, '<<');
          // <= '<<'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '<<'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<<' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <<
      _failure(_expect28);
    }
    // <= '<<' spaces # Choice
    return $$;
  }
  
  dynamic _parse_lt() {
    // SENTENCE (NONTERMINAL)
    // lt <- '<' spaces
    var $$;
    // => '<' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<'
          $$ = '<';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '<'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '<'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <
      _failure(_expect30);
    }
    // <= '<' spaces # Choice
    return $$;
  }
  
  dynamic _parse_lte() {
    // SENTENCE (NONTERMINAL)
    // lte <- '<=' spaces
    var $$;
    // => '<=' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<='
          $$ = _matchString(_strings2, '<=');
          // <= '<='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '<='
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <=
      _failure(_expect32);
    }
    // <= '<=' spaces # Choice
    return $$;
  }
  
  dynamic _parse_minus() {
    // SENTENCE (NONTERMINAL)
    // minus <- '-' spaces
    var $$;          
    var pos = _cursor;             
    if(_cachePos[35] >= pos) {
      $$ = _getFromCache(35);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[35] = pos;
    }  
    // => '-' spaces # Choice
    switch (_ch == 45 ? 0 : _ch == -1 ? 2 : 1) {
      // [-]
      case 0:
        // => '-' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '-'
          $$ = '-';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '-'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '-'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '-' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: -
      _failure(_expect22);
    }
    // <= '-' spaces # Choice
    if (_cacheable[35]) {
      _addToCache($$, pos, 35);
    }    
    return $$;
  }
  
  dynamic _parse_multiplicative_expression() {
    // SENTENCE (NONTERMINAL)
    // multiplicative_expression <- unary_expression (multiplicative_operator unary_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[22] >= pos) {
      $$ = _getFromCache(22);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[22] = pos;
    }  
    // => unary_expression (multiplicative_operator unary_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => unary_expression (multiplicative_operator unary_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => unary_expression
          $$ = _parse_unary_expression();
          // <= unary_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (multiplicative_operator unary_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (multiplicative_operator unary_expression) # Choice
            switch (_getState(_transitions9)) {
              // [%] [*] [/]
              case 0:
                // => multiplicative_operator unary_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => multiplicative_operator
                  $$ = _parse_multiplicative_operator();
                  // <= multiplicative_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => unary_expression
                  $$ = _parse_unary_expression();
                  // <= unary_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= multiplicative_operator unary_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: *, /, %
              _failure(_expect12);
            }
            // <= (multiplicative_operator unary_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (multiplicative_operator unary_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // unary_expression
            final $1 = seq[0];
            // (multiplicative_operator unary_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= unary_expression (multiplicative_operator unary_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= unary_expression (multiplicative_operator unary_expression)* # Choice
    if (_cacheable[22]) {
      _addToCache($$, pos, 22);
    }    
    return $$;
  }
  
  dynamic _parse_multiplicative_operator() {
    // SENTENCE (NONTERMINAL)
    // multiplicative_operator <- asterisk / slash / percent
    var $$;
    // => asterisk / slash / percent # Choice
    switch (_getState(_transitions17)) {
      // [%]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => percent
        $$ = _parse_percent();
        // <= percent
        _startPos = startPos0;
        break;
      // [*]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => asterisk
        $$ = _parse_asterisk();
        // <= asterisk
        _startPos = startPos1;
        break;
      // [/]
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => slash
        $$ = _parse_slash();
        // <= slash
        _startPos = startPos2;
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: *, /, %
      _failure(_expect12);
    }
    // <= asterisk / slash / percent # Choice
    return $$;
  }
  
  dynamic _parse_percent() {
    // SENTENCE (NONTERMINAL)
    // percent <- '%' spaces
    var $$;
    // => '%' spaces # Choice
    switch (_ch == 37 ? 0 : _ch == -1 ? 2 : 1) {
      // [%]
      case 0:
        // => '%' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '%'
          $$ = '%';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '%'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '%'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '%' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: %
      _failure(_expect27);
    }
    // <= '%' spaces # Choice
    return $$;
  }
  
  dynamic _parse_plus() {
    // SENTENCE (NONTERMINAL)
    // plus <- '+' spaces
    var $$;          
    var pos = _cursor;             
    if(_cachePos[34] >= pos) {
      $$ = _getFromCache(34);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[34] = pos;
    }  
    // => '+' spaces # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        // => '+' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '+'
          $$ = '+';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '+'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '+'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '+' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: +
      _failure(_expect21);
    }
    // <= '+' spaces # Choice
    if (_cacheable[34]) {
      _addToCache($$, pos, 34);
    }    
    return $$;
  }
  
  dynamic _parse_primary_expression() {
    // SENTENCE (NONTERMINAL)
    // primary_expression <- sizeof / Identifier / constant / lparen expression rparen
    var $$;
    // => sizeof / Identifier / constant / lparen expression rparen # Choice
    switch (_getState(_transitions11)) {
      // [\'] [.] [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => constant
        $$ = _parse_constant();
        // <= constant
        _startPos = startPos0;
        break;
      // [(]
      case 1:
        // => lparen expression rparen # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => lparen
          $$ = _parse_lparen();
          // <= lparen
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => expression
          $$ = _parse_expression();
          // <= expression
          if (!success) break;
          seq[1] = $$;
          // => rparen
          $$ = _parse_rparen();
          // <= rparen
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // lparen
            final $1 = seq[0];
            // expression
            final $2 = seq[1];
            // rparen
            final $3 = seq[2];
            final $start = startPos1;
            $$ = new ParenthesisExpression(expression: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos1;
        // <= lparen expression rparen # Sequence
        break;
      // [A-Z]
      case 2:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => constant
          $$ = _parse_constant();
          // <= constant
          _startPos = startPos3;
          break;
        }
        break;
      // [\\] [_] [a-r] [t-z]
      // EOF
      case 3:
      case 6:
        var startPos4 = _startPos;
        _startPos = _cursor;
        // => Identifier
        $$ = _parse_Identifier();
        // <= Identifier
        _startPos = startPos4;
        break;
      // [s]
      case 4:
        while (true) {
          var startPos5 = _startPos;
          _startPos = _cursor;
          // => sizeof
          $$ = _parse_sizeof();
          // <= sizeof
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          _startPos = _cursor;
          // => Identifier
          $$ = _parse_Identifier();
          // <= Identifier
          _startPos = startPos6;
          break;
        }
        break;
      // No matches
      case 5:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, NONDIGIT, \U, \u
      _failure(_expect13);
    }
    // <= sizeof / Identifier / constant / lparen expression rparen # Choice
    return $$;
  }
  
  dynamic _parse_question_mark() {
    // SENTENCE (NONTERMINAL)
    // question_mark <- '?' spaces
    var $$;
    // => '?' spaces # Choice
    switch (_ch == 63 ? 0 : _ch == -1 ? 2 : 1) {
      // [?]
      case 0:
        // => '?' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '?'
          $$ = '?';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '?'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '?'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '?' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ?
      _failure(_expect41);
    }
    // <= '?' spaces # Choice
    return $$;
  }
  
  dynamic _parse_relational_expression() {
    // SENTENCE (NONTERMINAL)
    // relational_expression <- shift_expression (relational_operator shift_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[19] >= pos) {
      $$ = _getFromCache(19);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[19] = pos;
    }  
    // => shift_expression (relational_operator shift_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => shift_expression (relational_operator shift_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => shift_expression
          $$ = _parse_shift_expression();
          // <= shift_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (relational_operator shift_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (relational_operator shift_expression) # Choice
            switch (_getState(_transitions7)) {
              // [<] [>]
              case 0:
                // => relational_operator shift_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => relational_operator
                  $$ = _parse_relational_operator();
                  // <= relational_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => shift_expression
                  $$ = _parse_shift_expression();
                  // <= shift_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= relational_operator shift_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: <, >, <=, >=
              _failure(_expect9);
            }
            // <= (relational_operator shift_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (relational_operator shift_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // shift_expression
            final $1 = seq[0];
            // (relational_operator shift_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= shift_expression (relational_operator shift_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= shift_expression (relational_operator shift_expression)* # Choice
    if (_cacheable[19]) {
      _addToCache($$, pos, 19);
    }    
    return $$;
  }
  
  dynamic _parse_relational_operator() {
    // SENTENCE (NONTERMINAL)
    // relational_operator <- lt / gt / lte / gte
    var $$;
    // => lt / gt / lte / gte # Choice
    switch (_getState(_transitions19)) {
      // [<]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => lt
          $$ = _parse_lt();
          // <= lt
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => lte
          $$ = _parse_lte();
          // <= lte
          _startPos = startPos1;
          break;
        }
        break;
      // [>]
      case 1:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => gt
          $$ = _parse_gt();
          // <= gt
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => gte
          $$ = _parse_gte();
          // <= gte
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <, >, <=, >=
      _failure(_expect9);
    }
    // <= lt / gt / lte / gte # Choice
    return $$;
  }
  
  dynamic _parse_rparen() {
    // SENTENCE (NONTERMINAL)
    // rparen <- ')' spaces
    var $$;
    // => ')' spaces # Choice
    switch (_ch == 41 ? 0 : _ch == -1 ? 2 : 1) {
      // [)]
      case 0:
        // => ')' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ')'
          $$ = ')';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ')'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ')'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ')' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: )
      _failure(_expect19);
    }
    // <= ')' spaces # Choice
    return $$;
  }
  
  dynamic _parse_rsh() {
    // SENTENCE (NONTERMINAL)
    // rsh <- '>>' spaces
    var $$;
    // => '>>' spaces # Choice
    switch (_ch == 62 ? 0 : _ch == -1 ? 2 : 1) {
      // [>]
      case 0:
        // => '>>' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '>>'
          $$ = _matchString(_strings1, '>>');
          // <= '>>'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '>>'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '>>' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: >>
      _failure(_expect29);
    }
    // <= '>>' spaces # Choice
    return $$;
  }
  
  dynamic _parse_semicolon() {
    // SENTENCE (NONTERMINAL)
    // semicolon <- ':' spaces
    var $$;
    // => ':' spaces # Choice
    switch (_ch == 58 ? 0 : _ch == -1 ? 2 : 1) {
      // [:]
      case 0:
        // => ':' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ':'
          $$ = ':';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ':'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ':'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ':' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: :
      _failure(_expect42);
    }
    // <= ':' spaces # Choice
    return $$;
  }
  
  dynamic _parse_shift_expression() {
    // SENTENCE (NONTERMINAL)
    // shift_expression <- additive_expression (shift_operator additive_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[20] >= pos) {
      $$ = _getFromCache(20);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[20] = pos;
    }  
    // => additive_expression (shift_operator additive_expression)* # Choice
    switch (_getState(_transitions5)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      // EOF
      case 0:
      case 2:
        // => additive_expression (shift_operator additive_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => additive_expression
          $$ = _parse_additive_expression();
          // <= additive_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (shift_operator additive_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (shift_operator additive_expression) # Choice
            switch (_getState(_transitions7)) {
              // [<] [>]
              case 0:
                // => shift_operator additive_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => shift_operator
                  $$ = _parse_shift_operator();
                  // <= shift_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => additive_expression
                  $$ = _parse_additive_expression();
                  // <= additive_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= shift_operator additive_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: <<, >>
              _failure(_expect10);
            }
            // <= (shift_operator additive_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (shift_operator additive_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // additive_expression
            final $1 = seq[0];
            // (shift_operator additive_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= additive_expression (shift_operator additive_expression)* # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= additive_expression (shift_operator additive_expression)* # Choice
    if (_cacheable[20]) {
      _addToCache($$, pos, 20);
    }    
    return $$;
  }
  
  dynamic _parse_shift_operator() {
    // SENTENCE (NONTERMINAL)
    // shift_operator <- lsh / rsh
    var $$;
    // => lsh / rsh # Choice
    switch (_getState(_transitions19)) {
      // [<]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => lsh
        $$ = _parse_lsh();
        // <= lsh
        _startPos = startPos0;
        break;
      // [>]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => rsh
        $$ = _parse_rsh();
        // <= rsh
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <<, >>
      _failure(_expect10);
    }
    // <= lsh / rsh # Choice
    return $$;
  }
  
  dynamic _parse_sizeof() {
    // SENTENCE (NONTERMINAL)
    // sizeof <- SIZEOF OPEN_PAREN Type CLOSE_PAREN
    var $$;
    // => SIZEOF OPEN_PAREN Type CLOSE_PAREN # Choice
    switch (_ch == 115 ? 0 : _ch == -1 ? 2 : 1) {
      // [s]
      case 0:
        // => SIZEOF OPEN_PAREN Type CLOSE_PAREN # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => SIZEOF
          $$ = _parse_SIZEOF();
          // <= SIZEOF
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => OPEN_PAREN
          $$ = _parse_OPEN_PAREN();
          // <= OPEN_PAREN
          if (!success) break;
          seq[1] = $$;
          // => Type
          $$ = _parse_Type();
          // <= Type
          if (!success) break;
          seq[2] = $$;
          // => CLOSE_PAREN
          $$ = _parse_CLOSE_PAREN();
          // <= CLOSE_PAREN
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // SIZEOF
            final $1 = seq[0];
            // OPEN_PAREN
            final $2 = seq[1];
            // Type
            final $3 = seq[2];
            // CLOSE_PAREN
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new SizeofExpression(type: $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SIZEOF OPEN_PAREN Type CLOSE_PAREN # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof
      _failure(_expect14);
    }
    // <= SIZEOF OPEN_PAREN Type CLOSE_PAREN # Choice
    return $$;
  }
  
  dynamic _parse_slash() {
    // SENTENCE (NONTERMINAL)
    // slash <- '/' spaces
    var $$;
    // => '/' spaces # Choice
    switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
      // [/]
      case 0:
        // => '/' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '/'
          $$ = '/';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '/'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '/'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '/' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: /
      _failure(_expect26);
    }
    // <= '/' spaces # Choice
    return $$;
  }
  
  dynamic _parse_spaces() {
    // LEXEME (TOKEN)
    // spaces <- [\t ]*
    var $$;
    _token = 1;  
    _tokenStart = _cursor;  
    // => [\t ]* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\t ]*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => [\t ]
          $$ = _matchMapping(9, 32, _mapping0);
          // <= [\t ]
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= [\t ]*
        if (success) {    
          // [\t ]*
          final $1 = $$;
          final $start = startPos0;
          $$ = _text();
        }
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: spaces
      _failure(_expect73);
    }
    // <= [\t ]* # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_string_literal() {
    // SENTENCE (NONTERMINAL)
    // string_literal <- string_literal2 spaces
    var $$;
    // => string_literal2 spaces # Choice
    switch (_getState(_transitions37)) {
      // [\"] [L]
      case 0:
        // => string_literal2 spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => string_literal2
          $$ = _parse_string_literal2();
          // <= string_literal2
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // string_literal2
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= string_literal2 spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ", L"
      _failure(_expect56);
    }
    // <= string_literal2 spaces # Choice
    return $$;
  }
  
  dynamic _parse_string_literal2() {
    // SENTENCE (NONTERMINAL)
    // string_literal2 <- string_literal_base (spaces string_literal_base)*
    var $$;
    // => string_literal_base (spaces string_literal_base)* # Choice
    switch (_getState(_transitions37)) {
      // [\"] [L]
      case 0:
        // => string_literal_base (spaces string_literal_base)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => string_literal_base
          $$ = _parse_string_literal_base();
          // <= string_literal_base
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (spaces string_literal_base)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (spaces string_literal_base) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              case 0:
                // => spaces string_literal_base # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => spaces
                  $$ = _parse_spaces();
                  // <= spaces
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => string_literal_base
                  $$ = _parse_string_literal_base();
                  // <= string_literal_base
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= spaces string_literal_base # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: spaces, ", L"
              _failure(_expect57);
            }
            // <= (spaces string_literal_base) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (spaces string_literal_base)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // string_literal_base
            final $1 = seq[0];
            // (spaces string_literal_base)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new StringLiteral(text: _text(), value: _strValue(_list($1, $2)));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= string_literal_base (spaces string_literal_base)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ", L"
      _failure(_expect56);
    }
    // <= string_literal_base (spaces string_literal_base)* # Choice
    return $$;
  }
  
  dynamic _parse_string_literal_base() {
    // SENTENCE (NONTERMINAL)
    // string_literal_base <- '"' S_CHAR_SEQUENCE? '"' / 'L"' S_CHAR_SEQUENCE? '"'
    var $$;          
    var pos = _cursor;             
    if(_cachePos[142] >= pos) {
      $$ = _getFromCache(142);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[142] = pos;
    }  
    // => '"' S_CHAR_SEQUENCE? '"' / 'L"' S_CHAR_SEQUENCE? '"' # Choice
    switch (_getState(_transitions45)) {
      // [\"]
      case 0:
        // => '"' S_CHAR_SEQUENCE? '"' # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '"'
          $$ = '\"';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '"'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => S_CHAR_SEQUENCE?
          var testing0 = _testing;
          _testing = _cursor;
          // => S_CHAR_SEQUENCE
          $$ = _parse_S_CHAR_SEQUENCE();
          // <= S_CHAR_SEQUENCE
          success = true; 
          _testing = testing0;
          // <= S_CHAR_SEQUENCE?
          if (!success) break;
          seq[1] = $$;
          // => '"'
          $$ = _matchChar(34, '\"');
          // <= '"'
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '"'
            final $1 = seq[0];
            // S_CHAR_SEQUENCE?
            final $2 = seq[1];
            // '"'
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '"' S_CHAR_SEQUENCE? '"' # Sequence
        break;
      // [L]
      case 1:
        // => 'L"' S_CHAR_SEQUENCE? '"' # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'L"'
          $$ = _matchString(_strings48, 'L\"');
          // <= 'L"'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => S_CHAR_SEQUENCE?
          var testing1 = _testing;
          _testing = _cursor;
          // => S_CHAR_SEQUENCE
          $$ = _parse_S_CHAR_SEQUENCE();
          // <= S_CHAR_SEQUENCE
          success = true; 
          _testing = testing1;
          // <= S_CHAR_SEQUENCE?
          if (!success) break;
          seq[1] = $$;
          // => '"'
          $$ = _matchChar(34, '\"');
          // <= '"'
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'L"'
            final $1 = seq[0];
            // S_CHAR_SEQUENCE?
            final $2 = seq[1];
            // '"'
            final $3 = seq[2];
            final $start = startPos1;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= 'L"' S_CHAR_SEQUENCE? '"' # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ", L"
      _failure(_expect56);
    }
    // <= '"' S_CHAR_SEQUENCE? '"' / 'L"' S_CHAR_SEQUENCE? '"' # Choice
    if (_cacheable[142]) {
      _addToCache($$, pos, 142);
    }    
    return $$;
  }
  
  dynamic _parse_tilde() {
    // SENTENCE (NONTERMINAL)
    // tilde <- '~' spaces
    var $$;
    // => '~' spaces # Choice
    switch (_ch == 126 ? 0 : _ch == -1 ? 2 : 1) {
      // [~]
      case 0:
        // => '~' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '~'
          $$ = '~';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '~'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '~'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '~' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ~
      _failure(_expect23);
    }
    // <= '~' spaces # Choice
    return $$;
  }
  
  dynamic _parse_unary_expression() {
    // SENTENCE (NONTERMINAL)
    // unary_expression <- primary_expression / unary_operator unary_expression
    var $$;          
    var pos = _cursor;             
    if(_cachePos[23] >= pos) {
      $$ = _getFromCache(23);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[23] = pos;
    }  
    // => primary_expression / unary_operator unary_expression # Choice
    switch (_getState(_transitions10)) {
      // [!] [+] [-] [~]
      case 0:
        // => unary_operator unary_expression # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => unary_operator
          $$ = _parse_unary_operator();
          // <= unary_operator
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => unary_expression
          $$ = _parse_unary_expression();
          // <= unary_expression
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // unary_operator
            final $1 = seq[0];
            // unary_expression
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _unary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= unary_operator unary_expression # Sequence
        break;
      // [\'-(] [.] [0-9] [A-Z] [\\] [_] [a-z]
      // EOF
      case 1:
      case 3:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => primary_expression
        $$ = _parse_primary_expression();
        // <= primary_expression
        _startPos = startPos1;
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sizeof, ., DIGIT, HEXADECIMAL_PREFIX, NONZERO_DIGIT, '0', ', L', (, +, -, ~, !, NONDIGIT, \U, \u
      _failure(_expect8);
    }
    // <= primary_expression / unary_operator unary_expression # Choice
    if (_cacheable[23]) {
      _addToCache($$, pos, 23);
    }    
    return $$;
  }
  
  dynamic _parse_unary_operator() {
    // SENTENCE (NONTERMINAL)
    // unary_operator <- plus / minus / tilde / exclamation
    var $$;
    // => plus / minus / tilde / exclamation # Choice
    switch (_getState(_transitions16)) {
      // [!]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => exclamation
        $$ = _parse_exclamation();
        // <= exclamation
        _startPos = startPos0;
        break;
      // [+]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => plus
        $$ = _parse_plus();
        // <= plus
        _startPos = startPos1;
        break;
      // [-]
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => minus
        $$ = _parse_minus();
        // <= minus
        _startPos = startPos2;
        break;
      // [~]
      case 3:
        var startPos3 = _startPos;
        _startPos = _cursor;
        // => tilde
        $$ = _parse_tilde();
        // <= tilde
        _startPos = startPos3;
        break;
      // No matches
      // EOF
      case 4:
      case 5:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: +, -, ~, !
      _failure(_expect20);
    }
    // <= plus / minus / tilde / exclamation # Choice
    return $$;
  }
  
  String _text([int offset = 0]) {
    return new String.fromCharCodes(_input.sublist(_startPos + offset, _cursor));
  }
  
  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }
  
    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }
  
    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }
  
    return start;
  }
  
  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }
  
    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }
  
    codePoints.length = pos;
    return codePoints;
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<CParserError> errors() {
    if (success) {
      return <CParserError>[];
    }
  
    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    } 
    
    String getc(int position) {  
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";      
      }       
      return "end of file";
    }
  
    var errors = <CParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<CParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();  
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new CParserError(CParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {      
        var found = getc(_failurePos);      
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new CParserError(CParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }        
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;  
  }
  
  dynamic parse_Declarations() {
    // SENTENCE (NONTERMINAL)
    // Declarations <- LEADING_SPACES? DeclarationList? EOF
    var $$;
    // => LEADING_SPACES? DeclarationList? EOF # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        // => LEADING_SPACES? DeclarationList? EOF # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => LEADING_SPACES?
          var testing0 = _testing;
          _testing = _cursor;
          // => LEADING_SPACES
          $$ = _parse_LEADING_SPACES();
          // <= LEADING_SPACES
          success = true; 
          _testing = testing0;
          // <= LEADING_SPACES?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => DeclarationList?
          var testing1 = _testing;
          _testing = _cursor;
          // => DeclarationList
          $$ = _parse_DeclarationList();
          // <= DeclarationList
          success = true; 
          _testing = testing1;
          // <= DeclarationList?
          if (!success) break;
          seq[1] = $$;
          // => EOF
          $$ = _parse_EOF();
          // <= EOF
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // LEADING_SPACES?
            final $1 = seq[0];
            // DeclarationList?
            final $2 = seq[1];
            // EOF
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= LEADING_SPACES? DeclarationList? EOF # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= LEADING_SPACES? DeclarationList? EOF # Choice
    return $$;
  }
  
  dynamic parse_ampersand() {
    // SENTENCE (NONTERMINAL)
    // ampersand <- '&' spaces
    var $$;
    // => '&' spaces # Choice
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      // [&]
      case 0:
        // => '&' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '&'
          $$ = '&';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '&'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '&'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '&' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: &
      _failure(_expect36);
    }
    // <= '&' spaces # Choice
    return $$;
  }
  
  dynamic parse_ampersand2() {
    // SENTENCE (NONTERMINAL)
    // ampersand2 <- '&&' spaces
    var $$;
    // => '&&' spaces # Choice
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      // [&]
      case 0:
        // => '&&' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '&&'
          $$ = _matchString(_strings6, '&&');
          // <= '&&'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '&&'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '&&' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: &&
      _failure(_expect39);
    }
    // <= '&&' spaces # Choice
    return $$;
  }
  
  dynamic parse_eq() {
    // SENTENCE (NONTERMINAL)
    // eq <- '==' spaces
    var $$;
    // => '==' spaces # Choice
    switch (_ch == 61 ? 0 : _ch == -1 ? 2 : 1) {
      // [=]
      case 0:
        // => '==' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '=='
          $$ = _matchString(_strings4, '==');
          // <= '=='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '=='
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '==' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ==
      _failure(_expect34);
    }
    // <= '==' spaces # Choice
    return $$;
  }
  
  dynamic parse_neq() {
    // SENTENCE (NONTERMINAL)
    // neq <- '!=' spaces
    var $$;
    // => '!=' spaces # Choice
    switch (_ch == 33 ? 0 : _ch == -1 ? 2 : 1) {
      // [!]
      case 0:
        // => '!=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '!='
          $$ = _matchString(_strings5, '!=');
          // <= '!='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '!='
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '!=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: !=
      _failure(_expect35);
    }
    // <= '!=' spaces # Choice
    return $$;
  }
  
  dynamic parse_vertical_line() {
    // SENTENCE (NONTERMINAL)
    // vertical_line <- '|' spaces
    var $$;
    // => '|' spaces # Choice
    switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
      // [|]
      case 0:
        // => '|' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '|'
          $$ = '|';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '|'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '|'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '|' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: |
      _failure(_expect38);
    }
    // <= '|' spaces # Choice
    return $$;
  }
  
  dynamic parse_vertical_line2() {
    // SENTENCE (NONTERMINAL)
    // vertical_line2 <- '||' spaces
    var $$;
    // => '||' spaces # Choice
    switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
      // [|]
      case 0:
        // => '||' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '||'
          $$ = _matchString(_strings7, '||');
          // <= '||'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '||'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '||' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ||
      _failure(_expect40);
    }
    // <= '||' spaces # Choice
    return $$;
  }
  
  dynamic parse_xor() {
    // SENTENCE (NONTERMINAL)
    // xor <- '^' spaces
    var $$;
    // => '^' spaces # Choice
    switch (_ch == 94 ? 0 : _ch == -1 ? 2 : 1) {
      // [^]
      case 0:
        // => '^' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '^'
          $$ = '^';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '^'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '^'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '^' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ^
      _failure(_expect37);
    }
    // <= '^' spaces # Choice
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }      
    _cursor = pos;
    _cache = new List<Map<int, List>>(193);
    _cachePos = new List<int>.filled(193, -1);  
    _cacheable = new List<bool>.filled(193, false);
    _ch = -1;
    _errors = <CParserError>[];   
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;        
    _testing = -1;
    _token = null;
    _tokenStart = null;  
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;    
  }
  
}

class CParserError {
  static const int EXPECTED = 1;    
      
  static const int MALFORMED = 2;    
      
  static const int MISSING = 3;    
      
  static const int UNEXPECTED = 4;    
      
  static const int UNTERMINATED = 5;    
      
  final int hashCode = 0;
  
  final String message;
  
  final int position;
  
  final int start;
  
  final int type;
  
  CParserError(this.type, this.position, this.start, this.message);
  
  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is CParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;  
    }
    return false;
  }
  
}

